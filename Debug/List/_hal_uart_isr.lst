###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        24/Mar/2015  22:02:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\New folder\_hal_uart_isr.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\New folder\_hal_uart_isr.c" -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=NO
#        -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1 --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -On
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\_hal_uart_isr.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\_hal_uart_isr.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\New folder\_hal_uart_isr.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart_isr.c
      3            Revised:        $Date: 2014-07-29 21:18:07 -0700 (Tue, 29 Jul 2014) $
      4            Revision:       $Revision: 39577 $
      5          
      6            Description:    This file contains the interface to the UART.
      7          
      8          
      9            Copyright 2013-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board.h"
     46          #include "hal_types.h"
     47          #include "hal_uart.h"
     48          #include "OSAL.h"
     49          #include "OSAL_Timers.h"
     50          #include "hw_ioc.h"
     51          #include "hw_uart.h"
     52          
     53          /* ------------------------------------------------------------------------------------------------
     54           *                                           Constants
     55           * ------------------------------------------------------------------------------------------------
     56           */
     57          #define HAL_UART_PORT                      UART1_BASE
     58          #define HAL_UART_SYS_CTRL                  SYS_CTRL_PERIPH_UART1
     59          #define HAL_UART_INT_CTRL                  INT_UART1
     60          #define HalUartISR                         interrupt_uart1
     61          
     62          /* ------------------------------------------------------------------------------------------------
     63           *                                           Local Variables
     64           * ------------------------------------------------------------------------------------------------
     65           */
     66          

   \                                 In section .rodata, align 4
     67          const uint32 UBRRTable[] = {
   \                     UBRRTable:
   \   00000000   0x00002580         DC32 9600, 19200, 38400, 57600, 115200
   \              0x00004B00   
   \              0x00009600   
   \              0x0000E100   
   \              0x0001C200   
     68            9600,
     69            19200,
     70            38400,
     71            57600,
     72            115200
     73          };
     74          

   \                                 In section .bss, align 4
     75          static halUARTCfg_t uartRecord;
   \                     uartRecord:
   \   00000000                      DS8 44

   \                                 In section .bss, align 1
     76          static bool txMT;
   \                     txMT:
   \   00000000                      DS8 1
     77          
     78          /* ------------------------------------------------------------------------------------------------
     79           *                                           Local Functions
     80           * ------------------------------------------------------------------------------------------------
     81           */
     82          
     83          static void recRst(void);
     84          static void procRx(void);
     85          static void procTx(void);
     86          
     87          /* ------------------------------------------------------------------------------------------------
     88           *                                           Global Functions
     89           * ------------------------------------------------------------------------------------------------
     90           */
     91          
     92          void interrupt_uart(void);
     93          void HalUARTInitIsr(void);
     94          uint8 HalUARTOpenIsr(uint8 port, halUARTCfg_t *config);
     95          void HalUARTPollIsr(void);
     96          void HalUARTCloseIsr(uint8 port);
     97          uint16 HalUARTReadIsr ( uint8 port, uint8 *pBuffer, uint16 length );
     98          uint16 HalUARTWriteIsr(uint8 port, uint8 *pBuffer, uint16 length);
     99          uint16 Hal_UART_RxBufLenIsr(uint8 port);
    100          void HalUartISR(void);
    101          
    102          /*************************************************************************************************
    103           * @fn      HalUARTInitIsr()
    104           *
    105           * @brief   Initialize the UART
    106           *
    107           * @param   none
    108           *
    109           * @return  none
    110           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    111          void HalUARTInitIsr(void)
    112          {
   \                     HalUARTInitIsr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    113             SysCtrlPeripheralEnable(HAL_UART_SYS_CTRL);
   \   00000002   0xF240 0x2001      MOVW     R0,#+513
   \   00000006   0x.... 0x....      BL       SysCtrlPeripheralEnable
    114          
    115            /* Setup PB0 as UART_CTS, PD3 as UART_RTS  
    116             * PA1 as UART_TX and PA0 as UART_RX
    117             */ 
    118            IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_1, IOC_MUX_OUT_SEL_UART1_TXD);
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400d9000
   \   00000012   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    119            IOCPinConfigPeriphInput(GPIO_A_BASE, GPIO_PIN_0, IOC_UARTRXD_UART1);
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable11_1  ;; 0x400d4108
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400d9000
   \   00000020   0x.... 0x....      BL       IOCPinConfigPeriphInput
    120            GPIOPinTypeUARTInput(GPIO_A_BASE, GPIO_PIN_0);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400d9000
   \   0000002A   0x.... 0x....      BL       GPIOPinTypeUARTInput
    121            GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_1);  
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400d9000
   \   00000034   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    122            recRst();
   \   00000038   0x.... 0x....      BL       recRst
    123          
    124          }
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    125          
    126          /*************************************************************************************************
    127           * @fn      HalUARTOpenIsr()
    128           *
    129           * @brief   Open a port based on the configuration
    130           *
    131           * @param   port   - UART port
    132           *          config - contains configuration information
    133           *          cBack  - Call back function where events will be reported back
    134           *
    135           * @return  Status of the function call
    136           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          uint8 HalUARTOpenIsr(uint8 port, halUARTCfg_t *config)
    138          {
   \                     HalUARTOpenIsr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    139            if (uartRecord.configured)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??HalUARTOpenIsr_0
    140            {
    141              HalUARTClose(port);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       HalUARTClose
    142            }
    143          
    144            if (config->baudRate > HAL_UART_BR_115200)
   \                     ??HalUARTOpenIsr_0: (+1)
   \   00000018   0x7868             LDRB     R0,[R5, #+1]
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xDB01             BLT.N    ??HalUARTOpenIsr_1
    145            {
    146              return HAL_UART_BAUDRATE_ERROR;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE0A4             B.N      ??HalUARTOpenIsr_2
    147            }
    148          
    149            if (((uartRecord.rx.pBuffer = osal_mem_alloc(config->rx.maxBufSize)) == NULL) ||
    150                ((uartRecord.tx.pBuffer = osal_mem_alloc(config->tx.maxBufSize)) == NULL))
   \                     ??HalUARTOpenIsr_1: (+1)
   \   00000022   0x89A8             LDRH     R0,[R5, #+12]
   \   00000024   0x.... 0x....      BL       osal_mem_alloc
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000002C   0x6108             STR      R0,[R1, #+16]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000032   0x6900             LDR      R0,[R0, #+16]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00A             BEQ.N    ??HalUARTOpenIsr_3
   \   00000038   0x8B28             LDRH     R0,[R5, #+24]
   \   0000003A   0x.... 0x....      BL       osal_mem_alloc
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000042   0x61C8             STR      R0,[R1, #+28]
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000048   0x69C0             LDR      R0,[R0, #+28]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD10F             BNE.N    ??HalUARTOpenIsr_4
    151            {
    152              if (uartRecord.rx.pBuffer != NULL)
   \                     ??HalUARTOpenIsr_3: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000052   0x6900             LDR      R0,[R0, #+16]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD008             BEQ.N    ??HalUARTOpenIsr_5
    153              {
    154                osal_mem_free(uartRecord.rx.pBuffer);
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000005C   0x6900             LDR      R0,[R0, #+16]
   \   0000005E   0x.... 0x....      BL       osal_mem_free
    155                uartRecord.rx.pBuffer = NULL;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000068   0x6108             STR      R0,[R1, #+16]
    156              }
    157          
    158              return HAL_UART_MEM_FAIL;
   \                     ??HalUARTOpenIsr_5: (+1)
   \   0000006A   0x2003             MOVS     R0,#+3
   \   0000006C   0xE07E             B.N      ??HalUARTOpenIsr_2
    159            }
    160            
    161            if(config->flowControl)
   \                     ??HalUARTOpenIsr_4: (+1)
   \   0000006E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD016             BEQ.N    ??HalUARTOpenIsr_6
    162            {
    163              IOCPinConfigPeriphOutput(GPIO_D_BASE, GPIO_PIN_3, IOC_MUX_OUT_SEL_UART1_RTS);
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x2108             MOVS     R1,#+8
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x400dc000
   \   0000007C   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    164              GPIOPinTypeUARTOutput(GPIO_D_BASE, GPIO_PIN_3);
   \   00000080   0x2108             MOVS     R1,#+8
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x400dc000
   \   00000086   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    165              IOCPinConfigPeriphInput(GPIO_B_BASE, GPIO_PIN_0, IOC_UARTCTS_UART1);
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable11_4  ;; 0x400d4104
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x400da000
   \   00000094   0x.... 0x....      BL       IOCPinConfigPeriphInput
    166              GPIOPinTypeUARTInput(GPIO_B_BASE, GPIO_PIN_0);
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x400da000
   \   0000009E   0x.... 0x....      BL       GPIOPinTypeUARTInput
    167            }
    168            
    169            IntEnable(HAL_UART_INT_CTRL);
   \                     ??HalUARTOpenIsr_6: (+1)
   \   000000A2   0x2016             MOVS     R0,#+22
   \   000000A4   0x.... 0x....      BL       IntEnable
    170          
    171            uartRecord.configured = TRUE;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
    172            uartRecord.baudRate = config->baudRate;
   \   000000B0   0x7868             LDRB     R0,[R5, #+1]
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000B6   0x7048             STRB     R0,[R1, #+1]
    173            uartRecord.flowControl = config->flowControl;
   \   000000B8   0x78A8             LDRB     R0,[R5, #+2]
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000BE   0x7088             STRB     R0,[R1, #+2]
    174            uartRecord.flowControlThreshold = (config->flowControlThreshold > config->rx.maxBufSize) ? 0 :
    175                                               config->flowControlThreshold;
   \   000000C0   0x89A8             LDRH     R0,[R5, #+12]
   \   000000C2   0x88A9             LDRH     R1,[R5, #+4]
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD204             BCS.N    ??HalUARTOpenIsr_7
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000CE   0x8088             STRH     R0,[R1, #+4]
   \   000000D0   0xE003             B.N      ??HalUARTOpenIsr_8
   \                     ??HalUARTOpenIsr_7: (+1)
   \   000000D2   0x88A8             LDRH     R0,[R5, #+4]
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000D8   0x8088             STRH     R0,[R1, #+4]
    176            uartRecord.idleTimeout = config->idleTimeout;
   \                     ??HalUARTOpenIsr_8: (+1)
   \   000000DA   0x79A8             LDRB     R0,[R5, #+6]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000E0   0x7188             STRB     R0,[R1, #+6]
    177            uartRecord.rx.maxBufSize = config->rx.maxBufSize;
   \   000000E2   0x89A8             LDRH     R0,[R5, #+12]
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000E8   0x8188             STRH     R0,[R1, #+12]
    178            uartRecord.tx.maxBufSize = config->tx.maxBufSize;
   \   000000EA   0x8B28             LDRH     R0,[R5, #+24]
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000F0   0x8308             STRH     R0,[R1, #+24]
    179            uartRecord.intEnable = config->intEnable;
   \   000000F2   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   000000FA   0xF881 0x0020      STRB     R0,[R1, #+32]
    180            uartRecord.callBackFunc = config->callBackFunc;
   \   000000FE   0x6AA8             LDR      R0,[R5, #+40]
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000104   0x6288             STR      R0,[R1, #+40]
    181          
    182            UARTConfigSetExpClk(HAL_UART_PORT, SysCtrlClockGet(), UBRRTable[uartRecord.baudRate],
    183                                   (UART_CONFIG_WLEN_8 | UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE));
   \   00000106   0x.... 0x....      BL       SysCtrlClockGet
   \   0000010A   0x2360             MOVS     R3,#+96
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000110   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000114   0x7852             LDRB     R2,[R2, #+1]
   \   00000116   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   \   0000011A   0x0001             MOVS     R1,R0
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x4000d000
   \   00000120   0x.... 0x....      BL       UARTConfigSetExpClk
    184          
    185            /* FIFO level set to 1/8th for both RX and TX which is 2 bytes */
    186            UARTFIFOLevelSet(HAL_UART_PORT, UART_FIFO_TX1_8, UART_FIFO_RX1_8);
   \   00000124   0x2200             MOVS     R2,#+0
   \   00000126   0x2100             MOVS     R1,#+0
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x4000d000
   \   0000012C   0x.... 0x....      BL       UARTFIFOLevelSet
    187            UARTFIFOEnable(HAL_UART_PORT);
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x4000d000
   \   00000134   0x.... 0x....      BL       UARTFIFOEnable
    188          
    189            /* Clear and enable UART TX, RX, CTS and Recieve Timeout interrupt */
    190            UARTIntClear(HAL_UART_PORT, (UART_INT_RX | UART_INT_TX | UART_INT_CTS | UART_INT_RT ));
   \   00000138   0x2172             MOVS     R1,#+114
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x4000d000
   \   0000013E   0x.... 0x....      BL       UARTIntClear
    191            UARTIntEnable(HAL_UART_PORT, (UART_INT_RX | UART_INT_TX | UART_INT_CTS | UART_INT_RT ));
   \   00000142   0x2172             MOVS     R1,#+114
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x4000d000
   \   00000148   0x.... 0x....      BL       UARTIntEnable
    192            
    193            if(config->flowControl)
   \   0000014C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD007             BEQ.N    ??HalUARTOpenIsr_9
    194            {
    195              /* Enable hardware flow control by enabling CTS and RTS */
    196              HWREG(HAL_UART_PORT + UART_O_CTL) |= (UART_CTL_CTSEN | UART_CTL_RTSEN );
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x4000d030
   \   00000156   0x6800             LDR      R0,[R0, #+0]
   \   00000158   0xF450 0x4040      ORRS     R0,R0,#0xC000
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable11_8  ;; 0x4000d030
   \   00000160   0x6008             STR      R0,[R1, #+0]
    197            }
    198            UARTEnable(HAL_UART_PORT);
   \                     ??HalUARTOpenIsr_9: (+1)
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x4000d000
   \   00000166   0x.... 0x....      BL       UARTEnable
    199          
    200            return HAL_UART_SUCCESS;
   \   0000016A   0x2000             MOVS     R0,#+0
   \                     ??HalUARTOpenIsr_2: (+1)
   \   0000016C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    201          }
    202          
    203          /*************************************************************************************************
    204           * @fn      Hal_UARTPollIsr
    205           *
    206           * @brief   This routine simulate polling and has to be called by the main loop
    207           *
    208           * @param   void
    209           *
    210           * @return  void
    211           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    212          void HalUARTPollIsr(void)
    213          {
   \                     HalUARTPollIsr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    214            uint16 head = uartRecord.tx.bufferHead;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000006   0x8A84             LDRH     R4,[R0, #+20]
    215            uint16 tail = uartRecord.tx.bufferTail;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000000C   0x8AC5             LDRH     R5,[R0, #+22]
    216            /* If port is not configured, no point to poll it. */
    217            if (!uartRecord.configured)  
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD054             BEQ.N    ??HalUARTPollIsr_0
    218            {
    219              return;
    220            }
    221          
    222            halIntState_t intState;
    223            HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??HalUARTPollIsr_1: (+1)
   \   00000018   0x.... 0x....      BL       IntMasterDisable
   \   0000001C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000020   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000024   0x0006             MOVS     R6,R0
    224            procRx();
   \   00000026   0x.... 0x....      BL       procRx
    225            procTx();
   \   0000002A   0x.... 0x....      BL       procTx
    226            HAL_EXIT_CRITICAL_SECTION(intState);
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD001             BEQ.N    ??HalUARTPollIsr_2
   \   00000034   0x.... 0x....      BL       IntMasterEnable
    227          
    228            uint8 evts = 0;
   \                     ??HalUARTPollIsr_2: (+1)
   \   00000038   0x2700             MOVS     R7,#+0
    229            /* Report if Rx Buffer is full. */
    230            if ((Hal_UART_RxBufLen(0) + 1) >= uartRecord.rx.maxBufSize)  
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       Hal_UART_RxBufLen
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable11_2
   \   00000046   0x8989             LDRH     R1,[R1, #+12]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xDB01             BLT.N    ??HalUARTPollIsr_3
    231            {
    232              evts = HAL_UART_RX_FULL;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x0007             MOVS     R7,R0
    233            }
    234          
    235            /* Report if Rx Buffer is idled. */
    236            if ((uartRecord.rxChRvdTime != 0) &&  
    237               ((osal_GetSystemClock() - uartRecord.rxChRvdTime) > uartRecord.idleTimeout))
   \                     ??HalUARTPollIsr_3: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable11_2
   \   00000052   0x6A40             LDR      R0,[R0, #+36]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD00D             BEQ.N    ??HalUARTPollIsr_4
   \   00000058   0x.... 0x....      BL       osal_GetSystemClock
   \   0000005C   0x....             LDR.N    R1,??DataTable11_2
   \   0000005E   0x7989             LDRB     R1,[R1, #+6]
   \   00000060   0x....             LDR.N    R2,??DataTable11_2
   \   00000062   0x6A52             LDR      R2,[R2, #+36]
   \   00000064   0x1A80             SUBS     R0,R0,R2
   \   00000066   0x4281             CMP      R1,R0
   \   00000068   0xD204             BCS.N    ??HalUARTPollIsr_4
    238            {
    239              uartRecord.rxChRvdTime = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x....             LDR.N    R1,??DataTable11_2
   \   0000006E   0x6248             STR      R0,[R1, #+36]
    240              evts |= HAL_UART_RX_TIMEOUT;
   \   00000070   0xF057 0x0704      ORRS     R7,R7,#0x4
    241            }
    242          
    243            if (Hal_UART_RxBufLen(0) >= uartRecord.rx.maxBufSize - uartRecord.flowControlThreshold)
   \                     ??HalUARTPollIsr_4: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      BL       Hal_UART_RxBufLen
   \   0000007A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007C   0x....             LDR.N    R1,??DataTable11_2
   \   0000007E   0x8989             LDRH     R1,[R1, #+12]
   \   00000080   0x....             LDR.N    R2,??DataTable11_2
   \   00000082   0x8892             LDRH     R2,[R2, #+4]
   \   00000084   0x1A89             SUBS     R1,R1,R2
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDB01             BLT.N    ??HalUARTPollIsr_5
    244            {
    245              evts |= HAL_UART_RX_ABOUT_FULL;
   \   0000008A   0xF057 0x0702      ORRS     R7,R7,#0x2
    246            }
    247          
    248            if (!txMT && (head == tail))
   \                     ??HalUARTPollIsr_5: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable11_9
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD108             BNE.N    ??HalUARTPollIsr_6
   \   00000096   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000098   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009A   0x42AC             CMP      R4,R5
   \   0000009C   0xD104             BNE.N    ??HalUARTPollIsr_6
    249            {
    250              txMT = true;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x....             LDR.N    R1,??DataTable11_9
   \   000000A2   0x7008             STRB     R0,[R1, #+0]
    251              evts |= HAL_UART_TX_EMPTY;
   \   000000A4   0xF057 0x0710      ORRS     R7,R7,#0x10
    252            }
    253          
    254            if (evts && uartRecord.callBackFunc)
   \                     ??HalUARTPollIsr_6: (+1)
   \   000000A8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AA   0x2F00             CMP      R7,#+0
   \   000000AC   0xD009             BEQ.N    ??HalUARTPollIsr_7
   \   000000AE   0x....             LDR.N    R0,??DataTable11_2
   \   000000B0   0x6A80             LDR      R0,[R0, #+40]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD005             BEQ.N    ??HalUARTPollIsr_7
    255            {
    256              (uartRecord.callBackFunc)(0, evts);
   \   000000B6   0x0039             MOVS     R1,R7
   \   000000B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x....             LDR.N    R2,??DataTable11_2
   \   000000BE   0x6A92             LDR      R2,[R2, #+40]
   \   000000C0   0x4790             BLX      R2
    257            }
    258          
    259          }
   \                     ??HalUARTPollIsr_7: (+1)
   \                     ??HalUARTPollIsr_0: (+1)
   \   000000C2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    260          
    261          /*************************************************************************************************
    262           * @fn      HalUARTCloseIsr()
    263           *
    264           * @brief   Close the UART
    265           *
    266           * @param   port - UART port (not used.)
    267           *
    268           * @return  none
    269           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    270          void HalUARTCloseIsr(uint8 port)
    271          {
   \                     HalUARTCloseIsr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    272            (void)port;
    273          
    274            UARTDisable(HAL_UART_PORT);
   \   00000004   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4000d000
   \   00000006   0x.... 0x....      BL       UARTDisable
    275          
    276            if (uartRecord.configured)
   \   0000000A   0x....             LDR.N    R0,??DataTable11_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD009             BEQ.N    ??HalUARTCloseIsr_0
    277            {
    278              (void)osal_mem_free(uartRecord.rx.pBuffer);
   \   00000012   0x....             LDR.N    R0,??DataTable11_2
   \   00000014   0x6900             LDR      R0,[R0, #+16]
   \   00000016   0x.... 0x....      BL       osal_mem_free
    279              (void)osal_mem_free(uartRecord.tx.pBuffer);
   \   0000001A   0x....             LDR.N    R0,??DataTable11_2
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x.... 0x....      BL       osal_mem_free
    280              recRst();
   \   00000022   0x.... 0x....      BL       recRst
    281            }
    282          }
   \                     ??HalUARTCloseIsr_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    283          
    284          /*************************************************************************************************
    285           * @fn      HalUARTReadIsr()
    286           *
    287           * @brief   Read a buffer from the UART
    288           *
    289           * @param   port - UART port (not used.)
    290           *          ppBuffer - pointer to a pointer that points to the data that will be read
    291           *          length - length of the requested buffer
    292           *
    293           * @return  length of buffer that was read
    294           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          uint16 HalUARTReadIsr ( uint8 port, uint8 *pBuffer, uint16 length )
    296          {
   \                     HalUARTReadIsr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    297            uint16 cnt, idx;
    298            (void)port;
    299          
    300            /* If port is not configured, no point to read it. */
    301            if (!uartRecord.configured)
   \   0000000A   0x....             LDR.N    R0,??DataTable11_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??HalUARTReadIsr_0
    302            {
    303              return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE02A             B.N      ??HalUARTReadIsr_1
    304            }
    305          
    306            /* If requested length is bigger than what in 
    307             * buffer, re-adjust it to the buffer length.
    308             */
    309            cnt = Hal_UART_RxBufLen(0);
   \                     ??HalUARTReadIsr_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       Hal_UART_RxBufLen
   \   0000001C   0x0007             MOVS     R7,R0
    310            if (cnt < length)
   \   0000001E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x42B7             CMP      R7,R6
   \   00000024   0xD200             BCS.N    ??HalUARTReadIsr_2
    311            {
    312              length = cnt;
   \   00000026   0x003E             MOVS     R6,R7
    313            }
    314          
    315            idx = uartRecord.rx.bufferHead;
   \                     ??HalUARTReadIsr_2: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable11_2
   \   0000002A   0x8900             LDRH     R0,[R0, #+8]
   \   0000002C   0x4680             MOV      R8,R0
    316            for (cnt = 0; cnt < length; cnt++)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0007             MOVS     R7,R0
   \                     ??HalUARTReadIsr_3: (+1)
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000036   0x42B7             CMP      R7,R6
   \   00000038   0xD213             BCS.N    ??HalUARTReadIsr_4
    317            {
    318              pBuffer[cnt] = uartRecord.rx.pBuffer[idx++];
   \   0000003A   0x....             LDR.N    R0,??DataTable11_2
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000042   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000046   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000048   0x5578             STRB     R0,[R7, R5]
   \   0000004A   0xF118 0x0801      ADDS     R8,R8,#+1
    319          
    320              if (idx >= uartRecord.rx.maxBufSize)
   \   0000004E   0x....             LDR.N    R0,??DataTable11_2
   \   00000050   0x8980             LDRH     R0,[R0, #+12]
   \   00000052   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000056   0x4580             CMP      R8,R0
   \   00000058   0xD301             BCC.N    ??HalUARTReadIsr_5
    321              {
    322                idx = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x4680             MOV      R8,R0
    323              }
    324            }
   \                     ??HalUARTReadIsr_5: (+1)
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
   \   00000060   0xE7E7             B.N      ??HalUARTReadIsr_3
    325            uartRecord.rx.bufferHead = idx;
   \                     ??HalUARTReadIsr_4: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable11_2
   \   00000064   0xF8A0 0x8008      STRH     R8,[R0, #+8]
    326          
    327            /* Return number of bytes read. */
    328            return length;  
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??HalUARTReadIsr_1: (+1)
   \   0000006C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    329          }
    330          
    331          /*************************************************************************************************
    332           * @fn      HalUARTWriteIsr()
    333           *
    334           * @brief   Write a buffer to the UART
    335           *
    336           * @param   port    - UART port (not used.)
    337           *          pBuffer - pointer to the buffer that will be written
    338           *          length  - length of
    339           *
    340           * @return  length of the buffer that was sent
    341           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    342          uint16 HalUARTWriteIsr(uint8 port, uint8 *pBuffer, uint16 length)
    343          {
   \                     HalUARTWriteIsr: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    344            (void)port;
    345          
    346            if (!uartRecord.configured)
   \   0000000A   0x....             LDR.N    R0,??DataTable11_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??HalUARTWriteIsr_0
    347            {
    348              return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE056             B.N      ??HalUARTWriteIsr_1
    349            }
    350          
    351            uint16 idx = uartRecord.tx.bufferHead;
   \                     ??HalUARTWriteIsr_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable11_2
   \   00000018   0x8A87             LDRH     R7,[R0, #+20]
    352            uint16 cnt = uartRecord.tx.bufferTail;
   \   0000001A   0x....             LDR.N    R0,??DataTable11_2
   \   0000001C   0xF8B0 0x8016      LDRH     R8,[R0, #+22]
    353          
    354            if (cnt == idx)
   \   00000020   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000024   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000026   0x45B8             CMP      R8,R7
   \   00000028   0xD103             BNE.N    ??HalUARTWriteIsr_2
    355            {
    356              cnt = uartRecord.tx.maxBufSize;
   \   0000002A   0x....             LDR.N    R0,??DataTable11_2
   \   0000002C   0x8B00             LDRH     R0,[R0, #+24]
   \   0000002E   0x4680             MOV      R8,R0
   \   00000030   0xE00D             B.N      ??HalUARTWriteIsr_3
    357            }
    358            else if (cnt > idx)
   \                     ??HalUARTWriteIsr_2: (+1)
   \   00000032   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000034   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000038   0x4547             CMP      R7,R8
   \   0000003A   0xD206             BCS.N    ??HalUARTWriteIsr_4
    359            {
    360              cnt = uartRecord.tx.maxBufSize - cnt + idx;
   \   0000003C   0x....             LDR.N    R0,??DataTable11_2
   \   0000003E   0x8B00             LDRH     R0,[R0, #+24]
   \   00000040   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000044   0xEB17 0x0800      ADDS     R8,R7,R0
   \   00000048   0xE001             B.N      ??HalUARTWriteIsr_3
    361            }
    362            else /* (cnt < idx) */
    363            {
    364              cnt = idx - cnt;
   \                     ??HalUARTWriteIsr_4: (+1)
   \   0000004A   0xEBB7 0x0808      SUBS     R8,R7,R8
    365            }
    366          
    367            /* Accept "all-or-none" on write request. */
    368            if (cnt < length)
   \                     ??HalUARTWriteIsr_3: (+1)
   \   0000004E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000052   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000054   0x45B0             CMP      R8,R6
   \   00000056   0xD201             BCS.N    ??HalUARTWriteIsr_5
    369            {
    370              return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE033             B.N      ??HalUARTWriteIsr_1
    371            }
    372          
    373            txMT = false;
   \                     ??HalUARTWriteIsr_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x....             LDR.N    R1,??DataTable11_9
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    374            idx = uartRecord.tx.bufferTail;
   \   00000062   0x....             LDR.N    R0,??DataTable11_2
   \   00000064   0x8AC0             LDRH     R0,[R0, #+22]
   \   00000066   0x0007             MOVS     R7,R0
    375          
    376            for (cnt = 0; cnt < length; cnt++)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x4680             MOV      R8,R0
   \                     ??HalUARTWriteIsr_6: (+1)
   \   0000006C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000070   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000072   0x45B0             CMP      R8,R6
   \   00000074   0xD212             BCS.N    ??HalUARTWriteIsr_7
    377            {
    378              uartRecord.tx.pBuffer[idx++] = pBuffer[cnt];
   \   00000076   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000007A   0xF818 0x0005      LDRB     R0,[R8, R5]
   \   0000007E   0x....             LDR.N    R1,??DataTable11_2
   \   00000080   0x69C9             LDR      R1,[R1, #+28]
   \   00000082   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000084   0x5478             STRB     R0,[R7, R1]
   \   00000086   0x1C7F             ADDS     R7,R7,#+1
    379          
    380              if (idx >= uartRecord.tx.maxBufSize)
   \   00000088   0x....             LDR.N    R0,??DataTable11_2
   \   0000008A   0x8B00             LDRH     R0,[R0, #+24]
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0x4287             CMP      R7,R0
   \   00000090   0xD301             BCC.N    ??HalUARTWriteIsr_8
    381              {
    382                idx = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0007             MOVS     R7,R0
    383              }
    384            }
   \                     ??HalUARTWriteIsr_8: (+1)
   \   00000096   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000009A   0xE7E7             B.N      ??HalUARTWriteIsr_6
    385          
    386            halIntState_t intState;
    387            HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??HalUARTWriteIsr_7: (+1)
   \   0000009C   0x.... 0x....      BL       IntMasterDisable
   \   000000A0   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000A4   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000000A8   0x4681             MOV      R9,R0
    388            uartRecord.tx.bufferTail = idx;
   \   000000AA   0x....             LDR.N    R0,??DataTable11_2
   \   000000AC   0x82C7             STRH     R7,[R0, #+22]
    389            procTx();
   \   000000AE   0x.... 0x....      BL       procTx
    390            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000000B2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000B6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BA   0xD001             BEQ.N    ??HalUARTWriteIsr_9
   \   000000BC   0x.... 0x....      BL       IntMasterEnable
    391          
    392            /* Return the number of bytes actually put into the buffer. */
    393            return length;  
   \                     ??HalUARTWriteIsr_9: (+1)
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??HalUARTWriteIsr_1: (+1)
   \   000000C4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    394          }
    395          
    396          /*************************************************************************************************
    397           * @fn      Hal_UART_RxBufLenIsr()
    398           *
    399           * @brief   Calculate Rx Buffer length of a port
    400           *
    401           * @param   port - UART port (not used.)
    402           *
    403           * @return  length of current Rx Buffer
    404           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    405          uint16 Hal_UART_RxBufLenIsr(uint8 port)
    406          {
   \                     Hal_UART_RxBufLenIsr: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    407            int16 length = uartRecord.rx.bufferTail;
   \   00000002   0x....             LDR.N    R0,??DataTable11_2
   \   00000004   0xF9B0 0x000A      LDRSH    R0,[R0, #+10]
    408            (void)port;
    409          
    410            length -= uartRecord.rx.bufferHead;
   \   00000008   0x....             LDR.N    R2,??DataTable11_2
   \   0000000A   0xF9B2 0x2008      LDRSH    R2,[R2, #+8]
   \   0000000E   0x1A80             SUBS     R0,R0,R2
    411            if  (length < 0)
   \   00000010   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD503             BPL.N    ??Hal_UART_RxBufLenIsr_0
    412              length += uartRecord.rx.maxBufSize;
   \   00000016   0x....             LDR.N    R2,??DataTable11_2
   \   00000018   0xF9B2 0x200C      LDRSH    R2,[R2, #+12]
   \   0000001C   0x1810             ADDS     R0,R2,R0
    413          
    414            return (uint16)length;
   \                     ??Hal_UART_RxBufLenIsr_0: (+1)
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x4770             BX       LR               ;; return
    415          }
    416          
    417          /*************************************************************************************************
    418           * @fn      Hal_UART_TxBufLen()
    419           *
    420           * @brief   Calculate Tx Buffer length of a port
    421           *
    422           * @param   port - UART port (not used.)
    423           *
    424           * @return  length of current Tx buffer
    425           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    426          uint16 Hal_UART_TxBufLen( uint8 port )
    427          {
   \                     Hal_UART_TxBufLen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    428            int16 length = uartRecord.tx.bufferTail;
   \   00000002   0x....             LDR.N    R0,??DataTable11_2
   \   00000004   0xF9B0 0x0016      LDRSH    R0,[R0, #+22]
    429            (void)port;
    430          
    431            length -= uartRecord.tx.bufferHead;
   \   00000008   0x....             LDR.N    R2,??DataTable11_2
   \   0000000A   0xF9B2 0x2014      LDRSH    R2,[R2, #+20]
   \   0000000E   0x1A80             SUBS     R0,R0,R2
    432            if  (length < 0)
   \   00000010   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD503             BPL.N    ??Hal_UART_TxBufLen_0
    433              length += uartRecord.tx.maxBufSize;
   \   00000016   0x....             LDR.N    R2,??DataTable11_2
   \   00000018   0xF9B2 0x2018      LDRSH    R2,[R2, #+24]
   \   0000001C   0x1810             ADDS     R0,R2,R0
    434          
    435            return (uint16)length;
   \                     ??Hal_UART_TxBufLen_0: (+1)
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x4770             BX       LR               ;; return
    436          }
    437          
    438          /*************************************************************************************************
    439           * @fn      recRst()
    440           *
    441           * @brief   Reset the UART record.
    442           *
    443           * @param   none
    444           *
    445           * @return  none
    446           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    447          static void recRst(void)
    448          {
    449            uartRecord.configured        = FALSE;
   \                     recRst: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable11_2
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    450            uartRecord.rx.bufferHead     = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable11_2
   \   0000000A   0x8108             STRH     R0,[R1, #+8]
    451            uartRecord.rx.bufferTail     = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable11_2
   \   00000010   0x8148             STRH     R0,[R1, #+10]
    452            uartRecord.rx.pBuffer        = (uint8 *)NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable11_2
   \   00000016   0x6108             STR      R0,[R1, #+16]
    453            uartRecord.tx.bufferHead     = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable11_2
   \   0000001C   0x8288             STRH     R0,[R1, #+20]
    454            uartRecord.tx.bufferTail     = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable11_2
   \   00000022   0x82C8             STRH     R0,[R1, #+22]
    455            uartRecord.tx.pBuffer        = (uint8 *)NULL;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR.N    R1,??DataTable11_2
   \   00000028   0x61C8             STR      R0,[R1, #+28]
    456            uartRecord.rxChRvdTime       = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable11_2
   \   0000002E   0x6248             STR      R0,[R1, #+36]
    457            uartRecord.intEnable         = FALSE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable11_2
   \   00000034   0xF881 0x0020      STRB     R0,[R1, #+32]
    458          }
   \   00000038   0x4770             BX       LR               ;; return
    459          
    460          /*************************************************************************************************
    461           * @fn      procRx
    462           *
    463           * @brief   Process Tx bytes.
    464           *
    465           * @param   void
    466           *
    467           * @return  void
    468           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    469          static void procRx(void)
    470          {
   \                     procRx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    471            uint16 tail = uartRecord.rx.bufferTail;
   \   00000002   0x....             LDR.N    R0,??DataTable11_2
   \   00000004   0x8944             LDRH     R4,[R0, #+10]
    472          
    473            while (UARTCharsAvail(HAL_UART_PORT))
   \                     ??procRx_0: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4000d000
   \   00000008   0x.... 0x....      BL       UARTCharsAvail
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00F             BEQ.N    ??procRx_1
    474            {
    475              uartRecord.rx.pBuffer[tail++] = UARTCharGetNonBlocking(HAL_UART_PORT);
   \   00000010   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4000d000
   \   00000012   0x.... 0x....      BL       UARTCharGetNonBlocking
   \   00000016   0x....             LDR.N    R1,??DataTable11_2
   \   00000018   0x6909             LDR      R1,[R1, #+16]
   \   0000001A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001C   0x5460             STRB     R0,[R4, R1]
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
    476          
    477              if (tail >= uartRecord.rx.maxBufSize)
   \   00000020   0x....             LDR.N    R0,??DataTable11_2
   \   00000022   0x8980             LDRH     R0,[R0, #+12]
   \   00000024   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD3ED             BCC.N    ??procRx_0
    478              {
    479                tail = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0004             MOVS     R4,R0
   \   0000002E   0xE7EA             B.N      ??procRx_0
    480              }
    481            }
    482          
    483            if (uartRecord.rx.bufferTail != tail)
   \                     ??procRx_1: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable11_2
   \   00000032   0x8940             LDRH     R0,[R0, #+10]
   \   00000034   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xD005             BEQ.N    ??procRx_2
    484            {
    485              uartRecord.rx.bufferTail = tail;
   \   0000003A   0x....             LDR.N    R0,??DataTable11_2
   \   0000003C   0x8144             STRH     R4,[R0, #+10]
    486              uartRecord.rxChRvdTime = osal_GetSystemClock();
   \   0000003E   0x.... 0x....      BL       osal_GetSystemClock
   \   00000042   0x....             LDR.N    R1,??DataTable11_2
   \   00000044   0x6248             STR      R0,[R1, #+36]
    487            }
    488          }
   \                     ??procRx_2: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    489          
    490          /*************************************************************************************************
    491           * @fn      procTx
    492           *
    493           * @brief   Process Tx bytes.
    494           *
    495           * @param   void
    496           *
    497           * @return  void
    498           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    499          static void procTx(void)
    500          {
   \                     procTx: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    501            uint16 head = uartRecord.tx.bufferHead;
   \   00000002   0x....             LDR.N    R0,??DataTable11_2
   \   00000004   0x8A84             LDRH     R4,[R0, #+20]
    502            uint16 tail = uartRecord.tx.bufferTail;
   \   00000006   0x....             LDR.N    R0,??DataTable11_2
   \   00000008   0x8AC5             LDRH     R5,[R0, #+22]
    503          
    504            while ((head != tail) && (UARTCharPutNonBlocking(HAL_UART_PORT, uartRecord.tx.pBuffer[head])))
   \                     ??procTx_0: (+1)
   \   0000000A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x42AC             CMP      R4,R5
   \   00000010   0xD011             BEQ.N    ??procTx_1
   \   00000012   0x....             LDR.N    R0,??DataTable11_2
   \   00000014   0x69C0             LDR      R0,[R0, #+28]
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x5C21             LDRB     R1,[R4, R0]
   \   0000001A   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4000d000
   \   0000001C   0x.... 0x....      BL       UARTCharPutNonBlocking
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD008             BEQ.N    ??procTx_1
    505            {
    506              if (++head >= uartRecord.tx.maxBufSize)
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \   00000026   0x....             LDR.N    R0,??DataTable11_2
   \   00000028   0x8B00             LDRH     R0,[R0, #+24]
   \   0000002A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD3EC             BCC.N    ??procTx_0
    507              {
    508                head = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE7E9             B.N      ??procTx_0
    509              }
    510            }
    511          
    512            uartRecord.tx.bufferHead = head;
   \                     ??procTx_1: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable11_2
   \   00000038   0x8284             STRH     R4,[R0, #+20]
    513          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    514          
    515          /*************************************************************************************************
    516           * @fn      UART Rx/Tx ISR
    517           *
    518           * @brief   Called when a serial byte is ready to read and/or write.
    519           * NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    520           *
    521           * @param   void
    522           *
    523           * @return  void
    524          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    525          void HalUartISR(void)
    526          {
   \                     interrupt_uart1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    527            UARTIntClear(HAL_UART_PORT, (UART_INT_RX |  UART_INT_RT));
   \   00000002   0x2150             MOVS     R1,#+80
   \   00000004   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4000d000
   \   00000006   0x.... 0x....      BL       UARTIntClear
    528            procRx();
   \   0000000A   0x.... 0x....      BL       procRx
    529          
    530            UARTIntClear(HAL_UART_PORT, (UART_INT_TX | UART_INT_CTS));
   \   0000000E   0x2122             MOVS     R1,#+34
   \   00000010   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4000d000
   \   00000012   0x.... 0x....      BL       UARTIntClear
    531            procTx();
   \   00000016   0x.... 0x....      BL       procTx
    532          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x400D9000         DC32     0x400d9000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x400D4108         DC32     0x400d4108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     uartRecord

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x400DC000         DC32     0x400dc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x400D4104         DC32     0x400d4104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x400DA000         DC32     0x400da000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     UBRRTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x4000D000         DC32     0x4000d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x4000D030         DC32     0x4000d030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     txMT
    533          
    534          /**************************************************************************************************
    535          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HalUARTCloseIsr
         8   -> UARTDisable
         8   -> osal_mem_free
         8   -> recRst
       8   HalUARTInitIsr
         8   -> GPIOPinTypeUARTInput
         8   -> GPIOPinTypeUARTOutput
         8   -> IOCPinConfigPeriphInput
         8   -> IOCPinConfigPeriphOutput
         8   -> SysCtrlPeripheralEnable
         8   -> recRst
      16   HalUARTOpenIsr
        16   -> GPIOPinTypeUARTInput
        16   -> GPIOPinTypeUARTOutput
        16   -> HalUARTClose
        16   -> IOCPinConfigPeriphInput
        16   -> IOCPinConfigPeriphOutput
        16   -> IntEnable
        16   -> SysCtrlClockGet
        16   -> UARTConfigSetExpClk
        16   -> UARTEnable
        16   -> UARTFIFOEnable
        16   -> UARTFIFOLevelSet
        16   -> UARTIntClear
        16   -> UARTIntEnable
        16   -> osal_mem_alloc
        16   -> osal_mem_free
      24   HalUARTPollIsr
        24   -- Indirect call
        24   -> Hal_UART_RxBufLen
        24   -> IntMasterDisable
        24   -> IntMasterEnable
        24   -> osal_GetSystemClock
        24   -> procRx
        24   -> procTx
      24   HalUARTReadIsr
        24   -> Hal_UART_RxBufLen
      32   HalUARTWriteIsr
        32   -> IntMasterDisable
        32   -> IntMasterEnable
        32   -> procTx
       0   Hal_UART_RxBufLenIsr
       0   Hal_UART_TxBufLen
       8   interrupt_uart1
         8   -> UARTIntClear
         8   -> procRx
         8   -> procTx
       8   procRx
         8   -> UARTCharGetNonBlocking
         8   -> UARTCharsAvail
         8   -> osal_GetSystemClock
      16   procTx
        16   -> UARTCharPutNonBlocking
       0   recRst


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      40  HalUARTCloseIsr
      62  HalUARTInitIsr
     366  HalUARTOpenIsr
     196  HalUARTPollIsr
     112  HalUARTReadIsr
     200  HalUARTWriteIsr
      34  Hal_UART_RxBufLenIsr
      34  Hal_UART_TxBufLen
      20  UBRRTable
      28  interrupt_uart1
      72  procRx
      60  procTx
      58  recRst
       1  txMT
      44  uartRecord

 
    45 bytes in section .bss
    20 bytes in section .rodata
 1 302 bytes in section .text
 
 1 302 bytes of CODE  memory
    20 bytes of CONST memory
    45 bytes of DATA  memory

Errors: none
Warnings: none
