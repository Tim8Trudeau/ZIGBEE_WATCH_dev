###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        25/Apr/2015  18:56:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\zmac_cb.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\zmac\f8w\zmac_cb.c" -D FEATURE_RESET_MACRO -D ewarm
#        -D NWK_AUTO_POLL -D xPOWER_SAVING -D ZTOOL_P1 -D xMT_TASK -D
#        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D LCD_SUPPORTED=TRUE -D
#        CC2538_USE_ALTERNATE_INTERRUPT_MAP=1 --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\zmac_cb.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\zmac_cb.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\zmac_cb.c
      1          /**************************************************************************************************
      2            Filename:       zmac_cb.c
      3            Revised:        $Date: 2014-06-04 08:52:26 -0700 (Wed, 04 Jun 2014) $
      4            Revision:       $Revision: 38796 $
      5          
      6            Description:    This file contains the NWK functions that the ZMAC calls
      7          
      8          
      9            Copyright 2005-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /********************************************************************************************************
     41           *                                               INCLUDES
     42           ********************************************************************************************************/
     43          
     44          #include "ZComDef.h"
     45          #include "OSAL.h"
     46          #include "ZMAC.h"
     47          #include "MT_MAC.h"
     48          #include "hal_mcu.h"
     49          
     50          #if !defined NONWK
     51          #include "nwk.h"
     52          #include "nwk_bufs.h"
     53          #include "ZGlobals.h"
     54          #endif
     55          
     56          #if defined( MACSIM )
     57            #include "mac_sim.h"
     58          #endif
     59          
     60          #include "mac_security.h"
     61          
     62          #include "mac_main.h"
     63          extern void *ZMac_ScanBuf;
     64          
     65          /********************************************************************************************************
     66           *                                               CONSTANTS
     67           ********************************************************************************************************/
     68          
     69          #if !defined NONWK
     70          /* Lookup table for size of structures. Must match with the order of MAC callback events */

   \                                 In section .rodata, align 4
     71          const uint8 CODE zmacCBSizeTable [] = {
   \                     zmacCBSizeTable:
   \   00000000   0x00 0x16          DC8 0, 22, 16, 0, 0, 24, 21, 16, 2, 0, 2, 36, 20, 64, 0, 0, 16, 0, 0, 0
   \              0x10 0x00    
   \              0x00 0x18    
   \              0x15 0x10    
   \              0x02 0x00    
   \              0x02 0x24    
   \              0x14 0x40    
   \              0x00 0x00    
   \              0x10 0x00    
   \              0x00 0x00    
     72            0,
     73            sizeof(ZMacAssociateInd_t),       // MAC_MLME_ASSOCIATE_IND      1   Associate indication
     74            sizeof(ZMacAssociateCnf_t),       // MAC_MLME_ASSOCIATE_CNF      2   Associate confirm
     75            0,                                // MAC_MLME_DISASSOCIATE_IND   3   Disassociate indication
     76            0,                                // MAC_MLME_DISASSOCIATE_CNF   4   Disassociate confirm
     77            sizeof(macMlmeBeaconNotifyInd_t), // MAC_MLME_BEACON_NOTIFY_IND  5   con notify indication
     78            sizeof(ZMacOrphanInd_t),          // MAC_MLME_ORPHAN_IND         6   Orphan indication
     79            sizeof(ZMacScanCnf_t),            // MAC_MLME_SCAN_CNF           7   Scan confirm
     80            sizeof(ZMacStartCnf_t),           // MAC_MLME_START_CNF          8   Start confirm
     81            0,                                // MAC_MLME_SYNC_LOSS_IND      9   Sync loss indication
     82            sizeof(ZMacPollCnf_t),            // MAC_MLME_POLL_CNF           10  Poll confirm
     83            sizeof(ZMacCommStatusInd_t),      // MAC_MLME_COMM_STATUS_IND    11  Comm status indication
     84            sizeof(ZMacDataCnf_t),            // MAC_MCPS_DATA_CNF           12  Data confirm
     85            sizeof(macMcpsDataInd_t),         // MAC_MCPS_DATA_IND           13  Data indication
     86            0,                                // MAC_MCPS_PURGE_CNF          14  Purge confirm
     87            0,                                // MAC_PWR_ON_CNF              15  Power on confirm
     88            sizeof(ZMacPollInd_t)             // MAC_MLME_POLL_IND           16  Poll indication
     89          };
     90          #endif /* !defined NONWK */
     91          
     92          /********************************************************************************************************
     93           *                                               LOCALS
     94           ********************************************************************************************************/
     95          
     96          /* LQI Adjustment Mode */

   \                                 In section .bss, align 1
     97          static ZMacLqiAdjust_t lqiAdjMode = LQI_ADJ_OFF;
   \                     lqiAdjMode:
   \   00000000                      DS8 1
     98          
     99          #if !defined NONWK
    100          /* LQI Adjustment Function */
    101          static void ZMacLqiAdjust( uint8 corr, uint8* lqi );
    102          #endif
    103          
    104          /*********************************************************************
    105           * ZMAC Function Pointers
    106           */
    107          
    108          /*
    109           * ZMac Application callback function. This function will be called
    110           * for every MAC message that is received over-the-air or generated
    111           * locally by MAC for the application.
    112           *
    113           * The callback function should return TRUE if it has handled the
    114           * MAC message and no further action should be taken with it. It
    115           * should return FALSE if it has not handled the MAC message and
    116           * normal processing should take place.
    117           *
    118           * NOTE: The processing in this function should be kept to the
    119           *       minimum.
    120           */

   \                                 In section .bss, align 4
    121          uint8 (*pZMac_AppCallback)( uint8 *msgPtr ) = (void*)NULL;
   \                     pZMac_AppCallback:
   \   00000000                      DS8 4
    122          
    123          
    124          /*********************************************************************
    125           * ZMAC Functions
    126           */
    127          
    128          /**************************************************************************************************
    129           * @fn       MAC_CbackEvent()
    130           *
    131           * @brief    convert MAC data confirm and indication to ZMac and send to NWK
    132           *
    133           * @param    pData - pointer to macCbackEvent_t
    134           *
    135           * @return   none
    136           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          void MAC_CbackEvent(macCbackEvent_t *pData)
    138          #ifndef MT_MAC_CB_FUNC
    139          {
   \                     MAC_CbackEvent: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    140          #if !defined NONWK
    141            uint8 event = pData->hdr.event;
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x7804             LDRB     R4,[R0, #+0]
    142            uint16 tmp = zmacCBSizeTable[event];
   \   00000008   0x....             LDR.N    R0,??DataTable2
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x5C20             LDRB     R0,[R4, R0]
   \   0000000E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    143            macCbackEvent_t *msgPtr;
    144          
    145            /* If the Network layer will handle a new MAC callback, a non-zero value must be entered in the
    146             * corresponding location in the zmacCBSizeTable[] - thus the table acts as "should handle"?
    147             */
    148            if (tmp == 0)
   \   00000012   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF000 0x811D      BEQ.W    ??MAC_CbackEvent_0
    149            {
    150              return;
    151            }
    152          
    153            // MAC_MCPS_DATA_IND is very special - it is the only event where the MAC does not free *pData.
    154            if ( event == MAC_MCPS_DATA_IND )
   \                     ??MAC_CbackEvent_1: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C0D             CMP      R4,#+13
   \   00000020   0xD119             BNE.N    ??MAC_CbackEvent_2
    155            {
    156          #if defined ( ZMAC_MAX_DATA_IND ) && ( ZMAC_MAX_DATA_IND >= 1 )
    157              // This feature limits the number of unprocessed MAC Data Indications that can be queued
    158              // into the Network Task's OSAL message queue. To enable ZMAC_MAX_DATA_IND filtering, the
    159              // command-line option specifies the threshold setting where MAC_MCPS_DATD_IND callback
    160              // messages will be dropped. For example, adding ZMAC_MAX_DATA_IND=5 to the commnad-line
    161              // options allows up to five messages to be passed up and queued in the NWK layer buffer.
    162              uint8 diCount = osal_msg_count( NWK_TaskID, MAC_MCPS_DATA_IND );
    163          #endif // ZMAC_MAX_DATA_IND
    164              MAC_MlmeGetReq( MAC_SHORT_ADDRESS, &tmp );
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x2053             MOVS     R0,#+83
   \   00000026   0x.... 0x....      BL       MAC_MlmeGetReq
    165              if ( (tmp == INVALID_NODE_ADDR) ||
    166                   (tmp == NWK_BROADCAST_SHORTADDR_DEVALL) ||
    167          #if defined ( ZMAC_MAX_DATA_IND ) && ( ZMAC_MAX_DATA_IND >= 1 )
    168                   (diCount > ZMAC_MAX_DATA_IND) ||
    169          #endif // ZMAC_MAX_DATA_IND
    170                   (pData->dataInd.msdu.len == 0) )
   \   0000002A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000002E   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD009             BEQ.N    ??MAC_CbackEvent_3
   \   00000036   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000003A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD003             BEQ.N    ??MAC_CbackEvent_3
   \   00000042   0x9801             LDR      R0,[SP, #+4]
   \   00000044   0x7A00             LDRB     R0,[R0, #+8]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD103             BNE.N    ??MAC_CbackEvent_4
    171              {
    172                mac_msg_deallocate( (uint8 **)&pData );
   \                     ??MAC_CbackEvent_3: (+1)
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       mac_msg_deallocate
    173                return;
   \   00000050   0xE101             B.N      ??MAC_CbackEvent_0
    174              }
    175              msgPtr = pData;
   \                     ??MAC_CbackEvent_4: (+1)
   \   00000052   0x9D01             LDR      R5,[SP, #+4]
   \   00000054   0xE052             B.N      ??MAC_CbackEvent_5
    176            }
    177            else
    178            {
    179              if (event == MAC_MLME_BEACON_NOTIFY_IND )
   \                     ??MAC_CbackEvent_2: (+1)
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2C05             CMP      R4,#+5
   \   0000005A   0xD108             BNE.N    ??MAC_CbackEvent_6
    180              {
    181                tmp += sizeof(macPanDesc_t) + pData->beaconNotifyInd.sduLength;
   \   0000005C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000060   0x9901             LDR      R1,[SP, #+4]
   \   00000062   0x7C09             LDRB     R1,[R1, #+16]
   \   00000064   0x3124             ADDS     R1,R1,#+36
   \   00000066   0x1808             ADDS     R0,R1,R0
   \   00000068   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000006C   0xE015             B.N      ??MAC_CbackEvent_7
    182              }
    183              else if (event == MAC_MLME_SCAN_CNF)
   \                     ??MAC_CbackEvent_6: (+1)
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x2C07             CMP      R4,#+7
   \   00000072   0xD112             BNE.N    ??MAC_CbackEvent_7
    184              {
    185                if (pData->scanCnf.scanType == ZMAC_ED_SCAN)
   \   00000074   0x9801             LDR      R0,[SP, #+4]
   \   00000076   0x7880             LDRB     R0,[R0, #+2]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD105             BNE.N    ??MAC_CbackEvent_8
    186                {
    187                  tmp += ZMAC_ED_SCAN_MAXCHANNELS;
   \   0000007C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000080   0x301B             ADDS     R0,R0,#+27
   \   00000082   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000086   0xE008             B.N      ??MAC_CbackEvent_7
    188                }
    189                else
    190                {
    191                  tmp += sizeof( ZMacPanDesc_t ) * pData->scanCnf.resultListSize;
   \                     ??MAC_CbackEvent_8: (+1)
   \   00000088   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000008C   0x9901             LDR      R1,[SP, #+4]
   \   0000008E   0x7A09             LDRB     R1,[R1, #+8]
   \   00000090   0x2224             MOVS     R2,#+36
   \   00000092   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000096   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    192                }
    193              }
    194          
    195              if ( !(msgPtr = (macCbackEvent_t *)osal_msg_allocate(tmp)) )
   \                     ??MAC_CbackEvent_7: (+1)
   \   0000009A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009E   0x.... 0x....      BL       osal_msg_allocate
   \   000000A2   0x0005             MOVS     R5,R0
   \   000000A4   0x2D00             CMP      R5,#+0
   \   000000A6   0xD122             BNE.N    ??MAC_CbackEvent_9
    196              {
    197                // Not enough memory. If data confirm - try again
    198                if ((event == MAC_MCPS_DATA_CNF) && (pData->dataCnf.pDataReq != NULL))
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x2C0C             CMP      R4,#+12
   \   000000AC   0xD13C             BNE.N    ??MAC_CbackEvent_10
   \   000000AE   0x9801             LDR      R0,[SP, #+4]
   \   000000B0   0x6840             LDR      R0,[R0, #+4]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD038             BEQ.N    ??MAC_CbackEvent_10
    199                {
    200                  halIntState_t intState;
    201          
    202                  // This is not normally deallocated here because the pZMac_AppCallback()
    203                  // application may need it.
    204                  HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000000B6   0x.... 0x....      BL       IntMasterDisable
   \   000000BA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000BE   0xF090 0x0601      EORS     R6,R0,#0x1
    205          
    206                  mac_msg_deallocate( (uint8**)&(pData->dataCnf.pDataReq) );
   \   000000C2   0x9801             LDR      R0,[SP, #+4]
   \   000000C4   0x1D00             ADDS     R0,R0,#+4
   \   000000C6   0x.... 0x....      BL       mac_msg_deallocate
    207                  if ( !(msgPtr = (macCbackEvent_t *)osal_msg_allocate(tmp)) )
   \   000000CA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000CE   0x.... 0x....      BL       osal_msg_allocate
   \   000000D2   0x0005             MOVS     R5,R0
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD105             BNE.N    ??MAC_CbackEvent_11
    208                  {
    209                    // Still no allocation, something is wrong
    210                    HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000000D8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DA   0x2E00             CMP      R6,#+0
   \   000000DC   0xD001             BEQ.N    ??MAC_CbackEvent_12
   \   000000DE   0x.... 0x....      BL       IntMasterEnable
    211                    return;
   \                     ??MAC_CbackEvent_12: (+1)
   \   000000E2   0xE0B8             B.N      ??MAC_CbackEvent_0
    212                  }
    213                  HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??MAC_CbackEvent_11: (+1)
   \   000000E4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E6   0x2E00             CMP      R6,#+0
   \   000000E8   0xD001             BEQ.N    ??MAC_CbackEvent_13
   \   000000EA   0x.... 0x....      BL       IntMasterEnable
    214                }
    215                else
    216                {
    217                  // This message is dropped
    218                  return;
    219                }
    220              }
    221              osal_memcpy(msgPtr, pData, zmacCBSizeTable[event]);
   \                     ??MAC_CbackEvent_13: (+1)
   \                     ??MAC_CbackEvent_9: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable2
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x5C22             LDRB     R2,[R4, R0]
   \   000000F4   0x9901             LDR      R1,[SP, #+4]
   \   000000F6   0x0028             MOVS     R0,R5
   \   000000F8   0x.... 0x....      BL       osal_memcpy
    222            }
    223          
    224            if ( event == MAC_MLME_BEACON_NOTIFY_IND )
   \                     ??MAC_CbackEvent_5: (+1)
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x2C05             CMP      R4,#+5
   \   00000100   0xD113             BNE.N    ??MAC_CbackEvent_14
    225            {
    226              macMlmeBeaconNotifyInd_t *pBeacon = (macMlmeBeaconNotifyInd_t*)msgPtr;
    227          
    228              osal_memcpy(pBeacon+1, pBeacon->pPanDesc, sizeof(macPanDesc_t));
   \   00000102   0x2224             MOVS     R2,#+36
   \   00000104   0x6869             LDR      R1,[R5, #+4]
   \   00000106   0xF115 0x0018      ADDS     R0,R5,#+24
   \   0000010A   0x.... 0x....      BL       osal_memcpy
    229              pBeacon->pPanDesc = (macPanDesc_t *)(pBeacon+1);
   \   0000010E   0xF115 0x0018      ADDS     R0,R5,#+24
   \   00000112   0x6068             STR      R0,[R5, #+4]
    230              osal_memcpy(pBeacon->pPanDesc+1, pBeacon->pSdu, pBeacon->sduLength);
   \   00000114   0x7C2A             LDRB     R2,[R5, #+16]
   \   00000116   0x6969             LDR      R1,[R5, #+20]
   \   00000118   0x6868             LDR      R0,[R5, #+4]
   \   0000011A   0x3024             ADDS     R0,R0,#+36
   \   0000011C   0x.... 0x....      BL       osal_memcpy
    231              pBeacon->pSdu = (uint8 *)(pBeacon->pPanDesc+1);
   \   00000120   0x6868             LDR      R0,[R5, #+4]
   \   00000122   0x3024             ADDS     R0,R0,#+36
   \   00000124   0x6168             STR      R0,[R5, #+20]
   \   00000126   0xE027             B.N      ??MAC_CbackEvent_15
    232            }
   \                     ??MAC_CbackEvent_10: (+1)
   \   00000128   0xE095             B.N      ??MAC_CbackEvent_0
    233            else if (event == MAC_MLME_SCAN_CNF)
   \                     ??MAC_CbackEvent_14: (+1)
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x2C07             CMP      R4,#+7
   \   0000012E   0xD123             BNE.N    ??MAC_CbackEvent_15
    234            {
    235              macMlmeScanCnf_t *pScan = (macMlmeScanCnf_t*)msgPtr;
   \   00000130   0x0028             MOVS     R0,R5
    236          
    237              if (ZMac_ScanBuf != NULL)
   \   00000132   0x....             LDR.N    R1,??DataTable2_1
   \   00000134   0x6809             LDR      R1,[R1, #+0]
   \   00000136   0x2900             CMP      R1,#+0
   \   00000138   0xD01E             BEQ.N    ??MAC_CbackEvent_15
    238              {
    239                void *pTmp = ZMac_ScanBuf;
   \   0000013A   0x....             LDR.N    R1,??DataTable2_1
   \   0000013C   0x680E             LDR      R6,[R1, #+0]
    240                ZMac_ScanBuf = NULL;
   \   0000013E   0x2100             MOVS     R1,#+0
   \   00000140   0x....             LDR.N    R2,??DataTable2_1
   \   00000142   0x6011             STR      R1,[R2, #+0]
    241          
    242                if (pScan->scanType == ZMAC_ED_SCAN)
   \   00000144   0x7881             LDRB     R1,[R0, #+2]
   \   00000146   0x2900             CMP      R1,#+0
   \   00000148   0xD108             BNE.N    ??MAC_CbackEvent_16
    243                {
    244                  pScan->result.pEnergyDetect = (uint8*) (pScan + 1);
   \   0000014A   0xF110 0x0110      ADDS     R1,R0,#+16
   \   0000014E   0x60C1             STR      R1,[R0, #+12]
    245                  osal_memcpy(pScan->result.pEnergyDetect, pTmp, ZMAC_ED_SCAN_MAXCHANNELS);
   \   00000150   0x221B             MOVS     R2,#+27
   \   00000152   0x0031             MOVS     R1,R6
   \   00000154   0x68C0             LDR      R0,[R0, #+12]
   \   00000156   0x.... 0x....      BL       osal_memcpy
   \   0000015A   0xE00A             B.N      ??MAC_CbackEvent_17
    246                }
    247                else
    248                {
    249                  pScan->result.pPanDescriptor = (macPanDesc_t*) (pScan + 1);
   \                     ??MAC_CbackEvent_16: (+1)
   \   0000015C   0xF110 0x0110      ADDS     R1,R0,#+16
   \   00000160   0x60C1             STR      R1,[R0, #+12]
    250                  osal_memcpy(pScan + 1, pTmp, sizeof( ZMacPanDesc_t ) * pScan->resultListSize);
   \   00000162   0x7A01             LDRB     R1,[R0, #+8]
   \   00000164   0x2224             MOVS     R2,#+36
   \   00000166   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000016A   0x0031             MOVS     R1,R6
   \   0000016C   0x3010             ADDS     R0,R0,#+16
   \   0000016E   0x.... 0x....      BL       osal_memcpy
    251                }
    252          
    253                osal_mem_free(pTmp);
   \                     ??MAC_CbackEvent_17: (+1)
   \   00000172   0x0030             MOVS     R0,R6
   \   00000174   0x.... 0x....      BL       osal_mem_free
    254              }
    255            }
    256          
    257            if ( ( pZMac_AppCallback == NULL ) || ( pZMac_AppCallback( (uint8 *)msgPtr ) == FALSE ) )
   \                     ??MAC_CbackEvent_15: (+1)
   \   00000178   0x....             LDR.N    R0,??DataTable2_2
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD005             BEQ.N    ??MAC_CbackEvent_18
   \   00000180   0x0028             MOVS     R0,R5
   \   00000182   0x....             LDR.N    R1,??DataTable2_2
   \   00000184   0x6809             LDR      R1,[R1, #+0]
   \   00000186   0x4788             BLX      R1
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD159             BNE.N    ??MAC_CbackEvent_19
    258            {
    259              // Filter out non-zigbee packets
    260              if ( event == MAC_MCPS_DATA_IND )
   \                     ??MAC_CbackEvent_18: (+1)
   \   0000018C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000018E   0x2C0D             CMP      R4,#+13
   \   00000190   0xD13D             BNE.N    ??MAC_CbackEvent_20
    261              {
    262                uint8 fcFrameType = (pData->dataInd.msdu.p[0] & 0x03);
   \   00000192   0x9801             LDR      R0,[SP, #+4]
   \   00000194   0x6840             LDR      R0,[R0, #+4]
   \   00000196   0x7800             LDRB     R0,[R0, #+0]
   \   00000198   0xF010 0x0003      ANDS     R0,R0,#0x3
    263                uint8 fcProtoVer = ((pData->dataInd.msdu.p[0] >> 2) & 0x0F);
   \   0000019C   0x9901             LDR      R1,[SP, #+4]
   \   0000019E   0x6849             LDR      R1,[R1, #+4]
   \   000001A0   0x7809             LDRB     R1,[R1, #+0]
   \   000001A2   0xF3C1 0x0183      UBFX     R1,R1,#+2,#+4
    264                uint8 fcReserve = (pData->dataInd.msdu.p[1] & 0xE0);
   \   000001A6   0x9A01             LDR      R2,[SP, #+4]
   \   000001A8   0x6852             LDR      R2,[R2, #+4]
   \   000001AA   0x7852             LDRB     R2,[R2, #+1]
   \   000001AC   0xF012 0x02E0      ANDS     R2,R2,#0xE0
    265                if ( (fcFrameType > 0x01) || (fcProtoVer != _NIB.nwkProtocolVersion) || (fcReserve != 0)
    266                    || (pData->dataInd.mac.srcAddr.addrMode != SADDR_MODE_SHORT) )
   \   000001B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B2   0x2802             CMP      R0,#+2
   \   000001B4   0xDA0C             BGE.N    ??MAC_CbackEvent_21
   \   000001B6   0x....             LDR.N    R0,??DataTable2_3
   \   000001B8   0x7C80             LDRB     R0,[R0, #+18]
   \   000001BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001BC   0x4281             CMP      R1,R0
   \   000001BE   0xD107             BNE.N    ??MAC_CbackEvent_21
   \   000001C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001C2   0x2A00             CMP      R2,#+0
   \   000001C4   0xD104             BNE.N    ??MAC_CbackEvent_21
   \   000001C6   0x9801             LDR      R0,[SP, #+4]
   \   000001C8   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   000001CC   0x2802             CMP      R0,#+2
   \   000001CE   0xD003             BEQ.N    ??MAC_CbackEvent_22
    267                {
    268                  // Drop the message
    269                  mac_msg_deallocate( (uint8 **)&pData );
   \                     ??MAC_CbackEvent_21: (+1)
   \   000001D0   0xA801             ADD      R0,SP,#+4
   \   000001D2   0x.... 0x....      BL       mac_msg_deallocate
    270                  return;
   \   000001D6   0xE03E             B.N      ??MAC_CbackEvent_0
    271                }
    272                else
    273                {
    274                  macDataInd_t *pInd = &msgPtr->dataInd.mac;
   \                     ??MAC_CbackEvent_22: (+1)
   \   000001D8   0xF115 0x001C      ADDS     R0,R5,#+28
    275                  // See if LQI needs adjustment due to frame correlation
    276                  ZMacLqiAdjust( pInd->correlation, &pInd->mpduLinkQuality );
   \   000001DC   0xF110 0x011E      ADDS     R1,R0,#+30
   \   000001E0   0x7FC0             LDRB     R0,[R0, #+31]
   \   000001E2   0x.... 0x....      BL       ZMacLqiAdjust
    277          
    278                  // Look for broadcast message that has a radius of greater 1
    279                  if ( (pData->dataInd.mac.dstAddr.addr.shortAddr == 0xFFFF)
    280                         && (pData->dataInd.msdu.p[6] > 1) )
   \   000001E6   0x9801             LDR      R0,[SP, #+4]
   \   000001E8   0x8CC0             LDRH     R0,[R0, #+38]
   \   000001EA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000001EE   0x4288             CMP      R0,R1
   \   000001F0   0xD121             BNE.N    ??MAC_CbackEvent_23
   \   000001F2   0x9801             LDR      R0,[SP, #+4]
   \   000001F4   0x6840             LDR      R0,[R0, #+4]
   \   000001F6   0x7980             LDRB     R0,[R0, #+6]
   \   000001F8   0x2802             CMP      R0,#+2
   \   000001FA   0xDB1C             BLT.N    ??MAC_CbackEvent_23
    281                  {
    282                    // Send the messsage to a special broadcast queue
    283                    if ( nwk_broadcastSend( (uint8 *)msgPtr ) != SUCCESS )
   \   000001FC   0x0028             MOVS     R0,R5
   \   000001FE   0x.... 0x....      BL       nwk_broadcastSend
   \   00000202   0x2800             CMP      R0,#+0
   \   00000204   0xD002             BEQ.N    ??MAC_CbackEvent_24
    284                    {
    285                      // Drop the message, too many broadcast messages to process
    286                      mac_msg_deallocate( (uint8 **)&pData );
   \   00000206   0xA801             ADD      R0,SP,#+4
   \   00000208   0x.... 0x....      BL       mac_msg_deallocate
    287                    }
    288                    return;
   \                     ??MAC_CbackEvent_24: (+1)
   \   0000020C   0xE023             B.N      ??MAC_CbackEvent_0
    289                  }
    290                }
    291              }
    292              else if ((event == MAC_MCPS_DATA_CNF) && (pData->hdr.status != MAC_NO_RESOURCES))
   \                     ??MAC_CbackEvent_20: (+1)
   \   0000020E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000210   0x2C0C             CMP      R4,#+12
   \   00000212   0xD110             BNE.N    ??MAC_CbackEvent_23
   \   00000214   0x9801             LDR      R0,[SP, #+4]
   \   00000216   0x7840             LDRB     R0,[R0, #+1]
   \   00000218   0x281A             CMP      R0,#+26
   \   0000021A   0xD00C             BEQ.N    ??MAC_CbackEvent_23
    293              {
    294                macMcpsDataCnf_t *pCnf = &msgPtr->dataCnf;
   \   0000021C   0x0028             MOVS     R0,R5
    295                
    296                if ( pCnf->pDataReq && (pCnf->pDataReq->internal.txOptions & MAC_TXOPTION_ACK) )
   \   0000021E   0x6841             LDR      R1,[R0, #+4]
   \   00000220   0x2900             CMP      R1,#+0
   \   00000222   0xD008             BEQ.N    ??MAC_CbackEvent_23
   \   00000224   0x6841             LDR      R1,[R0, #+4]
   \   00000226   0x7D89             LDRB     R1,[R1, #+22]
   \   00000228   0x07C9             LSLS     R1,R1,#+31
   \   0000022A   0xD504             BPL.N    ??MAC_CbackEvent_23
    297                {
    298                  // See if LQI needs adjustment due to frame correlation
    299                  ZMacLqiAdjust( pCnf->correlation, &pCnf->mpduLinkQuality );
   \   0000022C   0xF110 0x010F      ADDS     R1,R0,#+15
   \   00000230   0x7C00             LDRB     R0,[R0, #+16]
   \   00000232   0x.... 0x....      BL       ZMacLqiAdjust
    300                }
    301              }
    302          
    303              // Application hasn't already processed this message. Send it to NWK task.
    304              osal_msg_send( NWK_TaskID, (uint8 *)msgPtr );
   \                     ??MAC_CbackEvent_23: (+1)
   \   00000236   0x0029             MOVS     R1,R5
   \   00000238   0x....             LDR.N    R0,??DataTable2_4
   \   0000023A   0x7800             LDRB     R0,[R0, #+0]
   \   0000023C   0x.... 0x....      BL       osal_msg_send
    305            }
    306          
    307            if ((event == MAC_MCPS_DATA_CNF) && (pData->dataCnf.pDataReq != NULL))
   \                     ??MAC_CbackEvent_19: (+1)
   \   00000240   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000242   0x2C0C             CMP      R4,#+12
   \   00000244   0xD107             BNE.N    ??MAC_CbackEvent_25
   \   00000246   0x9801             LDR      R0,[SP, #+4]
   \   00000248   0x6840             LDR      R0,[R0, #+4]
   \   0000024A   0x2800             CMP      R0,#+0
   \   0000024C   0xD003             BEQ.N    ??MAC_CbackEvent_25
    308            {
    309              // If the application needs 'pDataReq' then we cannot free it here.
    310              // The application must free it after using it. Note that 'pDataReq'
    311              // is of macMcpsDataReq_t (and not ZMacDataReq_t) type.
    312          
    313              mac_msg_deallocate( (uint8**)&(pData->dataCnf.pDataReq) );
   \   0000024E   0x9801             LDR      R0,[SP, #+4]
   \   00000250   0x1D00             ADDS     R0,R0,#+4
   \   00000252   0x.... 0x....      BL       mac_msg_deallocate
    314            }
    315          #endif
    316          }
   \                     ??MAC_CbackEvent_25: (+1)
   \                     ??MAC_CbackEvent_0: (+1)
   \   00000256   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    317          #else  // ifdef MT_MAC_CB_FUNC
    318          {
    319            /* Check if MT has subscribed for this callback If so, pass it as an event to MonitorTest */
    320            switch (pData->hdr.event)
    321            {
    322              case MAC_MLME_ASSOCIATE_IND:
    323                if ( _macCallbackSub & CB_ID_NWK_ASSOCIATE_IND )
    324                  nwk_MTCallbackSubNwkAssociateInd ( (ZMacAssociateInd_t *)pData );
    325                break;
    326          
    327              case MAC_MLME_ASSOCIATE_CNF:
    328                if ( _macCallbackSub & CB_ID_NWK_ASSOCIATE_CNF )
    329                  nwk_MTCallbackSubNwkAssociateCnf ( (ZMacAssociateCnf_t *)pData );
    330                break;
    331          
    332              case MAC_MLME_DISASSOCIATE_IND:
    333                if ( _macCallbackSub & CB_ID_NWK_DISASSOCIATE_IND )
    334                  nwk_MTCallbackSubNwkDisassociateInd ( (ZMacDisassociateInd_t *)pData );
    335                break;
    336          
    337              case MAC_MLME_DISASSOCIATE_CNF:
    338                if ( _macCallbackSub & CB_ID_NWK_DISASSOCIATE_CNF )
    339                  nwk_MTCallbackSubNwkDisassociateCnf ( (ZMacDisassociateCnf_t *)pData );
    340                break;
    341          
    342              case MAC_MLME_BEACON_NOTIFY_IND:
    343                if ( _macCallbackSub & CB_ID_NWK_BEACON_NOTIFY_IND )
    344                  nwk_MTCallbackSubNwkBeaconNotifyInd( (ZMacBeaconNotifyInd_t *)pData );
    345                break;
    346          
    347              case MAC_MLME_ORPHAN_IND:
    348                if ( _macCallbackSub & CB_ID_NWK_ORPHAN_IND )
    349                  nwk_MTCallbackSubNwkOrphanInd( (ZMacOrphanInd_t *) pData );
    350                break;
    351          
    352              case MAC_MLME_SCAN_CNF:
    353                if ( _macCallbackSub & CB_ID_NWK_SCAN_CNF )
    354                {
    355                  pData->scanCnf.result.pEnergyDetect = ZMac_ScanBuf;
    356                  nwk_MTCallbackSubNwkScanCnf ( (ZMacScanCnf_t *) pData );
    357                }
    358          
    359                if (ZMac_ScanBuf != NULL)
    360                {
    361                  void *pTmp = ZMac_ScanBuf;
    362                  ZMac_ScanBuf = NULL;
    363                  osal_mem_free(pTmp);
    364                }
    365                break;
    366          
    367              case MAC_MLME_START_CNF:
    368                if ( _macCallbackSub & CB_ID_NWK_START_CNF )
    369                  nwk_MTCallbackSubNwkStartCnf ( pData->hdr.status );
    370                break;
    371          
    372              case MAC_MLME_SYNC_LOSS_IND:
    373                if ( _macCallbackSub & CB_ID_NWK_SYNC_LOSS_IND )
    374                 nwk_MTCallbackSubNwkSyncLossInd( (ZMacSyncLossInd_t *) pData );
    375                break;
    376          
    377              case MAC_MLME_POLL_CNF:
    378                if ( _macCallbackSub & CB_ID_NWK_POLL_CNF )
    379                   nwk_MTCallbackSubNwkPollCnf( pData->hdr.status );
    380                break;
    381          
    382              case MAC_MLME_COMM_STATUS_IND:
    383                if ( _macCallbackSub & CB_ID_NWK_COMM_STATUS_IND )
    384                  nwk_MTCallbackSubCommStatusInd ( (ZMacCommStatusInd_t *) pData );
    385                break;
    386          
    387              case MAC_MCPS_DATA_CNF:
    388                if (pData->dataCnf.pDataReq != NULL)
    389                  mac_msg_deallocate((uint8**)&pData->dataCnf.pDataReq);
    390          
    391                if ( _macCallbackSub & CB_ID_NWK_DATA_CNF )
    392                  nwk_MTCallbackSubNwkDataCnf( (ZMacDataCnf_t *) pData );
    393                break;
    394          
    395              case MAC_MCPS_DATA_IND:
    396                {
    397                  /*
    398                     Data Ind is unconventional: to save an alloc/copy, reuse the MAC
    399                     buffer and re-organize the contents into ZMAC format.
    400                  */
    401                  ZMacDataInd_t *pDataInd = (ZMacDataInd_t *) pData;
    402                  uint8 event, status, len, *msdu;
    403          
    404                  /* Store parameters */
    405                  event = pData->hdr.event;
    406                  status = pData->hdr.status;
    407                  len = pData->dataInd.msdu.len;
    408                  msdu = pData->dataInd.msdu.p;
    409          
    410                  /* Copy security fields */
    411                  osal_memcpy(&pDataInd->Sec, &pData->dataInd.sec, sizeof(ZMacSec_t));
    412                  
    413                  /* Copy mac fields one by one since the two buffers overlap. */
    414                  osal_memcpy(&pDataInd->SrcAddr, &pData->dataInd.mac.srcAddr, sizeof(zAddrType_t));
    415                  osal_memcpy(&pDataInd->DstAddr, &pData->dataInd.mac.dstAddr, sizeof(zAddrType_t));
    416                  pDataInd->Timestamp = pData->dataInd.mac.timestamp;
    417                  pDataInd->Timestamp2 = pData->dataInd.mac.timestamp2;
    418                  pDataInd->SrcPANId = pData->dataInd.mac.srcPanId;
    419                  pDataInd->DstPANId = pData->dataInd.mac.dstPanId;
    420                  pDataInd->mpduLinkQuality = pData->dataInd.mac.mpduLinkQuality;
    421                  pDataInd->Correlation = pData->dataInd.mac.correlation;
    422                  pDataInd->Rssi = pData->dataInd.mac.rssi;
    423                  pDataInd->Dsn = pData->dataInd.mac.dsn;
    424          
    425                  /* Restore parameters */
    426                  pDataInd->hdr.Status = status;
    427                  pDataInd->hdr.Event = event;
    428                  pDataInd->msduLength = len;
    429          
    430                  if (len)
    431                    pDataInd->msdu = msdu;
    432                  else
    433                    pDataInd->msdu = NULL;
    434          
    435                  if ( _macCallbackSub & CB_ID_NWK_DATA_IND )
    436                    nwk_MTCallbackSubNwkDataInd ( pDataInd );
    437                }
    438          
    439                /* free buffer */
    440                mac_msg_deallocate( (uint8 **)&pData );
    441                break;
    442          
    443              case MAC_MCPS_PURGE_CNF:
    444                if ( _macCallbackSub & CB_ID_NWK_PURGE_CNF )
    445                  nwk_MTCallbackSubNwkPurgeCnf( (ZMacPurgeCnf_t *) pData);
    446                break;
    447          
    448              case MAC_MLME_POLL_IND:
    449                if ( _macCallbackSub & CB_ID_NWK_ASSOCIATE_IND )
    450                   nwk_MTCallbackSubNwkPollInd( (ZMacPollInd_t *)pData );
    451                break;
    452          
    453              default:
    454                break;
    455            }
    456          }
    457          #endif
    458          
    459          /********************************************************************************************************
    460           * @fn      MAC_CbackCheckPending
    461           *
    462           * @brief   Return number of pending indirect msg
    463           *
    464           * @param   None
    465           *
    466           * @return  Number of indirect msg holding
    467           ********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    468          uint8 MAC_CbackCheckPending(void)
    469          {
    470          #if !defined (NONWK)
    471            if ( ZSTACK_ROUTER_BUILD )
    472            {
    473              return (nwkDB_ReturnIndirectHoldingCnt());
    474            }
    475            else
    476            {
    477              return (0);
   \                     MAC_CbackCheckPending: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    478            }
    479          #else
    480            return (0);
    481          #endif
    482          }
    483          
    484          /**************************************************************************************************
    485           * @fn          MAC_CbackQueryRetransmit
    486           *
    487           * @brief       This function callback function returns whether or not to continue MAC
    488           *              retransmission.
    489           *              A return value '0x00' will indicate no continuation of retry and a return value
    490           *              '0x01' will indicate to continue retransmission. This callback function shall be
    491           *              used to stop continuing retransmission for RF4CE.
    492           *              MAC shall call this callback function whenever it finishes transmitting a packet
    493           *              for macMaxFrameRetries times.
    494           *
    495           * input parameters
    496           *
    497           * None.
    498           *
    499           * output parameters
    500           *
    501           * None.
    502           *
    503           * @return      0x00 to stop retransmission, 0x01 to continue retransmission.
    504           **************************************************************************************************
    505          */

   \                                 In section .text, align 2, keep-with-next
    506          uint8 MAC_CbackQueryRetransmit(void)
    507          {
    508            return(0);
   \                     MAC_CbackQueryRetransmit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    509          }
    510          
    511          /********************************************************************************************************
    512           * @fn      ZMacLqiAdjustMode
    513           *
    514           * @brief   Sets/return LQI adjust mode
    515           *
    516           * @param   mode - LQI_ADJ_GET = return current mode only
    517           *                 LQI_ADJ_OFF = disable LQI adjusts
    518           *                 LQI_ADJ_MODEx = set to LQI adjust MODEx
    519           *
    520           * @return  current LQI adjust mode
    521           ********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    522          ZMacLqiAdjust_t ZMacLqiAdjustMode( ZMacLqiAdjust_t mode )
    523          {
    524            if ( mode != LQI_ADJ_GET )
   \                     ZMacLqiAdjustMode: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x28FF             CMP      R0,#+255
   \   00000004   0xD001             BEQ.N    ??ZMacLqiAdjustMode_0
    525            {
    526              lqiAdjMode = mode;
   \   00000006   0x....             LDR.N    R1,??DataTable2_5
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    527            }
    528            return ( lqiAdjMode );
   \                     ??ZMacLqiAdjustMode_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable2_5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x4770             BX       LR               ;; return
    529          }
    530          
    531          #if !defined NONWK
    532          /********************************************************************************************************
    533           * @fn      ZMacLqiAdjust
    534           *
    535           * @brief   Adjust LQI according to correlation value
    536           *
    537           * @notes - the IEEE 802.15.4 specification provides some general statements on
    538           *          the subject of LQI. Section 6.7.8: "The minimum and maximum LQI values
    539           *          (0x00 and 0xFF) should be associated with the lowest and highest IEEE
    540           *          802.15.4 signals detectable by the receiver, and LQ values should be
    541           *          uniformly distributed between these two limits." Section E.2.3: "The
    542           *          LQI (see 6.7.8) measures the received energy and/or SNR for each
    543           *          received packet. When energy level and SNR information are combined,
    544           *          they can indicate whether a corrupt packet resulted from low signal
    545           *          strength or from high signal strength plus interference."
    546           *        - LQI Adjustment Mode1 provided below is a simple algorithm to use the
    547           *          packet correlation value (related to SNR) to scale incoming LQI value
    548           *          (related to signal strength) to 'derate' noisy packets.
    549           *        - LQI Adjustment Mode2 provided below is a location for a developer to
    550           *          implement their own proprietary LQI adjustment algorithm.
    551           *
    552           * @param   corr - packet correlation value
    553           * @param   lqi  - ptr to link quality (scaled rssi)
    554           *
    555           * @return  *lqi - adjusted link quality
    556           ********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    557          static void ZMacLqiAdjust( uint8 corr, uint8 *lqi )
    558          {
    559            if ( lqiAdjMode != LQI_ADJ_OFF )
   \                     ZMacLqiAdjust: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable2_5
   \   00000002   0x7812             LDRB     R2,[R2, #+0]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD01C             BEQ.N    ??ZMacLqiAdjust_0
    560            {
    561              uint16 adjLqi = *lqi;
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
    562          
    563              // Keep correlation within theoretical limits
    564              if ( corr < LQI_CORR_MIN )
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2832             CMP      R0,#+50
   \   0000000E   0xDA01             BGE.N    ??ZMacLqiAdjust_1
    565              {
    566                 corr = LQI_CORR_MIN;
   \   00000010   0x2032             MOVS     R0,#+50
   \   00000012   0xE003             B.N      ??ZMacLqiAdjust_2
    567              }
    568              else if ( corr > LQI_CORR_MAX )
   \                     ??ZMacLqiAdjust_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x286F             CMP      R0,#+111
   \   00000018   0xDB00             BLT.N    ??ZMacLqiAdjust_2
    569              {
    570                 corr = LQI_CORR_MAX;
   \   0000001A   0x206E             MOVS     R0,#+110
    571              }
    572          
    573              if ( lqiAdjMode == LQI_ADJ_MODE1 )
   \                     ??ZMacLqiAdjust_2: (+1)
   \   0000001C   0x....             LDR.N    R3,??DataTable2_5
   \   0000001E   0x781B             LDRB     R3,[R3, #+0]
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD108             BNE.N    ??ZMacLqiAdjust_3
    574              {
    575                /* MODE1 - linear scaling of incoming LQI with a "correlation percentage"
    576                           which is computed from the incoming correlation value between
    577                           theorectical minimum/maximum values. This is a very simple way
    578                           of 'derating' the incoming LQI as correlation value drops. */
    579                adjLqi = (adjLqi * (corr - LQI_CORR_MIN)) / (LQI_CORR_MAX - LQI_CORR_MIN);
   \   00000024   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x3832             SUBS     R0,R0,#+50
   \   0000002A   0xFB00 0xF002      MUL      R0,R0,R2
   \   0000002E   0x223C             MOVS     R2,#+60
   \   00000030   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000034   0xE7FF             B.N      ??ZMacLqiAdjust_4
    580              }
    581              else if ( lqiAdjMode == LQI_ADJ_MODE2 )
    582              {
    583                /* MODE2 - location for developer to implement a proprietary algorithm */
    584              }
    585          
    586              // Replace incoming LQI with scaled value
    587              *lqi = (adjLqi > 255) ? 255 : (uint8)adjLqi;
   \                     ??ZMacLqiAdjust_3: (+1)
   \                     ??ZMacLqiAdjust_4: (+1)
   \   00000036   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000038   0x2AFF             CMP      R2,#+255
   \   0000003A   0xDD01             BLE.N    ??ZMacLqiAdjust_5
   \   0000003C   0x22FF             MOVS     R2,#+255
   \   0000003E   0xE7FF             B.N      ??ZMacLqiAdjust_6
   \                     ??ZMacLqiAdjust_5: (+1)
   \                     ??ZMacLqiAdjust_6: (+1)
   \   00000040   0x700A             STRB     R2,[R1, #+0]
    588            }
    589          }
   \                     ??ZMacLqiAdjust_0: (+1)
   \   00000042   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     zmacCBSizeTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     ZMac_ScanBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     pZMac_AppCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     _NIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     NWK_TaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     lqiAdjMode
    590          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MAC_CbackCheckPending
      24   MAC_CbackEvent
        24   -- Indirect call
        24   -> IntMasterDisable
        24   -> IntMasterEnable
        24   -> MAC_MlmeGetReq
        24   -> ZMacLqiAdjust
        24   -> mac_msg_deallocate
        24   -> nwk_broadcastSend
        24   -> osal_mem_free
        24   -> osal_memcpy
        24   -> osal_msg_allocate
        24   -> osal_msg_send
       0   MAC_CbackQueryRetransmit
       0   ZMacLqiAdjust
       0   ZMacLqiAdjustMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  MAC_CbackCheckPending
     600  MAC_CbackEvent
       4  MAC_CbackQueryRetransmit
      68  ZMacLqiAdjust
      16  ZMacLqiAdjustMode
       1  lqiAdjMode
       4  pZMac_AppCallback
      20  zmacCBSizeTable

 
   5 bytes in section .bss
  20 bytes in section .rodata
 716 bytes in section .text
 
 716 bytes of CODE  memory
  20 bytes of CONST memory
   5 bytes of DATA  memory

Errors: none
Warnings: none
