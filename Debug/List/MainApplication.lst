###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        25/Apr/2015  18:56:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\MainApplication.c
#    Command line =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\MainApplication.c -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\MainApplication.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\MainApplication.o
#
###############################################################################

C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\MainApplication.c
      1            /*****************************************************************************
      2            *     program:  application.c
      3            *      Project: Zigbee Watch
      4            *     Version:  0.0.1 -- phase 1
      5            *   Copyright:  2014, Barron Associates
      6            *     Written:  Sunday, March 15, 2015
      7            *          By:  Tim Trudeau - Timware
      8            *   Processor:  TI CC2538
      9            *        Tool:  IAR Embedded Workbench
     10            *
     11            *-------------------------------------------------------------------
     12            This source file contains the MAIN function.
     13            This is where all the ZSTACK and Watch hardware initilization calls are performed.
     14            This application uses a proprietary profile and runs on a nonbeaconing sleepy end device.
     15            After initilization  osal_start_system() is called to start the OS task handler.
     16            This function call does not return.
     17          
     18               Note -- There are a large number of symbols used to control conditional
     19                       compilization and to set the Zigbee Profile.  Many of these symbols
     20                       (but not all!?) are defined in the configuration files:
     21                    f8wConfig.cfg
     22                    f8wEndev.cfg
     23          
     24                       Additional symbols are defined within the IAR project under
     25           <options/compiler/preprocessor>
     26                    ewarm
     27                    FEATURE_RESET_MACRO
     28                    NWK_AUTO_POLL
     29                    ZTOOL_P1
     30                    xPOWER_SAVING (The leading "x" means this option is deavtivated
     31                    xMT_TASK
     32                    xMT_SYS_FUNC
     33                    xMT_ZDO_FUNC
     34                    LCD_SUPPORTED=YES
     35                    CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
     36            *****************************************************************************/
     37           
     38           
     39           /* ------------------------------------------------------------------------------------------------
     40            *                                          Includes
     41            * ------------------------------------------------------------------------------------------------
     42            */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          
     47          #include "AF.h"
     48          #include "ZDApp.h"
     49          #include "ZDObject.h"
     50          #include "ZDProfile.h"
     51          #include "DebugTrace.h"
     52          
     53          #include "MT.h"
     54          #include "MT_SYS.h"
     55          #include "MT_UART.h"
     56          #include "MT_UTIL.h"
     57          
     58          #include "hal_drivers.h"
     59          #include "hal_lcd.h"
     60          #include "hal_led.h"
     61          #include "hal_key.h"
     62          #include "hal_uart.h"
     63          #include "hal_systick.h"
     64          #include "OSAL_PwrMgr.h"
     65          
     66          #include "hal_board_cfg.h"
     67          #include "mac_radio_defs.h"
     68          
     69          #include "WatchApp.h"
     70          
     71           /* ------------------------------------------------------------------------------------------------
     72            *                                           Constants
     73            * ------------------------------------------------------------------------------------------------
     74            */
     75          // TI IEEE Organizational Unique Identifier
     76          #define IEEE_OUI 0x00124B
     77          
     78          // This list should be filled with Application specific Cluster IDs.

   \                                 In section .rodata, align 2
     79          const cId_t WatchApp_ClusterList[WATCHAPP_MAX_CLUSTERS] =
   \                     WatchApp_ClusterList:
   \   00000000   0x0001             DC16 1
     80          {
     81            WATCHAPP_CLUSTERID
     82          };
     83          
     84          

   \                                 In section .rodata, align 4
     85          const SimpleDescriptionFormat_t       WatchApp_SimpleDesc =
   \                     WatchApp_SimpleDesc:
   \   00000000   0x01 0x00          DC8 1, 0
   \   00000002   0x0F04 0x0001      DC16 3844, 1
   \   00000006   0x00 0x01          DC8 0, 1
   \   00000008   0x........         DC32 WatchApp_ClusterList
   \   0000000C   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 WatchApp_ClusterList
     86          {
     87            WATCHAPP_ENDPOINT,              //  int Endpoint;
     88            WATCHAPP_PROFID,                //  uint16 AppProfId[2];
     89            WATCHAPP_DEVICEID,              //  uint16 AppDeviceId[2];
     90            WATCHAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
     91            WATCHAPP_FLAGS,                 //  int   AppFlags:4;
     92            WATCHAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
     93            (cId_t *)WatchApp_ClusterList,  //  byte *pAppInClusterList;
     94            WATCHAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
     95            (cId_t *)WatchApp_ClusterList   //  byte *pAppInClusterList;
     96          };
     97          
     98           /* ------------------------------------------------------------------------------------------------
     99            *                                           Functions Declarations
    100            * ------------------------------------------------------------------------------------------------
    101            */
    102          static void zmain_dev_info( void );
    103          static void zmain_lcd_init( void );
    104          
    105          extern void InitBoard( uint8 level );
    106          extern void HalUARTInitIsr(void);
    107          extern void InitWatch( void);
    108          static void zmain_ext_addr( void );      
    109          static void WatchApp_SendTheMessage( void );
    110          static void WatchApp_HandleKeys( byte shift, byte keys );
    111          static void WatchApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    112          extern void WatchApp_ProcessUARTMsgs(UARTMsg_t *pckt );
    113          extern void WatchApp_ProcessZDOMsgs( zdoIncomingMsg_t  *pckt );
    114          
    115          
    116          
    117           /* ------------------------------------------------------------------------------------------------
    118            *                                           Global Variables
    119            * ------------------------------------------------------------------------------------------------
    120            */
    121          
    122          // This is the Endpoint/Interface description.  It is defined here, but
    123          // filled-in in WatchApp_Init().  Another way to go would be to fill
    124          // in the structure here and make it a "const" (in code space).  The
    125          // way it's defined in this sample app it is define in RAM.

   \                                 In section .bss, align 4
    126          endPointDesc_t WatchApp_epDesc;
   \                     WatchApp_epDesc:
   \   00000000                      DS8 16
    127          
    128           /* ------------------------------------------------------------------------------------------------
    129             LOCAL VARIABLES
    130            * ------------------------------------------------------------------------------------------------
    131           */

   \                                 In section .bss, align 1
    132          byte WatchApp_TaskID;   // Task ID for internal task/event processing
   \                     WatchApp_TaskID:
   \   00000000                      DS8 1
    133                                    // This variable will be received when
    134                                    // WatchApp_Init() is called.
    135          

   \                                 In section .bss, align 1
    136          devStates_t WatchApp_NwkState;
   \                     WatchApp_NwkState:
   \   00000000                      DS8 1
    137          

   \                                 In section .bss, align 1
    138          byte WatchApp_TransID;  // This is the unique message ID (counter)
   \                     WatchApp_TransID:
   \   00000000                      DS8 1
    139          

   \                                 In section .bss, align 4
    140          afAddrType_t WatchApp_DstAddr;
   \                     WatchApp_DstAddr:
   \   00000000                      DS8 12
    141          
    142          // Number of recieved messages

   \                                 In section .bss, align 2
    143          static uint16 rxMsgCount;
   \                     rxMsgCount:
   \   00000000                      DS8 2
    144          
    145          // Time interval between sending messages

   \                                 In section .data, align 4
    146          static uint32 txMsgDelay = WATCHAPP_SEND_MSG_TIMEOUT;
   \                     txMsgDelay:
   \   00000000   0x00001388         DC32 5000
    147          
    148            /*****************************************************************************
    149             * @fn          main
    150             *
    151             * @brief    This function initializes the ZSTACK layers.
    152               NOTE -- Do not make any changes to this function OR to any functions
    153                       called within. This whole initilization process is incredibly
    154                       fragile. 
    155          
    156             *
    157             * Input Parameters 
    158             *
    159             * @param     None
    160             *
    161             * Output Parameters
    162             *
    163             * @param     None
    164             *
    165             * @return    Exit int
    166             ****************************************************************************/
    167           

   \                                 In section .text, align 2, keep-with-next
    168          int main( void )
    169          {
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    170          uint8 stat;
                       ^
Warning[Pe550]: variable "stat" was set but never used
    171            
    172            // Turn off interrupts
    173            osal_int_disable( INTS_ALL );
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0x.... 0x....      BL       osal_int_disable
    174          
    175            // Initialization for board related stuff such as LEDs
    176            HAL_BOARD_INIT();
   \   00000008   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0xe000ed08
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0x.... 0x....      BL       SysCtrlClockStartSetting
   \                     ??main_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x400d2004
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0300             LSLS     R0,R0,#+12
   \   0000001E   0xD5FA             BPL.N    ??main_0
   \   00000020   0x2008             MOVS     R0,#+8
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable8_2  ;; 0x400d3008
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0x.... 0x....      BL       IntAltMapEnable
   \   0000002C   0x.... 0x....      BL       SysCtrlDeepSleepSetting
   \   00000030   0x.... 0x....      BL       SysCtrlSleepSetting
   \   00000034   0x.... 0x....      BL       SysCtrlRunSetting
   \   00000038   0x.... 0x....      BL       SysCtrlWakeupSetting
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   00000042   0x.... 0x....      BL       GPIOPinTypeGPIOOutput
   \   00000046   0x2102             MOVS     R1,#+2
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   0000004C   0x.... 0x....      BL       GPIOPinTypeGPIOOutput
   \   00000050   0x2104             MOVS     R1,#+4
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   00000056   0x.... 0x....      BL       GPIOPinTypeGPIOOutput
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   00000060   0x.... 0x....      BL       GPIOPinTypeGPIOOutput
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   0000006C   0x.... 0x....      BL       GPIOPinWrite
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   00000078   0x.... 0x....      BL       GPIOPinWrite
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0x2104             MOVS     R1,#+4
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   00000084   0x.... 0x....      BL       GPIOPinWrite
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x2108             MOVS     R1,#+8
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   00000090   0x.... 0x....      BL       GPIOPinWrite
   \   00000094   0x2110             MOVS     R1,#+16
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x400da000
   \   0000009A   0x.... 0x....      BL       GPIOPinTypeGPIOOutput
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x2110             MOVS     R1,#+16
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x400da000
   \   000000A6   0x.... 0x....      BL       GPIOPinWrite
   \   000000AA   0x2120             MOVS     R1,#+32
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x400da000
   \   000000B0   0x.... 0x....      BL       GPIOPinTypeGPIOInput
    177          
    178            // Initialize board I/O
    179            InitBoard( OB_COLD );
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x.... 0x....      BL       InitBoard
    180          
    181            // Initialze HAL drivers
    182            HalDriverInit();
   \   000000BA   0x.... 0x....      BL       HalDriverInit
    183          
    184            // Initialize NV System
    185            osal_nv_init( NULL );
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       osal_nv_init
    186          
    187            // Initialize the MAC --This is correct
    188            MAC_Init();
   \   000000C4   0x.... 0x....      BL       MAC_Init
    189            MAC_InitDevice();
   \   000000C8   0x.... 0x....      BL       MAC_InitDevice
    190            stat = ZMacReset( TRUE );
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x.... 0x....      BL       ZMacReset
    191          
    192            // Determine the extended address
    193            zmain_ext_addr();
   \   000000D2   0x.... 0x....      BL       zmain_ext_addr
    194          
    195          #if defined ZCL_KEY_ESTABLISH
    196            // Initialize the Certicom certificate information.
    197            zmain_cert_init();
    198          #endif
    199          
    200            // Initialize basic NV items
    201            zgInit();
   \   000000D6   0x.... 0x....      BL       zgInit
    202           
    203            // Since the AF isn't a task, call it's initialization routine
    204            afInit();
    205          
    206             // Initialize the operating system
    207            osal_init_system();
   \   000000DA   0x.... 0x....      BL       osal_init_system
    208          
    209            // Allow interrupts
    210            osal_int_enable( INTS_ALL );
   \   000000DE   0x20FF             MOVS     R0,#+255
   \   000000E0   0x.... 0x....      BL       osal_int_enable
    211          
    212             SysTickSetup();
   \   000000E4   0x.... 0x....      BL       SysTickSetup
    213             
    214              // Final board initialization
    215            InitBoard( OB_READY );
   \   000000E8   0x2002             MOVS     R0,#+2
   \   000000EA   0x.... 0x....      BL       InitBoard
    216          
    217            /* Display the device info on the LCD */
    218          #ifdef LCD_SUPPORTED
    219            zmain_dev_info();
   \   000000EE   0x.... 0x....      BL       zmain_dev_info
    220            zmain_lcd_init();
   \   000000F2   0x.... 0x....      BL       zmain_lcd_init
    221          #endif
    222          
    223          HAL_TURN_ON_LED1();
   \   000000F6   0x2201             MOVS     R2,#+1
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x400db000
   \   000000FE   0x.... 0x....      BL       GPIOPinWrite
    224            osal_start_system(); // No Return from here
   \   00000102   0x.... 0x....      BL       osal_start_system
    225          
    226            return 0;  // Shouldn't get here.
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xBD02             POP      {R1,PC}          ;; return
    227          } // END main()
    228          
    229          /*********************************************************************
    230           * @fn      WatchApp_Init
    231           *
    232           * @brief   Initialization function for the App Task.
    233           *          This is called during initialization and should contain
    234           *          any application specific initialization (ie. hardware
    235           *          initialization/setup, table initialization, power up
    236           *          notificaiton ... ).
    237           *
    238           * @param   task_id - the ID assigned by OSAL.  This ID should be
    239           *                    used to send messages and set timers.
    240           *
    241           * @return  none
    242             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          void WatchApp_Init( uint8 task_id )
    244          {
   \                     WatchApp_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    245            uint8 WatchApp_TaskID = task_id;
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
    246            uint8 WatchApp_NwkState = DEV_INIT;
                         ^
Warning[Pe177]: variable "WatchApp_NwkState" was declared but never referenced
   \   00000006   0x2001             MOVS     R0,#+1
    247            uint8 WatchApp_TransID = 0;
                         ^
Warning[Pe177]: variable "WatchApp_TransID" was declared but never referenced
   \   00000008   0x2000             MOVS     R0,#+0
    248          
    249            // Device hardware initialization can be added here or in main() (Zmain.c).
    250            // If the hardware is application specific - add it here.
    251            // If the hardware is other parts of the device add it in main().
    252          
    253            WatchApp_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable8_5
   \   00000010   0x7208             STRB     R0,[R1, #+8]
    254            WatchApp_DstAddr.endPoint = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable8_5
   \   00000018   0x7248             STRB     R0,[R1, #+9]
    255            WatchApp_DstAddr.addr.shortAddr = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable8_5
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    256          
    257            // Fill out the endpoint description.
    258            WatchApp_epDesc.endPoint = WATCHAPP_ENDPOINT;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    259            WatchApp_epDesc.task_id = &WatchApp_TaskID;
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \   00000030   0x6048             STR      R0,[R1, #+4]
    260            WatchApp_epDesc.simpleDesc
    261                      = (SimpleDescriptionFormat_t *)&WatchApp_SimpleDesc;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \   0000003A   0x6088             STR      R0,[R1, #+8]
    262            WatchApp_epDesc.latencyReq = noLatencyReqs;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable8_6
   \   00000042   0x7308             STRB     R0,[R1, #+12]
    263          
    264            // Register the endpoint description with the AF
    265            afRegister( &WatchApp_epDesc );
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   00000048   0x.... 0x....      BL       afRegister
    266          
    267            // Register for all key events - The app will handle all key events
    268            RegisterForKeys( WatchApp_TaskID );
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0x.... 0x....      BL       RegisterForKeys
    269          
    270            // Update the display
    271          #if defined ( LCD_SUPPORTED )
    272            HalLcdWriteString( "WatchApp", HAL_LCD_LINE_4 );
   \   00000054   0x2104             MOVS     R1,#+4
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \   0000005A   0x.... 0x....      BL       HalLcdWriteString
    273          #endif
    274          
    275            ZDO_RegisterForZDOMsg( WatchApp_TaskID, End_Device_Bind_rsp );
   \   0000005E   0xF248 0x0120      MOVW     R1,#+32800
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0x.... 0x....      BL       ZDO_RegisterForZDOMsg
    276            ZDO_RegisterForZDOMsg( WatchApp_TaskID, Match_Desc_rsp );
   \   0000006A   0xF248 0x0106      MOVW     R1,#+32774
   \   0000006E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000072   0x.... 0x....      BL       ZDO_RegisterForZDOMsg
    277          }
   \   00000076   0xBD01             POP      {R0,PC}          ;; return
    278          
    279          /*********************************************************************
    280           * @fn      WatchApp_ProcessEvent
    281           *
    282           * @brief   Application Task event processor.  This function
    283           *          is called to process all events for WatchApp_TaskID.  Events
    284           *          include timers, messages and any other user defined events.
    285           *
    286           * @param   task_id  - The OSAL assigned task ID.
    287           * @param   events - events to process.  This is a bit map and can
    288           *                   contain more than one event.
    289           *
    290           * @return  none
    291             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    292          uint16 WatchApp_ProcessEvent( uint8 task_id, uint16 events )
    293          {
   \                     WatchApp_ProcessEvent: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x000C             MOVS     R4,R1
    294            afIncomingMSGPacket_t *MSGpkt;
    295            afDataConfirm_t *afDataConfirm;
    296          
    297            // Data Confirmation message fields
    298            byte sentEP;
    299            ZStatus_t sentStatus;
    300            byte sentTransID;       // This should match the value sent
    301            (void)task_id;  // Intentionally unreferenced parameter
    302          
    303            if ( events & SYS_EVENT_MSG ) { //Look for System Event first
   \   00000004   0x0420             LSLS     R0,R4,#+16
   \   00000006   0xD54B             BPL.N    ??WatchApp_ProcessEvent_0
    304              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( WatchApp_TaskID );
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       osal_msg_receive
   \   00000012   0x0005             MOVS     R5,R0
   \   00000014   0xE008             B.N      ??WatchApp_ProcessEvent_1
    305              while ( MSGpkt )
    306              {
    307                switch ( MSGpkt->hdr.event ) {
    308                  case WATCHAPP_UART_MESSAGE:
    309                    WatchApp_ProcessUARTMsgs((UARTMsg_t *)MSGpkt );
    310                    break;
    311          
    312                  case ZDO_CB_MSG:
    313                    WatchApp_ProcessZDOMsgs((zdoIncomingMsg_t *)MSGpkt );
    314                    break;
    315          
    316                  case KEY_CHANGE:
    317                    WatchApp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    318                    break;
    319          
    320                  case AF_DATA_CONFIRM_CMD:
    321                    // This message is received as a confirmation of a data packet sent.
    322                    // The status is of ZStatus_t type [defined in ZComDef.h]
    323                    // The message fields are defined in AF.h
    324                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
    325          
    326                    sentEP = afDataConfirm->endpoint;
    327                    (void)sentEP;  // This info not used now
    328                    sentTransID = afDataConfirm->transID;
    329                    (void)sentTransID;  // This info not used now
    330          
    331                    sentStatus = afDataConfirm->hdr.status;
    332                    // Action taken when confirmation is received.
    333                    if ( sentStatus != ZSuccess ) {
    334                      // The data wasn't delivered -- Do something
    335                    }
    336                    break;
    337          
    338                  case AF_INCOMING_MSG_CMD:
    339                    WatchApp_MessageMSGCB( MSGpkt );
    340                    break;
    341          
    342                  case ZDO_STATE_CHANGE:
    343                    WatchApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
    344                    if ( WatchApp_NwkState == DEV_END_DEVICE ) {
    345                      // Start sending "the" message in a regular interval.
    346                       osal_start_reload_timer( WatchApp_TaskID,
    347                                          WATCHAPP_SEND_MSG_EVT,
    348                                          txMsgDelay );
    349                    }
    350                    break;
    351          
    352                  default:
    353                    break;
    354                }
    355          
    356                // Release the memory
    357                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??WatchApp_ProcessEvent_2: (+1)
   \                     ??WatchApp_ProcessEvent_3: (+1)
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       osal_msg_deallocate
    358          
    359                // Next
    360                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( WatchApp_TaskID );
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x.... 0x....      BL       osal_msg_receive
   \   00000026   0x0005             MOVS     R5,R0
   \                     ??WatchApp_ProcessEvent_1: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD035             BEQ.N    ??WatchApp_ProcessEvent_4
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x281A             CMP      R0,#+26
   \   00000030   0xD01B             BEQ.N    ??WatchApp_ProcessEvent_5
   \   00000032   0x2820             CMP      R0,#+32
   \   00000034   0xD008             BEQ.N    ??WatchApp_ProcessEvent_6
   \   00000036   0x28C0             CMP      R0,#+192
   \   00000038   0xD00E             BEQ.N    ??WatchApp_ProcessEvent_7
   \   0000003A   0x28D1             CMP      R0,#+209
   \   0000003C   0xD019             BEQ.N    ??WatchApp_ProcessEvent_8
   \   0000003E   0x28D3             CMP      R0,#+211
   \   00000040   0xD006             BEQ.N    ??WatchApp_ProcessEvent_9
   \   00000042   0x28FD             CMP      R0,#+253
   \   00000044   0xD00D             BEQ.N    ??WatchApp_ProcessEvent_10
   \   00000046   0xE7E6             B.N      ??WatchApp_ProcessEvent_2
   \                     ??WatchApp_ProcessEvent_6: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       WatchApp_ProcessUARTMsgs
   \   0000004E   0xE7E2             B.N      ??WatchApp_ProcessEvent_3
   \                     ??WatchApp_ProcessEvent_9: (+1)
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       WatchApp_ProcessZDOMsgs
   \   00000056   0xE7DE             B.N      ??WatchApp_ProcessEvent_3
   \                     ??WatchApp_ProcessEvent_7: (+1)
   \   00000058   0x78E9             LDRB     R1,[R5, #+3]
   \   0000005A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005C   0x.... 0x....      BL       WatchApp_HandleKeys
   \   00000060   0xE7D9             B.N      ??WatchApp_ProcessEvent_3
   \                     ??WatchApp_ProcessEvent_10: (+1)
   \   00000062   0x78A8             LDRB     R0,[R5, #+2]
   \   00000064   0x78E8             LDRB     R0,[R5, #+3]
   \   00000066   0x7868             LDRB     R0,[R5, #+1]
   \   00000068   0xE7D5             B.N      ??WatchApp_ProcessEvent_3
   \                     ??WatchApp_ProcessEvent_5: (+1)
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0x.... 0x....      BL       WatchApp_MessageMSGCB
   \   00000070   0xE7D1             B.N      ??WatchApp_ProcessEvent_3
   \                     ??WatchApp_ProcessEvent_8: (+1)
   \   00000072   0x7868             LDRB     R0,[R5, #+1]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable8_10
   \   00000078   0x7008             STRB     R0,[R1, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x2806             CMP      R0,#+6
   \   00000082   0xD108             BNE.N    ??WatchApp_ProcessEvent_11
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable8_11
   \   00000088   0x6802             LDR      R2,[R0, #+0]
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       osal_start_reload_timer
   \                     ??WatchApp_ProcessEvent_11: (+1)
   \   00000096   0xE7BE             B.N      ??WatchApp_ProcessEvent_3
    361              }
    362          
    363              // return unprocessed events
    364              return (events ^ SYS_EVENT_MSG);
   \                     ??WatchApp_ProcessEvent_4: (+1)
   \   00000098   0xF494 0x4000      EORS     R0,R4,#0x8000
   \   0000009C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009E   0xE02E             B.N      ??WatchApp_ProcessEvent_12
    365            }
    366          //----------  Non System Messages do not have Message Packets -----------------
    367            if ( events & WATCHAPP_SEND_MSG_EVT ) {
   \                     ??WatchApp_ProcessEvent_0: (+1)
   \   000000A0   0x07E0             LSLS     R0,R4,#+31
   \   000000A2   0xD505             BPL.N    ??WatchApp_ProcessEvent_13
    368            // Send "I'M Awake" message - This event is generated by a timer
    369            //  (setup in WatchApp_Init()).
    370              WatchApp_SendTheMessage();
   \   000000A4   0x.... 0x....      BL       WatchApp_SendTheMessage
    371              return (events ^ WATCHAPP_SEND_MSG_EVT);
   \   000000A8   0xF094 0x0001      EORS     R0,R4,#0x1
   \   000000AC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AE   0xE026             B.N      ??WatchApp_ProcessEvent_12
    372            }
    373          
    374            if ( events & WATCHAPP_FALL_ALARM ) {
   \                     ??WatchApp_ProcessEvent_13: (+1)
   \   000000B0   0x07A0             LSLS     R0,R4,#+30
   \   000000B2   0xD503             BPL.N    ??WatchApp_ProcessEvent_14
    375              return (events ^ WATCHAPP_FALL_ALARM);
   \   000000B4   0xF094 0x0002      EORS     R0,R4,#0x2
   \   000000B8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000BA   0xE020             B.N      ??WatchApp_ProcessEvent_12
    376            }
    377          
    378            if ( events & WATCHAPP_LCD_UPDATE ) {
   \                     ??WatchApp_ProcessEvent_14: (+1)
   \   000000BC   0x0760             LSLS     R0,R4,#+29
   \   000000BE   0xD503             BPL.N    ??WatchApp_ProcessEvent_15
    379              return (events ^ WATCHAPP_LCD_UPDATE);
   \   000000C0   0xF094 0x0004      EORS     R0,R4,#0x4
   \   000000C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C6   0xE01A             B.N      ??WatchApp_ProcessEvent_12
    380            }
    381          
    382            if ( events & WATCHAPP_TIMER1 ) {
   \                     ??WatchApp_ProcessEvent_15: (+1)
   \   000000C8   0x0660             LSLS     R0,R4,#+25
   \   000000CA   0xD50A             BPL.N    ??WatchApp_ProcessEvent_16
    383               osal_start_timerEx(*(WatchApp_epDesc.task_id), WATCHAPP_TIMER1, 1);
   \   000000CC   0x2201             MOVS     R2,#+1
   \   000000CE   0x2140             MOVS     R1,#+64
   \   000000D0   0x....             LDR.N    R0,??DataTable8_6
   \   000000D2   0x6840             LDR      R0,[R0, #+4]
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0x.... 0x....      BL       osal_start_timerEx
    384              return (events ^ WATCHAPP_TIMER1);
   \   000000DA   0xF094 0x0040      EORS     R0,R4,#0x40
   \   000000DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E0   0xE00D             B.N      ??WatchApp_ProcessEvent_12
    385            }
    386          
    387            if ( events & WATCHAPP_TIMER2 ) {
   \                     ??WatchApp_ProcessEvent_16: (+1)
   \   000000E2   0x0620             LSLS     R0,R4,#+24
   \   000000E4   0xD50A             BPL.N    ??WatchApp_ProcessEvent_17
    388                osal_start_timerEx(*(WatchApp_epDesc.task_id), WATCHAPP_TIMER2, 1);
   \   000000E6   0x2201             MOVS     R2,#+1
   \   000000E8   0x2180             MOVS     R1,#+128
   \   000000EA   0x....             LDR.N    R0,??DataTable8_6
   \   000000EC   0x6840             LDR      R0,[R0, #+4]
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x.... 0x....      BL       osal_start_timerEx
    389              return (events ^ WATCHAPP_TIMER2);
   \   000000F4   0xF094 0x0080      EORS     R0,R4,#0x80
   \   000000F8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FA   0xE000             B.N      ??WatchApp_ProcessEvent_12
    390            }
    391            // Discard unknown events
    392            return 0;
   \                     ??WatchApp_ProcessEvent_17: (+1)
   \   000000FC   0x2000             MOVS     R0,#+0
   \                     ??WatchApp_ProcessEvent_12: (+1)
   \   000000FE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    393          }
    394          
    395          /*********************************************************************
    396           * Event Generation Functions
    397           */
    398          
    399          /*********************************************************************
    400           * @fn      WatchApp_ProcessZDOMsgs()
    401           *
    402           * @brief   Process response messages
    403           *
    404           * @param   none
    405           *
    406           * @return  none
    407             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          static void WatchApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
    409          {
   \                     WatchApp_ProcessZDOMsgs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    410            switch ( inMsg->clusterID ) {
   \   00000002   0x89C1             LDRH     R1,[R0, #+14]
   \   00000004   0xF248 0x0206      MOVW     R2,#+32774
   \   00000008   0x1A89             SUBS     R1,R1,R2
   \   0000000A   0xD00F             BEQ.N    ??WatchApp_ProcessZDOMsgs_0
   \   0000000C   0x391A             SUBS     R1,R1,#+26
   \   0000000E   0xD128             BNE.N    ??WatchApp_ProcessZDOMsgs_1
    411              case End_Device_Bind_rsp:
    412                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess ) {
   \                     ??WatchApp_ProcessZDOMsgs_2: (+1)
   \   00000010   0x6980             LDR      R0,[R0, #+24]
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD104             BNE.N    ??WatchApp_ProcessZDOMsgs_3
    413                  // Light LED
    414                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0x.... 0x....      BL       HalLedSet
   \   00000020   0xE003             B.N      ??WatchApp_ProcessZDOMsgs_4
    415                }
    416          #if defined( BLINK_LEDS )
    417                else {
    418                  // Flash LED to show failure
    419                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??WatchApp_ProcessZDOMsgs_3: (+1)
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0x.... 0x....      BL       HalLedSet
    420                }
    421          #endif
    422                break;
   \                     ??WatchApp_ProcessZDOMsgs_4: (+1)
   \   0000002A   0xE01A             B.N      ??WatchApp_ProcessZDOMsgs_1
    423          
    424              case Match_Desc_rsp:
    425                {
    426                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   \                     ??WatchApp_ProcessZDOMsgs_0: (+1)
   \   0000002C   0x.... 0x....      BL       ZDO_ParseEPListRsp
   \   00000030   0x0004             MOVS     R4,R0
    427                  if ( pRsp ) {
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD015             BEQ.N    ??WatchApp_ProcessZDOMsgs_5
    428                    if ( pRsp->status == ZSuccess && pRsp->cnt ) {
   \   00000036   0x7820             LDRB     R0,[R4, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD10F             BNE.N    ??WatchApp_ProcessZDOMsgs_6
   \   0000003C   0x7920             LDRB     R0,[R4, #+4]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00C             BEQ.N    ??WatchApp_ProcessZDOMsgs_6
    429                      WatchApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x....             LDR.N    R1,??DataTable8_5
   \   00000046   0x7208             STRB     R0,[R1, #+8]
    430                      WatchApp_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   \   00000048   0x8860             LDRH     R0,[R4, #+2]
   \   0000004A   0x....             LDR.N    R1,??DataTable8_5
   \   0000004C   0x8008             STRH     R0,[R1, #+0]
    431                      // Take the first endpoint, Can be changed to search through endpoints
    432                      WatchApp_DstAddr.endPoint = pRsp->epList[0];
   \   0000004E   0x7960             LDRB     R0,[R4, #+5]
   \   00000050   0x....             LDR.N    R1,??DataTable8_5
   \   00000052   0x7248             STRB     R0,[R1, #+9]
    433          
    434                      // Light LED
    435                      HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x2008             MOVS     R0,#+8
   \   00000058   0x.... 0x....      BL       HalLedSet
    436                    }
    437                    osal_mem_free( pRsp );
   \                     ??WatchApp_ProcessZDOMsgs_6: (+1)
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       osal_mem_free
    438                  }
    439                }
    440                break;
    441            }
    442          }
   \                     ??WatchApp_ProcessZDOMsgs_5: (+1)
   \                     ??WatchApp_ProcessZDOMsgs_1: (+1)
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    443          
    444          /*********************************************************************
    445           * @fn      WatchApp_HandleKeys
    446           *
    447           * @brief   Handles all key events for this device.
    448           *
    449           * @param   shift - true if in shift/alt. -Shift Not supported-
    450           * @param   keys - bit field for key events. Valid entries:
    451           *                 HAL_KEY_SW_2
    452           *                 HAL_KEY_SW_1
    453           *
    454           * @return  none
    455             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    456          static void WatchApp_HandleKeys( uint8 shift, uint8 keys )
    457          {
   \                     WatchApp_HandleKeys: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x000C             MOVS     R4,R1
    458            zAddrType_t dstAddr;
    459              if ( keys & HAL_KEY_SW_1 ) {
   \   00000006   0x07E0             LSLS     R0,R4,#+31
   \   00000008   0xD51E             BPL.N    ??WatchApp_HandleKeys_0
    460                HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0x.... 0x....      BL       HalLedSet
    461          
    462                // Initiate an End Device Bind Request for the mandatory endpoint
    463                dstAddr.addrMode = Addr16Bit;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xF88D 0x001C      STRB     R0,[SP, #+28]
    464                dstAddr.addr.shortAddr = 0x0000; // Coordinator
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    465                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(),
    466                                      WatchApp_epDesc.endPoint,
    467                                      WATCHAPP_PROFID,
    468                                      WATCHAPP_MAX_CLUSTERS, (cId_t *)WatchApp_ClusterList,
    469                                      WATCHAPP_MAX_CLUSTERS, (cId_t *)WatchApp_ClusterList,
    470                                      FALSE );
   \   0000001E   0x.... 0x....      BL       NLME_GetShortAddr
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9004             STR      R0,[SP, #+16]
   \   00000028   0x....             LDR.N    R0,??DataTable8_12
   \   0000002A   0x9003             STR      R0,[SP, #+12]
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x9002             STR      R0,[SP, #+8]
   \   00000030   0x....             LDR.N    R0,??DataTable8_12
   \   00000032   0x9001             STR      R0,[SP, #+4]
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0xF640 0x7304      MOVW     R3,#+3844
   \   0000003C   0x....             LDR.N    R0,??DataTable8_6
   \   0000003E   0x7802             LDRB     R2,[R0, #+0]
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0xA805             ADD      R0,SP,#+20
   \   00000044   0x.... 0x....      BL       ZDP_EndDeviceBindReq
    471              }
    472          
    473              if ( keys & HAL_KEY_SW_2 ) {
   \                     ??WatchApp_HandleKeys_0: (+1)
   \   00000048   0x07A0             LSLS     R0,R4,#+30
   \   0000004A   0xD51A             BPL.N    ??WatchApp_HandleKeys_1
    474                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x2008             MOVS     R0,#+8
   \   00000050   0x.... 0x....      BL       HalLedSet
    475                // Initiate a Match Description Request (Service Discovery)
    476                dstAddr.addrMode = AddrBroadcast;
   \   00000054   0x200F             MOVS     R0,#+15
   \   00000056   0xF88D 0x001C      STRB     R0,[SP, #+28]
    477                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   \   0000005A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000005E   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    478                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
    479                                      WATCHAPP_PROFID,
    480                                      WATCHAPP_MAX_CLUSTERS, (cId_t *)WatchApp_ClusterList,
    481                                      WATCHAPP_MAX_CLUSTERS, (cId_t *)WatchApp_ClusterList,
    482                                      FALSE );
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9003             STR      R0,[SP, #+12]
   \   00000066   0x....             LDR.N    R0,??DataTable8_12
   \   00000068   0x9002             STR      R0,[SP, #+8]
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x9001             STR      R0,[SP, #+4]
   \   0000006E   0x....             LDR.N    R0,??DataTable8_12
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0x2301             MOVS     R3,#+1
   \   00000074   0xF640 0x7204      MOVW     R2,#+3844
   \   00000078   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000007C   0xA805             ADD      R0,SP,#+20
   \   0000007E   0x.... 0x....      BL       ZDP_MatchDescReq
    483              }
    484          }
   \                     ??WatchApp_HandleKeys_1: (+1)
   \   00000082   0xB008             ADD      SP,SP,#+32
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
    485          
    486          /*********************************************************************
    487           * @fn      WatchApp_MessageMSGCB
    488           *
    489           * @brief   Data message processor callback.  This function processes
    490           *          any incoming data - probably from other devices.  So, based
    491           *          on cluster ID, perform the intended action.
    492           *
    493           * @param   none
    494           *
    495           * @return  none
    496             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    497          static void WatchApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
    498          {
   \                     WatchApp_MessageMSGCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    499            switch ( pkt->clusterId ) {
   \   00000004   0x88A0             LDRH     R0,[R4, #+4]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD113             BNE.N    ??WatchApp_MessageMSGCB_0
    500              case WATCHAPP_CLUSTERID:
    501                rxMsgCount += 1;  // Count this message
   \   0000000A   0x....             LDR.N    R0,??DataTable8_13
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable8_13
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    502                HalLedSet ( HAL_LED_4, HAL_LED_MODE_BLINK );  // Blink an LED
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x2008             MOVS     R0,#+8
   \   00000018   0x.... 0x....      BL       HalLedSet
    503          #if defined( LCD_SUPPORTED )
    504                HalLcdWriteString( (char*)pkt->cmd.Data, HAL_LCD_LINE_1 );
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000020   0x.... 0x....      BL       HalLcdWriteString
    505                HalLcdWriteStringValue( "Rcvd:", rxMsgCount, 10, HAL_LCD_LINE_2 );
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0x220A             MOVS     R2,#+10
   \   00000028   0x....             LDR.N    R0,??DataTable8_13
   \   0000002A   0x8801             LDRH     R1,[R0, #+0]
   \   0000002C   0x....             LDR.N    R0,??DataTable8_14
   \   0000002E   0x.... 0x....      BL       HalLcdWriteStringValue
    506          #elif defined( WIN32 )
    507                // TODO - What is this??
    508                WPRINTSTR( pkt->cmd.Data );
    509          #endif
    510                break;
    511            }
    512          }
   \                     ??WatchApp_MessageMSGCB_0: (+1)
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    513          
    514          /*******************************************************************************
    515           * @fn      WatchApp_SendTheMessage
    516           *
    517           * @brief   Send "the" message.
    518           *
    519           * @param   none
    520           *
    521           * @return  none
    522             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    523          static void WatchApp_SendTheMessage( void )
    524          {
   \                     WatchApp_SendTheMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    525            char theMessageData[] = "Hello World";
   \   00000004   0xA804             ADD      R0,SP,#+16
   \   00000006   0x....             LDR.N    R1,??DataTable8_15
   \   00000008   0xC91C             LDM      R1!,{R2-R4}
   \   0000000A   0xC01C             STM      R0!,{R2-R4}
   \   0000000C   0x390C             SUBS     R1,R1,#+12
   \   0000000E   0x380C             SUBS     R0,R0,#+12
    526          
    527            if ( AF_DataRequest( &WatchApp_DstAddr, &WatchApp_epDesc,
    528                               WATCHAPP_CLUSTERID,
    529                               (byte)osal_strlen( theMessageData ) + 1,
    530                               (byte *)&theMessageData,
    531                               &WatchApp_TransID,
    532                               AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS ) {
   \   00000010   0xA804             ADD      R0,SP,#+16
   \   00000012   0x.... 0x....      BL       osal_strlen
   \   00000016   0x211E             MOVS     R1,#+30
   \   00000018   0x9103             STR      R1,[SP, #+12]
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x9102             STR      R1,[SP, #+8]
   \   0000001E   0x....             LDR.N    R1,??DataTable8_16
   \   00000020   0x9101             STR      R1,[SP, #+4]
   \   00000022   0xA904             ADD      R1,SP,#+16
   \   00000024   0x9100             STR      R1,[SP, #+0]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x1C43             ADDS     R3,R0,#+1
   \   0000002A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable8_6
   \   00000030   0x....             LDR.N    R0,??DataTable8_5
   \   00000032   0x.... 0x....      BL       AF_DataRequest
    533              // Successfully requested to be sent.
    534            } else {
    535              // Error occurred in request to send.
    536            }
    537          }
   \   00000036   0xB008             ADD      SP,SP,#+32
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    538          
    539          /******************************************************************************
    540           * @fn      zmain_ext_addr
    541           *
    542           * @brief   Execute a prioritized search for a valid extended address and write
    543           *          the results into the OSAL NV memory. If a valid extended address is
    544           *          not found this will create a Temporary address so a link can still be
    545           *          established. The Temporary IEEE address is not saved to NV. At some 
    546           *          point MAKE SURE the CC2538 device IEEE address is correctly placed in NV.
    547           *
    548           * @param   none
    549           *
    550           * @return  none
    551             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    552          static void zmain_ext_addr( void )
    553          {
   \                     zmain_ext_addr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    554            uint8 nullAddr[Z_EXTADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x....             LDR.N    R1,??DataTable8_17
   \   00000008   0xC90C             LDM      R1!,{R2,R3}
   \   0000000A   0xC00C             STM      R0!,{R2,R3}
   \   0000000C   0x3908             SUBS     R1,R1,#+8
   \   0000000E   0x3808             SUBS     R0,R0,#+8
    555            uint8 temporaryIEEE_ADDR = FALSE;
   \   00000010   0x2400             MOVS     R4,#+0
    556          
    557            // First check whether a non-erased extended address exists in the OSAL NV.
    558            if ((SUCCESS != osal_nv_item_init(ZCD_NV_EXTADDR, Z_EXTADDR_LEN, NULL))  ||
    559                (SUCCESS != osal_nv_read(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress)) ||
    560                (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN))) {
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       osal_nv_item_init
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10E             BNE.N    ??zmain_ext_addr_0
   \   00000020   0x....             LDR.N    R3,??DataTable8_18
   \   00000022   0x2208             MOVS     R2,#+8
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       osal_nv_read
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD106             BNE.N    ??zmain_ext_addr_0
   \   00000030   0x2208             MOVS     R2,#+8
   \   00000032   0xA901             ADD      R1,SP,#+4
   \   00000034   0x....             LDR.N    R0,??DataTable8_18
   \   00000036   0x.... 0x....      BL       osal_memcmp
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD05B             BEQ.N    ??zmain_ext_addr_1
    561              // Attempt to read the extended address from the location in the last flash
    562              // page where the commissioning tools know to reserve it.
    563              if (!osal_memcmp((uint8 *)HAL_FLASH_IEEE_ADDR, nullAddr, Z_EXTADDR_LEN)) {
   \                     ??zmain_ext_addr_0: (+1)
   \   0000003E   0x2208             MOVS     R2,#+8
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x....             LDR.N    R0,??DataTable8_19  ;; 0x27ffcc
   \   00000044   0x.... 0x....      BL       osal_memcmp
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD105             BNE.N    ??zmain_ext_addr_2
    564                (void)osal_memcpy(aExtendedAddress, (uint8 *)HAL_FLASH_IEEE_ADDR, Z_EXTADDR_LEN);
   \   0000004C   0x2208             MOVS     R2,#+8
   \   0000004E   0x....             LDR.N    R1,??DataTable8_19  ;; 0x27ffcc
   \   00000050   0x....             LDR.N    R0,??DataTable8_18
   \   00000052   0x.... 0x....      BL       osal_memcpy
   \   00000056   0xE045             B.N      ??zmain_ext_addr_3
    565              } else  {
    566                // Disable prefetch when reading from Information Page.
    567                uint32 fctl = HWREG(FLASH_CTRL_FCTL);
   \                     ??zmain_ext_addr_2: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable8_2  ;; 0x400d3008
   \   0000005A   0x6805             LDR      R5,[R0, #+0]
    568                HWREG(FLASH_CTRL_FCTL) = fctl & ~(FLASH_CTRL_FCTL_PREFETCH_ENABLE);
   \   0000005C   0xF035 0x0008      BICS     R0,R5,#0x8
   \   00000060   0x....             LDR.N    R1,??DataTable8_2  ;; 0x400d3008
   \   00000062   0x6008             STR      R0,[R1, #+0]
    569          
    570                // Copy 64-bit extended address from the Information Page
    571                (void)osal_memcpy(aExtendedAddress, (uint8*)HAL_INFO_IEEE_ADDR, Z_EXTADDR_LEN);
   \   00000064   0x2208             MOVS     R2,#+8
   \   00000066   0xF05F 0x1128      MOVS     R1,#+2621480
   \   0000006A   0x....             LDR.N    R0,??DataTable8_18
   \   0000006C   0x.... 0x....      BL       osal_memcpy
    572                if (!osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN)) {
   \   00000070   0x2208             MOVS     R2,#+8
   \   00000072   0xA901             ADD      R1,SP,#+4
   \   00000074   0x....             LDR.N    R0,??DataTable8_18
   \   00000076   0x.... 0x....      BL       osal_memcmp
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD115             BNE.N    ??zmain_ext_addr_4
    573                  uint32 oui = IEEE_OUI;
   \   0000007E   0xF241 0x204B      MOVW     R0,#+4683
   \   00000082   0x9000             STR      R0,[SP, #+0]
    574                  // IEEE OUI is located in the upper 3 bytes of an 8-byte extended address
    575                  // Early Test CC2538EMs had the TI OUI located in the 2nd word,
    576                  // Production CC2538 devices have the TI OUI located in the 1st word
    577                  if (osal_memcmp(&aExtendedAddress[1], &oui, 3)) {
   \   00000084   0x2203             MOVS     R2,#+3
   \   00000086   0xA900             ADD      R1,SP,#+0
   \   00000088   0x....             LDR.N    R0,??DataTable8_20
   \   0000008A   0x.... 0x....      BL       osal_memcmp
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD026             BEQ.N    ??zmain_ext_addr_5
    578                    // OUI found in 1st word, swap words to place OUI in upper bytes
    579                    (void)osal_memcpy(aExtendedAddress, &aExtendedAddress[4], Z_EXTADDR_LEN/2);
   \   00000092   0x2204             MOVS     R2,#+4
   \   00000094   0x....             LDR.N    R1,??DataTable8_21
   \   00000096   0x....             LDR.N    R0,??DataTable8_18
   \   00000098   0x.... 0x....      BL       osal_memcpy
    580                    (void)osal_memcpy(&aExtendedAddress[4], (uint8*)HAL_INFO_IEEE_ADDR, Z_EXTADDR_LEN/2);
   \   0000009C   0x2204             MOVS     R2,#+4
   \   0000009E   0xF05F 0x1128      MOVS     R1,#+2621480
   \   000000A2   0x....             LDR.N    R0,??DataTable8_21
   \   000000A4   0x.... 0x....      BL       osal_memcpy
   \   000000A8   0xE01A             B.N      ??zmain_ext_addr_5
    581                  }
    582                } else { // No valid extended address was found.
    583                  uint8 idx;
    584          
    585          #if !defined ( NV_RESTORE )
    586                  temporaryIEEE_ADDR = TRUE;  // Make a temporary IEEE address, not saved in NV
   \                     ??zmain_ext_addr_4: (+1)
   \   000000AA   0x2401             MOVS     R4,#+1
    587          #endif
    588          
    589                 /* Create a sufficiently random extended address for expediency.
    590                  * Note: this is only valid/legal in a test environment and
    591                  *       must never be used for a commercial product.
    592                  */
    593                  for (idx = 0; idx < (Z_EXTADDR_LEN - 2);) {
   \   000000AC   0x2600             MOVS     R6,#+0
   \   000000AE   0xE00B             B.N      ??zmain_ext_addr_6
    594                    uint16 randy = osal_rand();
   \                     ??zmain_ext_addr_7: (+1)
   \   000000B0   0x.... 0x....      BL       osal_rand
    595                    aExtendedAddress[idx++] = LO_UINT16(randy);
   \   000000B4   0x....             LDR.N    R1,??DataTable8_18
   \   000000B6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B8   0x5470             STRB     R0,[R6, R1]
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
    596                    aExtendedAddress[idx++] = HI_UINT16(randy);
   \   000000BC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000BE   0x0A00             LSRS     R0,R0,#+8
   \   000000C0   0x....             LDR.N    R1,??DataTable8_18
   \   000000C2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C4   0x5470             STRB     R0,[R6, R1]
   \   000000C6   0x1C76             ADDS     R6,R6,#+1
    597                  }
   \                     ??zmain_ext_addr_6: (+1)
   \   000000C8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   0x2E06             CMP      R6,#+6
   \   000000CC   0xDBF0             BLT.N    ??zmain_ext_addr_7
    598                // Next-to-MSB identifies ZigBee device type.
    599                aExtendedAddress[idx++] = 0x30;  //This is an end device
   \   000000CE   0x2030             MOVS     R0,#+48
   \   000000D0   0x....             LDR.N    R1,??DataTable8_18
   \   000000D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D4   0x5470             STRB     R0,[R6, R1]
   \   000000D6   0x1C76             ADDS     R6,R6,#+1
    600                // MSB has historical signficance.
    601                aExtendedAddress[idx] = 0xF8;
   \   000000D8   0x20F8             MOVS     R0,#+248
   \   000000DA   0x....             LDR.N    R1,??DataTable8_18
   \   000000DC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DE   0x5470             STRB     R0,[R6, R1]
    602                }
    603          
    604                // Restore flash control to previous state
    605                HWREG(FLASH_CTRL_FCTL) = fctl;
   \                     ??zmain_ext_addr_5: (+1)
   \   000000E0   0x....             LDR.N    R0,??DataTable8_2  ;; 0x400d3008
   \   000000E2   0x6005             STR      R5,[R0, #+0]
    606              }
    607          
    608              if (temporaryIEEE_ADDR == FALSE) { // only if this is NOT a Temporary
   \                     ??zmain_ext_addr_3: (+1)
   \   000000E4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E6   0x2C00             CMP      R4,#+0
   \   000000E8   0xD105             BNE.N    ??zmain_ext_addr_1
    609                (void)osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress);
   \   000000EA   0x....             LDR.N    R3,??DataTable8_18
   \   000000EC   0x2208             MOVS     R2,#+8
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x.... 0x....      BL       osal_nv_write
    610              }
    611            }
    612          
    613            // Set the MAC PIB extended address according to results from above.
    614            (void)ZMacSetReq(MAC_EXTENDED_ADDRESS, aExtendedAddress);
   \                     ??zmain_ext_addr_1: (+1)
   \   000000F6   0x....             LDR.N    R1,??DataTable8_18
   \   000000F8   0x20E2             MOVS     R0,#+226
   \   000000FA   0x.... 0x....      BL       ZMacSetReq
    615          }
   \   000000FE   0xBD7F             POP      {R0-R6,PC}       ;; return
    616          
    617          #if defined ZCL_KEY_ESTABLISH
    618          /******************************************************************************
    619           * @fn      zmain_cert_init
    620           *
    621           * @brief   Initialize the Certicom certificate information.
    622           *
    623           * @param   none
    624           *
    625           * @return  none
    626             ****************************************************************************/
    627          static void zmain_cert_init( void )
    628          {
    629            uint8 certData[ZCL_KE_IMPLICIT_CERTIFICATE_LEN];
    630            uint8 nullData[ZCL_KE_IMPLICIT_CERTIFICATE_LEN] = {
    631              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    632              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    633              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    634              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    635              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    636              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    637            };
    638          
    639            (void)osal_nv_item_init(ZCD_NV_IMPLICIT_CERTIFICATE, ZCL_KE_IMPLICIT_CERTIFICATE_LEN, NULL);
    640            (void)osal_nv_item_init(ZCD_NV_DEVICE_PRIVATE_KEY, ZCL_KE_DEVICE_PRIVATE_KEY_LEN, NULL);
    641          
    642            // First, check whether non-null certificate data already exists in the OSAL NV.
    643            // To save on code space, just use the CA_PUBLIC_KEY as the bellwether for all three.
    644            if ((SUCCESS != osal_nv_item_init(ZCD_NV_CA_PUBLIC_KEY, ZCL_KE_CA_PUBLIC_KEY_LEN, NULL))   ||
    645                (SUCCESS != osal_nv_read(ZCD_NV_CA_PUBLIC_KEY, 0, ZCL_KE_CA_PUBLIC_KEY_LEN, certData)) ||
    646                (osal_memcmp(certData, nullData, ZCL_KE_CA_PUBLIC_KEY_LEN))) {
    647                  
    648              // If the certificate data is not NULL, use it to update the corresponding NV items.
    649              if (!osal_memcmp((uint8 *)HAL_FLASH_CA_PUBLIC_KEY_ADDR, nullData, ZCL_KE_CA_PUBLIC_KEY_LEN)) {
    650                (void)osal_memcpy(certData, (uint8 *)HAL_FLASH_CA_PUBLIC_KEY_ADDR, ZCL_KE_CA_PUBLIC_KEY_LEN);
    651                (void)osal_nv_write(ZCD_NV_CA_PUBLIC_KEY, 0, ZCL_KE_CA_PUBLIC_KEY_LEN, certData);
    652          
    653                (void)osal_memcpy(certData, (uint8 *)HAL_FLASH_IMPLICIT_CERT_ADDR, ZCL_KE_IMPLICIT_CERTIFICATE_LEN);
    654                (void)osal_nv_write(ZCD_NV_IMPLICIT_CERTIFICATE, 0, ZCL_KE_IMPLICIT_CERTIFICATE_LEN, certData);
    655          
    656                (void)osal_memcpy(certData, (uint8 *)HAL_FLASH_DEV_PRIVATE_KEY_ADDR, ZCL_KE_DEVICE_PRIVATE_KEY_LEN);
    657                (void)osal_nv_write(ZCD_NV_DEVICE_PRIVATE_KEY, 0, ZCL_KE_DEVICE_PRIVATE_KEY_LEN, certData);
    658              }
    659            }
    660          }
    661          #endif
    662          
    663          #ifdef LCD_SUPPORTED
    664          /* LCD_SUPPORTED means the DEV board LCD, NOT the watch LCD.
    665             Undefine LCD_SUPPORTED when running on a watch
    666          */
    667          /******************************************************************************
    668           * @fn      zmain_dev_info
    669           *
    670           * @brief   Displays the IEEE address (MSB to LSB) on the LCD.
    671           *
    672           * @param   none
    673           *
    674           * @return  none
    675             ****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    676          static void zmain_dev_info( void )
    677          {
   \                     zmain_dev_info: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    678            uint8 i;
    679            uint8 *xad;
    680            uint8 lcd_buf[(Z_EXTADDR_LEN*2)+1];
    681          
    682            // Display the extended address.
    683            xad = aExtendedAddress + Z_EXTADDR_LEN - 1;
   \   00000004   0x....             LDR.N    R1,??DataTable8_22
    684          
    685            for (i = 0; i < Z_EXTADDR_LEN*2; xad--) {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE005             B.N      ??zmain_dev_info_0
    686              uint8 ch;
    687              ch = (*xad >> 4) & 0x0F;
    688              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    689              ch = *xad & 0x0F;
    690              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \                     ??zmain_dev_info_1: (+1)
   \   0000000A   0x2237             MOVS     R2,#+55
   \                     ??zmain_dev_info_2: (+1)
   \   0000000C   0x1912             ADDS     R2,R2,R4
   \   0000000E   0xAC00             ADD      R4,SP,#+0
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x551A             STRB     R2,[R3, R4]
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \                     ??zmain_dev_info_0: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xDA18             BGE.N    ??zmain_dev_info_3
   \   0000001C   0x780A             LDRB     R2,[R1, #+0]
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x0914             LSRS     R4,R2,#+4
   \   00000022   0x0002             MOVS     R2,R0
   \   00000024   0x1C50             ADDS     R0,R2,#+1
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C0A             CMP      R4,#+10
   \   0000002A   0xDA01             BGE.N    ??zmain_dev_info_4
   \   0000002C   0x2330             MOVS     R3,#+48
   \   0000002E   0xE000             B.N      ??zmain_dev_info_5
   \                     ??zmain_dev_info_4: (+1)
   \   00000030   0x2337             MOVS     R3,#+55
   \                     ??zmain_dev_info_5: (+1)
   \   00000032   0x191B             ADDS     R3,R3,R4
   \   00000034   0xAC00             ADD      R4,SP,#+0
   \   00000036   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000038   0x5513             STRB     R3,[R2, R4]
   \   0000003A   0x780A             LDRB     R2,[R1, #+0]
   \   0000003C   0xF012 0x040F      ANDS     R4,R2,#0xF
   \   00000040   0x0003             MOVS     R3,R0
   \   00000042   0x1C58             ADDS     R0,R3,#+1
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C0A             CMP      R4,#+10
   \   00000048   0xDADF             BGE.N    ??zmain_dev_info_1
   \   0000004A   0x2230             MOVS     R2,#+48
   \   0000004C   0xE7DE             B.N      ??zmain_dev_info_2
    691            }
    692            lcd_buf[Z_EXTADDR_LEN*2] = '\0';
   \                     ??zmain_dev_info_3: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x0010      STRB     R0,[SP, #+16]
    693            HalLcdWriteString( "IEEE: ", HAL_LCD_LINE_2 );
   \   00000054   0x2102             MOVS     R1,#+2
   \   00000056   0x....             LDR.N    R0,??DataTable8_23
   \   00000058   0x.... 0x....      BL       HalLcdWriteString
    694            HalLcdWriteString( (char*)lcd_buf, HAL_LCD_LINE_3 );
   \   0000005C   0x2103             MOVS     R1,#+3
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x.... 0x....      BL       HalLcdWriteString
    695          }
   \   00000064   0xB006             ADD      SP,SP,#+24
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
    696          #endif
    697          
    698          #ifdef LCD_SUPPORTED
    699          /*********************************************************************
    700           * @fn      zmain_lcd_init
    701           * @brief   Initialize LCD at start up.
    702           * @return  none
    703           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    704          static void zmain_lcd_init( void )
    705          {
    706          #ifdef SERIAL_DEBUG_SUPPORTED
    707            {
    708              HalLcdWriteString( "TexasInstruments", HAL_LCD_LINE_1 );
    709          
    710          #if defined( MT_MAC_FUNC )
    711          #if defined( ZDO_COORDINATOR )
    712                HalLcdWriteString( "MAC-MT Coord", HAL_LCD_LINE_2 );
    713          #else
    714                HalLcdWriteString( "MAC-MT Device", HAL_LCD_LINE_2 );
    715          #endif // ZDO
    716          #elif defined( MT_NWK_FUNC )
    717          #if defined( ZDO_COORDINATOR )
    718                HalLcdWriteString( "NWK Coordinator", HAL_LCD_LINE_2 );
    719          #else
    720                HalLcdWriteString( "NWK Device", HAL_LCD_LINE_2 );
    721          #endif // ZDO
    722          #endif // MT_FUNC
    723            }
    724          #endif // SERIAL_DEBUG_SUPPORTED
    725          }
   \                     zmain_lcd_init: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x400D2004         DC32     0x400d2004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x400D3008         DC32     0x400d3008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x400DB000         DC32     0x400db000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x400DA000         DC32     0x400da000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     WatchApp_DstAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     WatchApp_epDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     WatchApp_SimpleDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     WatchApp_TaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     WatchApp_NwkState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     txMsgDelay

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     WatchApp_ClusterList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     rxMsgCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     WatchApp_TransID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x........         DC32     aExtendedAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x0027FFCC         DC32     0x27ffcc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x........         DC32     aExtendedAddress+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x........         DC32     aExtendedAddress+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x........         DC32     aExtendedAddress+0x7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x57 0x61          DC8 "WatchApp"
   \              0x74 0x63    
   \              0x68 0x41    
   \              0x70 0x70    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x52 0x63          DC8 "Rcvd:"
   \              0x76 0x64    
   \              0x3A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x48 0x65          DC8 "Hello World"
   \              0x6C 0x6C    
   \              0x6F 0x20    
   \              0x57 0x6F    
   \              0x72 0x6C    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x49 0x45          DC8 "IEEE: "
   \              0x45 0x45    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
    726          #endif
    727          
    728          /******************************************************************************
    729           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   WatchApp_HandleKeys
        40   -> HalLedSet
        40   -> NLME_GetShortAddr
        40   -> ZDP_EndDeviceBindReq
        40   -> ZDP_MatchDescReq
       8   WatchApp_Init
         8   -> HalLcdWriteString
         8   -> RegisterForKeys
         8   -> ZDO_RegisterForZDOMsg
         8   -> afRegister
       8   WatchApp_MessageMSGCB
         8   -> HalLcdWriteString
         8   -> HalLcdWriteStringValue
         8   -> HalLedSet
      16   WatchApp_ProcessEvent
        16   -> WatchApp_HandleKeys
        16   -> WatchApp_MessageMSGCB
        16   -> WatchApp_ProcessUARTMsgs
        16   -> WatchApp_ProcessZDOMsgs
        16   -> WatchApp_SendTheMessage
        16   -> osal_msg_deallocate
        16   -> osal_msg_receive
        16   -> osal_start_reload_timer
        16   -> osal_start_timerEx
       8   WatchApp_ProcessZDOMsgs
         8   -> HalLedSet
         8   -> ZDO_ParseEPListRsp
         8   -> osal_mem_free
      40   WatchApp_SendTheMessage
        40   -> AF_DataRequest
        40   -> osal_strlen
       8   main
         8   -> GPIOPinTypeGPIOInput
         8   -> GPIOPinTypeGPIOOutput
         8   -> GPIOPinWrite
         8   -> HalDriverInit
         8   -> InitBoard
         8   -> IntAltMapEnable
         8   -> MAC_Init
         8   -> MAC_InitDevice
         8   -> SysCtrlClockStartSetting
         8   -> SysCtrlDeepSleepSetting
         8   -> SysCtrlRunSetting
         8   -> SysCtrlSleepSetting
         8   -> SysCtrlWakeupSetting
         8   -> SysTickSetup
         8   -> ZMacReset
         8   -> osal_init_system
         8   -> osal_int_disable
         8   -> osal_int_enable
         8   -> osal_nv_init
         8   -> osal_start_system
         8   -> zgInit
         8   -> zmain_dev_info
         8   -> zmain_ext_addr
         8   -> zmain_lcd_init
      32   zmain_dev_info
        32   -> HalLcdWriteString
      32   zmain_ext_addr
        32   -> ZMacSetReq
        32   -> osal_memcmp
        32   -> osal_memcpy
        32   -> osal_nv_item_init
        32   -> osal_nv_read
        32   -> osal_nv_write
        32   -> osal_rand
       0   zmain_lcd_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      12  ?_0
       8  ?_1
      12  ?_2
       8  ?_3
       8  ?_4
       2  WatchApp_ClusterList
      12  WatchApp_DstAddr
     134  WatchApp_HandleKeys
     120  WatchApp_Init
      52  WatchApp_MessageMSGCB
       1  WatchApp_NwkState
     256  WatchApp_ProcessEvent
     100  WatchApp_ProcessZDOMsgs
      58  WatchApp_SendTheMessage
      20  WatchApp_SimpleDesc
       1  WatchApp_TaskID
       1  WatchApp_TransID
      16  WatchApp_epDesc
     266  main
       2  rxMsgCount
       4  txMsgDelay
     104  zmain_dev_info
     256  zmain_ext_addr
       2  zmain_lcd_init

 
    33 bytes in section .bss
     4 bytes in section .data
    70 bytes in section .rodata
 1 444 bytes in section .text
 
 1 444 bytes of CODE  memory
    70 bytes of CONST memory
    37 bytes of DATA  memory

Errors: none
Warnings: 3
