###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        25/Apr/2015  18:56:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\hal_key.c
#    Command line =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\hal_key.c -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\hal_key.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\hal_key.o
#
###############################################################################

C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\hal_key.c
      1          /********************************************************************
      2           *     program:  hal_key.c
      3           *      Project: Zigbee Watch
      4           *     Version:  0.0.1 -- phase 1
      5           *   Copyright:  2014, Barron Associates
      6           *     Written:  Wednesday, March 18, 2015
      7           *      Author:  Tim Trudeau - Timware
      8           *   Processor:  TI CC2538
      9           *        Tool:  IAR Embedded Workbench
     10           *
     11           *-------------------------------------------------------------------
     12           Description:    This file contains the interface to the board button Service.
     13                           NOTE: key is synonymous with button here.
     14           *******************************************************************/
     15          
     16          
     17          /**************************************************************************************************
     18           *                                            INCLUDES
     19           **************************************************************************************************/
     20          #include "hal_types.h"
     21          #include "hal_key.h"
     22          #include "hal_sleep.h"
     23          #include "osal.h"
     24          #include "Hal_Board.h"
     25          #include "hal_drivers.h"
     26          #include "hal_mcu.h"
     27          
     28          /**************************************************************************************************
     29           *                                            CONSTANTS
     30           **************************************************************************************************/
     31          
     32          /**************************************************************************************************
     33           *                                              MACROS
     34           **************************************************************************************************/
     35          #define HAL_KEY_WAKE_INIT()
     36          
     37          /**************************************************************************************************
     38           *                                            TYPEDEFS
     39           **************************************************************************************************/
     40          
     41          /**************************************************************************************************
     42           *                                        GLOBAL VARIABLES
     43           **************************************************************************************************/
     44          #if (HAL_KEY == TRUE)

   \                                 In section .bss, align 1
     45          static uint8 halSavedKeys;
   \                     halSavedKeys:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     46          static uint8 halIntKeys;
   \                     halIntKeys:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     47          static halKeyCBack_t pHal_KeyProcessFunction;
   \                     pHal_KeyProcessFunction:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     48          bool Hal_KeyIntEnable;
   \                     Hal_KeyIntEnable:
   \   00000000                      DS8 1
     49          #endif /* HAL_KEY */
     50          
     51          /**************************************************************************************************
     52           *                                        EXTERNAL VARIABLES
     53           **************************************************************************************************/
     54          
     55          /**************************************************************************************************
     56           *                                        FUNCTIONS - API
     57           **************************************************************************************************/
     58          void interrupt_keybd(void);
     59          uint8 hal_key_no_debounce(void);
     60          
     61          /**************************************************************************************************
     62           * @fn      HalKeyInit
     63           *
     64           * @brief   Initilize Key Service
     65           *
     66           * @param   none
     67           *
     68           * @return  None
     69           **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          void HalKeyInit( void )
     71          {
     72          #if (HAL_KEY == TRUE)
     73            /* Initialize previous key to 0 */
     74            halSavedKeys = 0;
   \                     HalKeyInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0x7008             STRB     R0,[R1, #+0]
     75          
     76            /* Initialize callback function */
     77            pHal_KeyProcessFunction  = NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable4_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     78          #endif /* HAL_KEY */
     79          }
   \   0000000C   0x4770             BX       LR               ;; return
     80          
     81          /**************************************************************************************************
     82          * @fn      hal_key_keys()
     83          *
     84          * @brief   Determine if key was pressed and which key was pressed
     85          *
     86          * @param   none
     87          *
     88          * @return  0 if no key pressed, HAL_KEY_SW bit(s) if pressed
     89          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     90          uint8 hal_key_keys(void)                                           
     91          {                                                                 
   \                     hal_key_keys: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     92            uint8 x = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     93            uint8 ucKeysPressed = bspKeyPushed(BSP_KEY_ALL);
   \   00000004   0x20F8             MOVS     R0,#+248
   \   00000006   0x.... 0x....      BL       bspKeyPushed
     94            
     95            if(ucKeysPressed & BSP_KEY_LEFT)
   \   0000000A   0x06C1             LSLS     R1,R0,#+27
   \   0000000C   0xD501             BPL.N    ??hal_key_keys_0
     96            {
     97              x |= HAL_KEY_SW_4;
   \   0000000E   0xF054 0x0408      ORRS     R4,R4,#0x8
     98            }
     99            if(ucKeysPressed & BSP_KEY_RIGHT)
   \                     ??hal_key_keys_0: (+1)
   \   00000012   0x0681             LSLS     R1,R0,#+26
   \   00000014   0xD501             BPL.N    ??hal_key_keys_1
    100            {
    101              x |= HAL_KEY_SW_2;
   \   00000016   0xF054 0x0402      ORRS     R4,R4,#0x2
    102            }
    103            if(ucKeysPressed & BSP_KEY_UP)
   \                     ??hal_key_keys_1: (+1)
   \   0000001A   0x0641             LSLS     R1,R0,#+25
   \   0000001C   0xD501             BPL.N    ??hal_key_keys_2
    104            {
    105              x |= HAL_KEY_SW_1;
   \   0000001E   0xF054 0x0401      ORRS     R4,R4,#0x1
    106            }
    107            if(ucKeysPressed & BSP_KEY_DOWN)
   \                     ??hal_key_keys_2: (+1)
   \   00000022   0x0601             LSLS     R1,R0,#+24
   \   00000024   0xD501             BPL.N    ??hal_key_keys_3
    108            {
    109              x |= HAL_KEY_SW_3;
   \   00000026   0xF054 0x0410      ORRS     R4,R4,#0x10
    110            }
    111            if(ucKeysPressed & BSP_KEY_SELECT)
   \                     ??hal_key_keys_3: (+1)
   \   0000002A   0x0700             LSLS     R0,R0,#+28
   \   0000002C   0xD501             BPL.N    ??hal_key_keys_4
    112            {
    113              x |= HAL_KEY_SW_5;
   \   0000002E   0xF054 0x0404      ORRS     R4,R4,#0x4
    114            }
    115            return x; 
   \                     ??hal_key_keys_4: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    116          }
    117          
    118          /**************************************************************************************************
    119          * @fn      hal_key_int_keys()
    120          *
    121          * @brief   Determine if key was and which key was pressed during interrupt
    122          *
    123          * @param   None
    124          *
    125          * @return  0 if no key pressed, HAL_KEY_SW bit(s) if pressed
    126          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    127          uint8 hal_key_int_keys(void)                                      
    128          { 
   \                     hal_key_int_keys: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    129            uint8 x = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    130            /* Get bitmask of buttons pushed (clear directional keys' bitmask) */
    131            uint8 ucKeysPressed;
    132            
    133            ucKeysPressed = bspKeyPushed(BSP_KEY_DIR_ALL);
   \   00000004   0x20F0             MOVS     R0,#+240
   \   00000006   0x.... 0x....      BL       bspKeyPushed
    134            if(ucKeysPressed & BSP_KEY_LEFT)
   \   0000000A   0x06C1             LSLS     R1,R0,#+27
   \   0000000C   0xD501             BPL.N    ??hal_key_int_keys_0
    135            {
    136              x |= HAL_KEY_SW_4;
   \   0000000E   0xF054 0x0408      ORRS     R4,R4,#0x8
    137            }
    138            if(ucKeysPressed & BSP_KEY_RIGHT)
   \                     ??hal_key_int_keys_0: (+1)
   \   00000012   0x0681             LSLS     R1,R0,#+26
   \   00000014   0xD501             BPL.N    ??hal_key_int_keys_1
    139            {
    140              x |= HAL_KEY_SW_2;
   \   00000016   0xF054 0x0402      ORRS     R4,R4,#0x2
    141            }
    142            if(ucKeysPressed & BSP_KEY_UP)
   \                     ??hal_key_int_keys_1: (+1)
   \   0000001A   0x0641             LSLS     R1,R0,#+25
   \   0000001C   0xD501             BPL.N    ??hal_key_int_keys_2
    143            {
    144              x |= HAL_KEY_SW_1;
   \   0000001E   0xF054 0x0401      ORRS     R4,R4,#0x1
    145            }
    146            if(ucKeysPressed & BSP_KEY_DOWN)
   \                     ??hal_key_int_keys_2: (+1)
   \   00000022   0x0600             LSLS     R0,R0,#+24
   \   00000024   0xD501             BPL.N    ??hal_key_int_keys_3
    147            {
    148              x |= HAL_KEY_SW_3;
   \   00000026   0xF054 0x0410      ORRS     R4,R4,#0x10
    149            }
    150            
    151            ucKeysPressed = bspKeyPushed(BSP_KEY_SELECT);
   \                     ??hal_key_int_keys_3: (+1)
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0x.... 0x....      BL       bspKeyPushed
    152            if(ucKeysPressed & BSP_KEY_SELECT)
   \   00000030   0x0700             LSLS     R0,R0,#+28
   \   00000032   0xD501             BPL.N    ??hal_key_int_keys_4
    153            {
    154              x |= HAL_KEY_SW_5;
   \   00000034   0xF054 0x0404      ORRS     R4,R4,#0x4
    155            }
    156            return x;
   \                     ??hal_key_int_keys_4: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    157          }
    158          
    159          /**************************************************************************************************
    160          * @fn      HalKeyConfig
    161          *
    162          * @brief   Configure the Key serivce
    163          *
    164          * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    165          *          cback - pointer to the CallBack function
    166          *
    167          * @return  None
    168          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    169          void HalKeyConfig( bool interruptEnable, halKeyCBack_t cback)
    170          {
   \                     HalKeyConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    171          //#if (HAL_KEY == TRUE)
    172            /* Enable/Disable Interrupt or */
    173            Hal_KeyIntEnable = interruptEnable;
   \   00000004   0x....             LDR.N    R1,??DataTable4_2
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    174            
    175            /* Register the callback fucntion */
    176            pHal_KeyProcessFunction = cback;  
   \   00000008   0x....             LDR.N    R0,??DataTable4_1
   \   0000000A   0x6004             STR      R4,[R0, #+0]
    177            
    178            /* Determine if interrupt is enable or not */
    179            if ( Hal_KeyIntEnable )
   \   0000000C   0x....             LDR.N    R0,??DataTable4_2
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01D             BEQ.N    ??HalKeyConfig_0
    180            {
    181              
    182              /* Initialize key handler to use interrupts */
    183              bspKeyInit(BSP_KEY_MODE_ISR);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       bspKeyInit
    184              
    185              /* Map function dirKeyIsr to UP, LEFT, RIGHT and DOWN keys */
    186              bspKeyIntRegister((BSP_KEY_UP|BSP_KEY_LEFT|BSP_KEY_RIGHT|BSP_KEY_DOWN),
    187                                &interrupt_keybd);
   \   0000001A   0x.... 0x....      ADR.W    R1,interrupt_keybd
   \   0000001E   0x20F0             MOVS     R0,#+240
   \   00000020   0x.... 0x....      BL       bspKeyIntRegister
    188              
    189              /* Map function selectKeyIsr to SELECT key */
    190              bspKeyIntRegister(BSP_KEY_SELECT, &interrupt_keybd);
   \   00000024   0x.... 0x....      ADR.W    R1,interrupt_keybd
   \   00000028   0x2008             MOVS     R0,#+8
   \   0000002A   0x.... 0x....      BL       bspKeyIntRegister
    191              
    192              /* Enable interrupts on all keys */
    193              bspKeyIntEnable(BSP_KEY_ALL);
   \   0000002E   0x20F8             MOVS     R0,#+248
   \   00000030   0x.... 0x....      BL       bspKeyIntEnable
    194              
    195              IntPrioritySet(INT_GPIOC, HAL_INT_PRIOR_KEY);              
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x2012             MOVS     R0,#+18
   \   00000038   0x.... 0x....      BL       IntPrioritySet
    196              IntPrioritySet(INT_GPIOA, HAL_INT_PRIOR_KEY);     
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x2010             MOVS     R0,#+16
   \   00000040   0x.... 0x....      BL       IntPrioritySet
    197              
    198              /* Cancel polling if there is one active */
    199              osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);
   \   00000044   0x2110             MOVS     R1,#+16
   \   00000046   0x....             LDR.N    R0,??DataTable4_3
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       osal_stop_timerEx
   \   0000004E   0xE009             B.N      ??HalKeyConfig_1
    200            }
    201            else
    202            {
    203              bspKeyInit(BSP_KEY_MODE_POLL);
   \                     ??HalKeyConfig_0: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      BL       bspKeyInit
    204              
    205              if( cback != NULL)
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD004             BEQ.N    ??HalKeyConfig_1
    206              {
    207                /* Start polling if callback function is setup*/
    208                osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
   \   0000005A   0x2110             MOVS     R1,#+16
   \   0000005C   0x....             LDR.N    R0,??DataTable4_3
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x.... 0x....      BL       osal_set_event
    209              }
    210            }
    211          //#endif /* HAL_KEY */
    212          }
   \                     ??HalKeyConfig_1: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    213          
    214          /**************************************************************************************************
    215           * @fn      HalKeyRead
    216           *
    217           * @brief   Read the current value of a button.
    218                      Different "key" functions are called depending 
    219                      on whether of not button interrupts are enabled.
    220              NOTE----Strangely this function is only called at startup
    221              --------to test if the user is setting a hold condition.
    222           *
    223           * @param   None
    224           *
    225           * @return  0 if no button pressed, HAL_KEY_SW bit(s) if pressed
    226           **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    227          uint8 HalKeyRead( void )
    228          {
   \                     HalKeyRead: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    229            uint8 keys = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    230          
    231          #if (HAL_KEY == TRUE)
    232            if (!Hal_KeyIntEnable)
   \   00000004   0x....             LDR.N    R0,??DataTable4_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??HalKeyRead_0
    233            {
    234              keys = hal_key_keys();
   \   0000000C   0x.... 0x....      BL       hal_key_keys
   \   00000010   0xE001             B.N      ??HalKeyRead_1
    235            }
    236            else
    237            {
    238              keys = hal_key_int_keys();
   \                     ??HalKeyRead_0: (+1)
   \   00000012   0x.... 0x....      BL       hal_key_int_keys
    239            }
    240          #endif /* HAL_KEY */
    241          
    242            return keys;
   \                     ??HalKeyRead_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    243          }
    244          
    245          /**************************************************************************************************
    246           * @fn      HalKeyPoll
    247           *
    248           * @brief   Send call back if key(s) is pressed.
    249                      The watch is currently not using interrupts to monitor button activity.
    250                      Polling of the bottons is done here. Until buttons are monitored via an interrupt
    251                      the watch can not put the cpu to sleep.
    252           *
    253           * @param   None
    254           *
    255           * @return  None
    256           **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    257          void HalKeyPoll( void )
    258          {
   \                     HalKeyPoll: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    259          #if (HAL_KEY == TRUE)
    260            uint8 keys = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    261            
    262            /* if polling is using */
    263            if (!Hal_KeyIntEnable)
   \   00000004   0x....             LDR.N    R1,??DataTable4_2
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD108             BNE.N    ??HalKeyPoll_0
    264            {
    265              /* Get keys */
    266              keys = hal_key_keys ();
   \   0000000C   0x.... 0x....      BL       hal_key_keys
    267          
    268              /* If same as before, no keys */
    269              if ( keys == halSavedKeys )
   \   00000010   0x....             LDR.N    R1,??DataTable4
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD00D             BEQ.N    ??HalKeyPoll_1
    270              {
    271                return;
    272              }
    273          
    274              /* Store the current keys for comparation next time */
    275              halSavedKeys = keys;
   \                     ??HalKeyPoll_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable4
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    276          
    277            }
    278            
    279            /* Callback */
    280            if (keys && (pHal_KeyProcessFunction))
   \                     ??HalKeyPoll_0: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD008             BEQ.N    ??HalKeyPoll_3
   \   00000024   0x....             LDR.N    R1,??DataTable4_1
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD004             BEQ.N    ??HalKeyPoll_3
    281            {
    282              (pHal_KeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x....             LDR.N    R2,??DataTable4_1
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x4790             BLX      R2
    283            }
    284            
    285          #endif /* HAL_KEY */
    286          }
   \                     ??HalKeyPoll_3: (+1)
   \                     ??HalKeyPoll_1: (+1)
   \   00000036   0xBD01             POP      {R0,PC}          ;; return
    287          
    288          #ifdef POWER_SAVING
    289          /**************************************************************************************************
    290           * @fn      HalKeyEnterSleep
    291           *
    292           * @brief   Get called to enter sleep mode
    293           *
    294           * @param   None
    295           *
    296           * @return  None
    297           **************************************************************************************************/
    298          void HalKeyEnterSleep ( void )
    299          {
    300            /* nothing to do */
    301          }
    302          
    303          /**************************************************************************************************
    304          * @fn      hal_key_no_debounce()
    305          *
    306          * @brief   Determine if key is pressed and which key is pressed
    307          *
    308          * @param   None
    309          *
    310          * @return  0 if no key pressed, HAL_KEY_SW bit(s) if pressed
    311          **************************************************************************************************/
    312          
    313          uint8 hal_key_no_debounce(void)
    314          {
    315            uint8 x = 0;
    316            uint8 dirPins, selPin;
    317            
    318            dirPins = (~GPIOPinRead(BSP_KEY_DIR_BASE,
    319                                    BSP_KEY_DIR_ALL)) \
    320                                    & BSP_KEY_DIR_ALL;
    321            selPin  = (~GPIOPinRead(BSP_KEY_SEL_BASE,
    322                                    BSP_KEY_SELECT)) \
    323                                    & BSP_KEY_SELECT;
    324            if(dirPins & BSP_KEY_LEFT)
    325            {
    326              x |= HAL_KEY_SW_4;
    327            }
    328            if(dirPins & BSP_KEY_RIGHT)
    329            {
    330              x |= HAL_KEY_SW_2;
    331            }
    332            if(dirPins & BSP_KEY_UP)
    333            {
    334              x |= HAL_KEY_SW_1;
    335            }
    336            if(dirPins & BSP_KEY_DOWN)
    337            {
    338              x |= HAL_KEY_SW_3;
    339            }
    340            if(selPin & BSP_KEY_SELECT)
    341            {
    342              x |= HAL_KEY_SW_5;
    343            }
    344            return x;
    345          }
    346          
    347          /**************************************************************************************************
    348           * @fn      HalKeyExitSleep
    349           *
    350           * @brief   Get called when sleep is over
    351           *
    352           * @param   None
    353           *
    354           * @return  0 if no key pressed, HAL_KEY_SW bit(s) if pressed
    355           **************************************************************************************************/
    356          uint8 HalKeyExitSleep ( void )
    357          {
    358            uint8 keys = 0;
    359          
    360            /* Get keys */
    361            if (!Hal_KeyIntEnable)
    362            {
    363              keys = hal_key_no_debounce();
    364            }
    365            else
    366            {
    367              keys = hal_key_int_keys();
    368            }
    369            return ( keys );
    370          }
    371          #endif /* POWER_SAVING */
    372          
    373          /**************************************************************************************************
    374           * @fn      INTERRUPT_KEYBD
    375           *
    376           * @brief   Interrupt Service Routine for buttons.
    377                      pHal_KeyProcessFunction is a pointer to the interrupt callback function.
    378                      Make sure this pointer is initialized if using interrupts.
    379           *
    380           * @param   None
    381           *
    382           * @return  None
    383           **************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    384          void interrupt_keybd(void)
    385          {
   \                     interrupt_keybd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    386            /* Clear the Power interrupt registers */
    387            SysCtrlPowIntClear();
   \   00000002   0x.... 0x....      BL       SysCtrlPowIntClear
    388            
    389          #if (HAL_KEY == TRUE)
    390            /* Read the key before it gone */
    391            halIntKeys = hal_key_int_keys();
   \   00000006   0x.... 0x....      BL       hal_key_int_keys
   \   0000000A   0x....             LDR.N    R1,??DataTable4_4
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    392            
    393            if (halIntKeys && (pHal_KeyProcessFunction))
   \   0000000E   0x....             LDR.N    R0,??DataTable4_4
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD009             BEQ.N    ??interrupt_keybd_0
   \   00000016   0x....             LDR.N    R0,??DataTable4_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??interrupt_keybd_0
    394            {
    395              (pHal_KeyProcessFunction) (halIntKeys, HAL_KEY_STATE_NORMAL);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x....             LDR.N    R0,??DataTable4_4
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x....             LDR.N    R2,??DataTable4_1
   \   00000026   0x6812             LDR      R2,[R2, #+0]
   \   00000028   0x4790             BLX      R2
    396            }
    397          #endif /* HAL_KEY */
    398            
    399            CLEAR_SLEEP_MODE();
    400          }
   \                     ??interrupt_keybd_0: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     halSavedKeys

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     pHal_KeyProcessFunction

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     Hal_KeyIntEnable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     Hal_TaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     halIntKeys
    401          
    402          /**************************************************************************************************
    403          **************************************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HalKeyConfig
         8   -> IntPrioritySet
         8   -> bspKeyInit
         8   -> bspKeyIntEnable
         8   -> bspKeyIntRegister
         8   -> osal_set_event
         8   -> osal_stop_timerEx
       0   HalKeyInit
       8   HalKeyPoll
         8   -- Indirect call
         8   -> hal_key_keys
       8   HalKeyRead
         8   -> hal_key_int_keys
         8   -> hal_key_keys
       8   hal_key_int_keys
         8   -> bspKeyPushed
       8   hal_key_keys
         8   -> bspKeyPushed
       8   interrupt_keybd
         8   -- Indirect call
         8   -> SysCtrlPowIntClear
         8   -> hal_key_int_keys


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
     102  HalKeyConfig
      14  HalKeyInit
      56  HalKeyPoll
      26  HalKeyRead
       1  Hal_KeyIntEnable
       1  halIntKeys
       1  halSavedKeys
      62  hal_key_int_keys
      56  hal_key_keys
      44  interrupt_keybd
       4  pHal_KeyProcessFunction

 
   7 bytes in section .bss
 380 bytes in section .text
 
 380 bytes of CODE memory
   7 bytes of DATA memory

Errors: none
Warnings: none
