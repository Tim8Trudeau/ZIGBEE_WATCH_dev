###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        25/Apr/2015  18:56:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\New folder\hal_sleep.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\New folder\hal_sleep.c" -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\hal_sleep.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\hal_sleep.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\New folder\hal_sleep.c
      1          /**************************************************************************************************
      2            Filename:       _hal_sleep.c
      3            Revised:        $Date: 2014-07-29 21:18:07 -0700 (Tue, 29 Jul 2014) $
      4            Revision:       $Revision: 39577 $
      5          
      6            Description:    This module contains the HAL power management procedures for the CC2538.
      7          
      8          
      9            Copyright 2011-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_mcu.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool halIntsAreEnabled(void)
   \                     halIntsAreEnabled: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       IntMasterDisable
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0xF090 0x0401      EORS     R4,R0,#0x1
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD001             BEQ.N    ??halIntsAreEnabled_0
   \   00000014   0x.... 0x....      BL       IntMasterEnable
   \                     ??halIntsAreEnabled_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     46          #include "hal_board.h"
     47          #include "hal_sleep.h"
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "mac_api.h"
     51          #include "comdef.h"
     52          #include "OSAL.h"
     53          #include "OSAL_Clock.h"
     54          #include "OSAL_PwrMgr.h"
     55          #include "OnBoard.h"
     56          #include "hal_drivers.h"
     57          #include "hal_assert.h"
     58          #include "mac_mcu.h"
     59          
     60          #ifndef ZG_BUILD_ENDDEVICE_TYPE
     61          # define ZG_BUILD_ENDDEVICE_TYPE FALSE
     62          #endif
     63          
     64          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
     65          #include "nwk_globals.h"
     66          #include "ZGlobals.h"
     67          #endif
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                           Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          
     74          /* POWER CONSERVATION DEFINITIONS
     75           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     76           */
     77          #define CC2538_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     78          #define CC2538_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     79          #define CC2538_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     80          #define CC2538_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     81          
     82          /* HAL power management mode is set according to the power management state. The default
     83           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     84           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     85           *   1. turn off the system clock, and
     86           *   2. halt the MCU.
     87           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     88           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     89           */
     90          #define HAL_SLEEP_OFF         CC2538_PM0
     91          #define HAL_SLEEP_CHECK       CC2538_PM1
     92          #define HAL_SLEEP_TIMER       CC2538_PM2
     93          #define HAL_SLEEP_DEEP        CC2538_PM3
     94          
     95          #define SLEEP_IE_FLAG    BV(INT_SMTIM - 48)  /* Sleep Interrupt Enable bit */
     96          #define GPIOA_IE_FLAG    BV(INT_GPIOA - 16)  /* GPIOA Interrupt Enable bit */
     97          #define GPIOC_IE_FLAG    BV(INT_GPIOC - 16)  /* GPIOC Interrupt Enable bit */
     98          #define GPIOAC_IE_FLAG   (GPIOC_IE_FLAG | GPIOA_IE_FLAG)
     99          #define DISABLE_IE_FLAG   0UL                /* GPIOC Interrupt Enable bit */
    100          
    101          /* MAX_SLEEP_TIME calculation:
    102           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
    103           *   Round it to 510 seconds or 510000 ms
    104           */
    105          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
    106          
    107          /* 
    108           * Choosing value to be lower than MAC_BACKOFF_TIMER_DEFAULT_NONBEACON_ROLLOVER
    109           *  The unit is in ms. The back off timer rollover should be greater 
    110           * than the value below
    111           */ 
    112          #define MAX_SLEEP_LOOP_TIME              0x510000           /* ~84 minutes */         
    113          
    114          /* minimum time to sleep, this macro is to:
    115           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
    116           * 2. define minimum safe sleep period
    117           */
    118          /* default to minimum safe sleep time minimum CAP */
    119          #if !defined (PM_MIN_SLEEP_TIME)
    120          #define PM_MIN_SLEEP_TIME                2  
    121          #endif
    122          
    123          #define SLEEP_TIMER_ROLLOVER                  0xFFFFFFFF
    124          
    125          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    126           * compare takes into account the amount of processing time spent in function halSleep().
    127           * The first value is determined by measuring the number of sleep timer ticks it from
    128           * the beginning of the function to entering sleep mode or more precisely, when
    129           * MAC_PwrNextTimeout() is called.  The second value is determined by measuring the number
    130           * of sleep timer ticks from exit of sleep mode to the call to MAC_PwrOnReq() where the
    131           * MAC timer is restarted.
    132           */
    133          #define HAL_SLEEP_ADJ_TICKS   (11 + 12)
    134          
    135          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    136          /* set CC2538 power mode; always use PM2 */
    137          #define HAL_SLEEP_PREP_POWER_MODE(mode)  st( PMCTL &= ~SYS_CTRL_PMCTL_PM_M; /* clear mode bits */ \
    138                                                          PMCTL |= mode;   /* set mode bits   */            \
    139                                                          while (!(STLOAD & LDRDY));                        \
    140                                                          halSleepPconValue = PCON_IDLE;                    \
    141                                                        )
    142          #define HAL_SLEEP_SET_POWER_MODE()          halSetSleepMode()
    143          #else
    144          /* Debug: don't set power mode, just block until sleep timer interrupt */
    145          #define HAL_SLEEP_PREP_POWER_MODE(mode)     /* nothing */
    146          #define HAL_SLEEP_SET_POWER_MODE()          st( while(halSleepInt == FALSE); \
    147                                                          halSleepInt = FALSE;         \
    148                                                          HAL_DISABLE_INTERRUPTS();    \
    149                                                        )
    150          #endif
    151          
    152          /* sleep timer interrupt control */
    153          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IntEnable(INT_SMTIM);)    /* enable sleep timer interrupt */
    154          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IntDisable(INT_SMTIM);)   /* disable sleep timer interrupt */
    155          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(IntPendClear(INT_SMTIM);) /* clear sleep interrupt flag */
    156          
    157          /* backup interrupt enable registers before sleep */
    158          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2, ien3, ien4)                                  \
    159                                                        st(ien0  = (HWREG(NVIC_EN0)); /* backup IEN0 register */ \
    160                                                          ien1  = (HWREG(NVIC_EN1)); /* backup IEN1 register */  \
    161                                                          ien2  = (HWREG(NVIC_EN2)); /* backup IEN2 register */  \
    162                                                          ien3  = (HWREG(NVIC_EN3)); /* backup IEN3 register */  \
    163                                                          ien4  = (HWREG(NVIC_EN4)); /* backup IEN4 register */  \
    164                                                           /* disable interrupts in EN0 except GPIO A & C*/      \
    165                                                          (HWREG(NVIC_EN0)) &= GPIOAC_IE_FLAG;                   \
    166                                                           /* disable interrupts in EN1 except Sleep */          \
    167                                                          (HWREG(NVIC_EN1)) &= SLEEP_IE_FLAG;                    \
    168                                                          (HWREG(NVIC_EN2)) &= DISABLE_IE_FLAG;                  \
    169                                                          (HWREG(NVIC_EN3)) &= DISABLE_IE_FLAG;                  \
    170                                                          (HWREG(NVIC_EN4)) &= DISABLE_IE_FLAG;)
    171          
    172          /* disable IEN2 except Port A and C*/
    173          /* restore interrupt enable registers before sleep */          
    174          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2, ien3, ien4)                                      \
    175                                               st((HWREG(NVIC_EN0)) = ien0;   /* restore IEN0 register */ \
    176                                               (HWREG(NVIC_EN1)) = ien1;   /* restore IEN1 register */    \
    177                                               (HWREG(NVIC_EN2)) = ien2;   /* restore IEN2 register */    \
    178                                               (HWREG(NVIC_EN3)) = ien3;   /* restore IEN3 register */    \
    179                                               (HWREG(NVIC_EN4)) = ien4;)  /* restore IEN4 register */                                                                
    180          
    181          /* convert msec to 320 usec units with round */
    182          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    183          
    184          /* for optimized indexing of uint32's */
    185          #if HAL_MCU_LITTLE_ENDIAN()
    186          #define UINT32_NDX0   0
    187          #define UINT32_NDX1   1
    188          #define UINT32_NDX2   2
    189          #define UINT32_NDX3   3
    190          #else
    191          #define UINT32_NDX0   3
    192          #define UINT32_NDX1   2
    193          #define UINT32_NDX2   1
    194          #define UINT32_NDX3   0
    195          #endif
    196          
    197          /* ------------------------------------------------------------------------------------------------
    198           *                                        Global Variables
    199           * ------------------------------------------------------------------------------------------------
    200           */
    201          /* PCON flag value to program when setting power mode */
    202          #if defined (ewarm)

   \                                 In section .data, align 1
    203          volatile __data uint8 halSleepPconValue = PCON_IDLE;
   \                     halSleepPconValue:
   \   00000000   0x01               DC8 1
    204          #else
    205          volatile uint8 halSleepPconValue = PCON_IDLE;
    206          #endif
    207          /* ------------------------------------------------------------------------------------------------
    208           *                                        Local Variables
    209           * ------------------------------------------------------------------------------------------------
    210           */
    211          
    212          /* HAL power management mode is set according to the power management state.
    213           */

   \                                 In section .bss, align 1
    214          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
   \                     halPwrMgtMode:
   \   00000000                      DS8 1
    215          
    216          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    217          static bool halSleepInt = FALSE;
    218          #endif
    219          
    220          /* ------------------------------------------------------------------------------------------------
    221           *                                      Function Prototypes
    222           * ------------------------------------------------------------------------------------------------
    223           */
    224          
    225          void halSetSleepMode(void);
    226          void halSleepTimerIsr(void);
    227          uint32 halSleepSetTimer(uint32 timeout);
    228          
    229          /**************************************************************************************************
    230           * @fn          halSleep
    231           *
    232           * @brief       This function put the CC2538 to sleep.
    233           *
    234           * input parameters
    235           *
    236           * @param       None.
    237           *
    238           * output parameters
    239           *
    240           * None.
    241           *
    242           * @return      None.
    243           **************************************************************************************************
    244           */

   \                                 In section .text, align 2, keep-with-next
    245          void halSetSleepMode(void)
    246          { 
   \                     halSetSleepMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    247            /* Clear if any pending GPIO power interrupts */
    248            SysCtrlPowIntClear();
   \   00000002   0x.... 0x....      BL       SysCtrlPowIntClear
    249            /* Enable SysCtrl Power interrupts during sleep */
    250            SysCtrlPowIntEnableSetting();
   \   00000006   0x.... 0x....      BL       SysCtrlPowIntEnableSetting
    251            
    252            /* If sleep pcon flag is enabled then go to deep sleep */
    253            if(halSleepPconValue)
   \   0000000A   0x....             LDR.N    R0,??DataTable2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??halSetSleepMode_0
    254            {  
    255              SysCtrlDeepSleep();
   \   00000012   0x.... 0x....      BL       SysCtrlDeepSleep
    256            }
    257            
    258            /* Disable SysCtrl Power interrupts after wakeup from sleep */
    259            SysCtrlPowIntDisableSetting();
   \                     ??halSetSleepMode_0: (+1)
   \   00000016   0x.... 0x....      BL       SysCtrlPowIntDisableSetting
    260            
    261            HAL_DISABLE_INTERRUPTS();
   \   0000001A   0x.... 0x....      BL       IntMasterDisable
    262          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    263          
    264          /**************************************************************************************************
    265           * @fn          halSleep
    266           *
    267           * @brief       This function is called from the OSAL task loop using and existing OSAL
    268           *              interface.  It sets the low power mode of the MAC and the CC2538.
    269           *
    270           * input parameters
    271           *
    272           * @param       osal_timeout - Next OSAL timer timeout.
    273           *
    274           * output parameters
    275           *
    276           * None.
    277           *
    278           * @return      None.
    279           **************************************************************************************************
    280           */

   \                                 In section .text, align 2, keep-with-next
    281          void halSleep( uint32 osal_timeout )
    282          {
   \                     halSleep: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    283            uint32        timeout;
    284            uint32        macTimeout = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    285            uint32        sleepTimeStart = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    286            uint32        sleepTimeStop = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x9100             STR      R1,[SP, #+0]
    287            uint32        sleepTime = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
    288            uint32        sleepTimeinms = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
    289            
    290            /* get next OSAL timer expiration converted to 320 usec units */
    291            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
   \   00000010   0x2164             MOVS     R1,#+100
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014   0x301F             ADDS     R0,R0,#+31
   \   00000016   0x0946             LSRS     R6,R0,#+5
    292            
    293            if (timeout == 0)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD103             BNE.N    ??halSleep_0
    294            {
    295              timeout = MAC_PwrNextTimeout();
   \   0000001C   0x.... 0x....      BL       MAC_PwrNextTimeout
   \   00000020   0x0006             MOVS     R6,R0
   \   00000022   0xE007             B.N      ??halSleep_1
    296            }
    297            else
    298            {
    299              /* get next MAC timer expiration */
    300              macTimeout = MAC_PwrNextTimeout();
   \                     ??halSleep_0: (+1)
   \   00000024   0x.... 0x....      BL       MAC_PwrNextTimeout
   \   00000028   0x0001             MOVS     R1,R0
    301          
    302              /* get lesser of two timeouts */
    303              if ((macTimeout != 0) && (macTimeout < timeout))
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD002             BEQ.N    ??halSleep_1
   \   0000002E   0x42B1             CMP      R1,R6
   \   00000030   0xD200             BCS.N    ??halSleep_1
    304              {
    305                timeout = macTimeout;
   \   00000032   0x000E             MOVS     R6,R1
    306              }
    307            }
    308            
    309            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    310             * the device is a stimulated device.
    311             */
    312            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
   \                     ??halSleep_1: (+1)
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD103             BNE.N    ??halSleep_2
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable2_1
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   \   0000003E   0xE002             B.N      ??halSleep_3
   \                     ??halSleep_2: (+1)
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x....             LDR.N    R1,??DataTable2_1
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    313          
    314            /* DEEP sleep can only be entered when zgPollRate == 0.
    315             * This is to eliminate any possibility of entering PM3 between
    316             * two network timers.
    317             */
    318          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
    319            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    320                (timeout == 0 && zgPollRate == 0))
    321          #else
    322            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    323                (timeout == 0))
   \                     ??halSleep_3: (+1)
   \   00000046   0x2E08             CMP      R6,#+8
   \   00000048   0xD202             BCS.N    ??halSleep_4
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xF040 0x80BC      BNE.W    ??halSleep_5
    324          #endif
    325            {
    326              uint32 ien0, ien1, ien2, ien3, ien4;
    327          
    328              HAL_ASSERT(HAL_INTERRUPTS_ARE_ENABLED());
   \                     ??halSleep_4: (+1)
   \   00000050   0x.... 0x....      BL       halIntsAreEnabled
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD101             BNE.N    ??halSleep_6
   \   00000058   0x.... 0x....      BL       halAssertHandler
    329              HAL_DISABLE_INTERRUPTS();
   \                     ??halSleep_6: (+1)
   \   0000005C   0x.... 0x....      BL       IntMasterDisable
    330              
    331              /* always use "deep sleep" to turn off radio VREG on CC2538 */
    332              if (halSleepPconValue != 0 && MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
   \   00000060   0x....             LDR.N    R0,??DataTable2
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xF000 0x80AD      BEQ.W    ??halSleep_7
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       MAC_PwrOffReq
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xF040 0x80A7      BNE.W    ??halSleep_7
    333              {
    334                /* The PCON value is not zero. There is no interrupt overriding the 
    335                 * sleep decision. Also, the radio granted the sleep request.
    336                 */
    337          
    338          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    339                /* get peripherals ready for sleep */
    340                HalKeyEnterSleep();
   \   00000076   0x.... 0x....      BL       HalKeyEnterSleep
    341          #endif
    342          
    343          #ifdef HAL_SLEEP_DEBUG_LED
    344                HAL_TURN_OFF_LED3();
    345          #else
    346                /* use this to turn LEDs off during sleep */
    347                HalLedEnterSleep();
   \   0000007A   0x.... 0x....      BL       HalLedEnterSleep
    348          #endif
    349          
    350                if(timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_LOOP_TIME))
   \   0000007E   0x....             LDR.N    R0,??DataTable2_2  ;; 0xfd2001
   \   00000080   0x4286             CMP      R6,R0
   \   00000082   0xD300             BCC.N    ??halSleep_8
    351                {
    352                  timeout = HAL_SLEEP_MS_TO_320US(MAX_SLEEP_LOOP_TIME);
   \   00000084   0x....             LDR.N    R6,??DataTable2_3  ;; 0xfd2000
    353                }  
    354                
    355                do
    356                 {
    357                  /* enable sleep timer interrupt */
    358                  if(timeout != 0)
   \                     ??halSleep_8: (+1)
   \   00000086   0x2E00             CMP      R6,#+0
   \   00000088   0xD014             BEQ.N    ??halSleep_9
    359                  { 
    360                    if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
   \   0000008A   0x....             LDR.N    R0,??DataTable2_4  ;; 0x185197
   \   0000008C   0x4286             CMP      R6,R0
   \   0000008E   0xD306             BCC.N    ??halSleep_10
    361                    {
    362                      timeout -= HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
   \   00000090   0x....             LDR.N    R0,??DataTable2_5  ;; 0xffe7ae6a
   \   00000092   0x1986             ADDS     R6,R0,R6
    363                      sleepTimeStart = halSleepSetTimer(HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ));
   \   00000094   0x....             LDR.N    R0,??DataTable2_6  ;; 0x185196
   \   00000096   0x.... 0x....      BL       halSleepSetTimer
   \   0000009A   0x0004             MOVS     R4,R0
   \   0000009C   0xE004             B.N      ??halSleep_11
    364                    }
    365                    else
    366                    {
    367                      /* set sleep timer */
    368                      sleepTimeStart = halSleepSetTimer(timeout);
   \                     ??halSleep_10: (+1)
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       halSleepSetTimer
   \   000000A4   0x0004             MOVS     R4,R0
    369                      timeout = 0;
   \   000000A6   0x2600             MOVS     R6,#+0
    370                    }
    371                    
    372                    /* set up sleep timer interrupt */
    373                    HAL_SLEEP_TIMER_CLEAR_INT();
   \                     ??halSleep_11: (+1)
   \   000000A8   0x2030             MOVS     R0,#+48
   \   000000AA   0x.... 0x....      BL       IntPendClear
    374                    HAL_SLEEP_TIMER_ENABLE_INT();
   \   000000AE   0x2030             MOVS     R0,#+48
   \   000000B0   0x.... 0x....      BL       IntEnable
    375                  }
    376          
    377          #ifdef HAL_SLEEP_DEBUG_LED
    378                  if (halPwrMgtMode == HAL_SLEEP_CHECK)
    379                  {
    380                    HAL_TURN_ON_LED1();
    381                  }
    382                  else
    383                  {
    384                    HAL_TURN_OFF_LED1();
    385                  }
    386          #endif
    387                  /* Prep CC2538 power mode */
    388                  HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);
   \                     ??halSleep_9: (+1)
   \   000000B4   0x....             LDR.N    R0,??DataTable2_7  ;; 0x400d2058
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x0880             LSRS     R0,R0,#+2
   \   000000BA   0x0080             LSLS     R0,R0,#+2
   \   000000BC   0x....             LDR.N    R1,??DataTable2_7  ;; 0x400d2058
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0x....             LDR.N    R0,??DataTable2_7  ;; 0x400d2058
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x....             LDR.N    R1,??DataTable2_1
   \   000000C6   0x7809             LDRB     R1,[R1, #+0]
   \   000000C8   0x4308             ORRS     R0,R1,R0
   \   000000CA   0x....             LDR.N    R1,??DataTable2_7  ;; 0x400d2058
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   \                     ??halSleep_12: (+1)
   \   000000CE   0x....             LDR.N    R0,??DataTable2_8  ;; 0x400d5050
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x07C0             LSLS     R0,R0,#+31
   \   000000D4   0xD5FB             BPL.N    ??halSleep_12
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x....             LDR.N    R1,??DataTable2
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
    389                  /* save interrupt enable registers and disable all  
    390                   * interrupts except for sleep timer and Key press 
    391                   */
    392                  HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2, ien3, ien4);
   \   000000DC   0x....             LDR.N    R0,??DataTable2_9  ;; 0xe000e100
   \   000000DE   0x6807             LDR      R7,[R0, #+0]
   \   000000E0   0x....             LDR.N    R0,??DataTable2_10  ;; 0xe000e104
   \   000000E2   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \   000000E6   0x....             LDR.N    R0,??DataTable2_11  ;; 0xe000e108
   \   000000E8   0xF8D0 0x9000      LDR      R9,[R0, #+0]
   \   000000EC   0x....             LDR.N    R0,??DataTable2_12  ;; 0xe000e10c
   \   000000EE   0xF8D0 0xA000      LDR      R10,[R0, #+0]
   \   000000F2   0x....             LDR.N    R0,??DataTable2_13  ;; 0xe000e110
   \   000000F4   0xF8D0 0xB000      LDR      R11,[R0, #+0]
   \   000000F8   0x....             LDR.N    R0,??DataTable2_9  ;; 0xe000e100
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0xF010 0x0005      ANDS     R0,R0,#0x5
   \   00000100   0x....             LDR.N    R1,??DataTable2_9  ;; 0xe000e100
   \   00000102   0x6008             STR      R0,[R1, #+0]
   \   00000104   0x....             LDR.N    R0,??DataTable2_10  ;; 0xe000e104
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000010C   0x....             LDR.N    R1,??DataTable2_10  ;; 0xe000e104
   \   0000010E   0x6008             STR      R0,[R1, #+0]
   \   00000110   0x....             LDR.N    R0,??DataTable2_11  ;; 0xe000e108
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x....             LDR.N    R1,??DataTable2_11  ;; 0xe000e108
   \   00000118   0x6008             STR      R0,[R1, #+0]
   \   0000011A   0x....             LDR.N    R0,??DataTable2_12  ;; 0xe000e10c
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x....             LDR.N    R1,??DataTable2_12  ;; 0xe000e10c
   \   00000122   0x6008             STR      R0,[R1, #+0]
   \   00000124   0x....             LDR.N    R0,??DataTable2_13  ;; 0xe000e110
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x....             LDR.N    R1,??DataTable2_13  ;; 0xe000e110
   \   0000012C   0x6008             STR      R0,[R1, #+0]
    393                  /* Disable SysTick Interrupt */
    394                  SysTickIntDisable();
   \   0000012E   0x.... 0x....      BL       SysTickIntDisable
    395                  
    396                  /* Master Interrupt Enable */
    397                  HAL_ENABLE_INTERRUPTS();
   \   00000132   0x.... 0x....      BL       IntMasterEnable
    398                  
    399                  /* set CC2538 power mode, interrupt is disabled after this function
    400                   * Note that an ISR (that could wake up from power mode) which runs
    401                   * between the previous instruction enabling interrupts and before
    402                   * power mode is set would switch the halSleepPconValue so that
    403                   * power mode shall not be entered in such a case. 
    404                   */
    405                  HAL_SLEEP_SET_POWER_MODE(); 
   \   00000136   0x.... 0x....      BL       halSetSleepMode
    406                  
    407                  /* restore interrupt enable registers */
    408                  HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2, ien3, ien4);
   \   0000013A   0x....             LDR.N    R0,??DataTable2_9  ;; 0xe000e100
   \   0000013C   0x6007             STR      R7,[R0, #+0]
   \   0000013E   0x....             LDR.N    R0,??DataTable2_10  ;; 0xe000e104
   \   00000140   0xF8C0 0x8000      STR      R8,[R0, #+0]
   \   00000144   0x....             LDR.N    R0,??DataTable2_11  ;; 0xe000e108
   \   00000146   0xF8C0 0x9000      STR      R9,[R0, #+0]
   \   0000014A   0x....             LDR.N    R0,??DataTable2_12  ;; 0xe000e10c
   \   0000014C   0xF8C0 0xA000      STR      R10,[R0, #+0]
   \   00000150   0x....             LDR.N    R0,??DataTable2_13  ;; 0xe000e110
   \   00000152   0xF8C0 0xB000      STR      R11,[R0, #+0]
    409          
    410                  /* disable sleep timer interrupt */
    411                  HAL_SLEEP_TIMER_DISABLE_INT();
   \   00000156   0x2030             MOVS     R0,#+48
   \   00000158   0x.... 0x....      BL       IntDisable
    412          
    413                  if(HAL_SLEEP_TIMER == halPwrMgtMode)
   \   0000015C   0x....             LDR.N    R0,??DataTable2_1
   \   0000015E   0x7800             LDRB     R0,[R0, #+0]
   \   00000160   0x2802             CMP      R0,#+2
   \   00000162   0xD114             BNE.N    ??halSleep_13
    414                  {
    415                    /* To Calculate duration of time in sleep, 
    416                     * read the sleep timer; ST0 must be read first 
    417                     */
    418                    ((uint8 *) &sleepTimeStop)[UINT32_NDX0] = ST0;
   \   00000164   0x....             LDR.N    R0,??DataTable2_14  ;; 0x400d5040
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0xF88D 0x0000      STRB     R0,[SP, #+0]
    419                    ((uint8 *) &sleepTimeStop)[UINT32_NDX1] = ST1;
   \   0000016C   0x....             LDR.N    R0,??DataTable2_15  ;; 0x400d5044
   \   0000016E   0x6800             LDR      R0,[R0, #+0]
   \   00000170   0xF88D 0x0001      STRB     R0,[SP, #+1]
    420                    ((uint8 *) &sleepTimeStop)[UINT32_NDX2] = ST2;
   \   00000174   0x....             LDR.N    R0,??DataTable2_16  ;; 0x400d5048
   \   00000176   0x6800             LDR      R0,[R0, #+0]
   \   00000178   0xF88D 0x0002      STRB     R0,[SP, #+2]
    421                    ((uint8 *) &sleepTimeStop)[UINT32_NDX3] = ST3;
   \   0000017C   0x....             LDR.N    R0,??DataTable2_17  ;; 0x400d504c
   \   0000017E   0x6800             LDR      R0,[R0, #+0]
   \   00000180   0xF88D 0x0003      STRB     R0,[SP, #+3]
    422                    
    423                    sleepTime += ((sleepTimeStop - sleepTimeStart) + HAL_SLEEP_ADJ_TICKS) 
    424                      & 0xffffffffu;
   \   00000184   0x9800             LDR      R0,[SP, #+0]
   \   00000186   0x1940             ADDS     R0,R0,R5
   \   00000188   0x1B00             SUBS     R0,R0,R4
   \   0000018A   0xF110 0x0517      ADDS     R5,R0,#+23
    425                   }
    426          
    427          #ifdef HAL_SLEEP_DEBUG_LED
    428                  HAL_TURN_ON_LED3();
    429          #else
    430                  /* use this to turn LEDs back on after sleep */
    431                  HalLedExitSleep();
   \                     ??halSleep_13: (+1)
   \   0000018E   0x.... 0x....      BL       HalLedExitSleep
    432          #endif
    433          
    434          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    435                  /* handle peripherals */
    436                  if(HalKeyExitSleep())
   \   00000192   0x.... 0x....      BL       HalKeyExitSleep
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD102             BNE.N    ??halSleep_14
    437                  {
    438                    break; 
    439                  }
    440          #endif
    441                } while(timeout != 0);
   \                     ??halSleep_15: (+1)
   \   0000019A   0x2E00             CMP      R6,#+0
   \   0000019C   0xF47F 0xAF73      BNE.W    ??halSleep_8
    442                
    443                /* Convert 32Khz ticks to ms = sleeptime * 1000/ 32768 */
    444                sleepTimeinms = ((sleepTime * 125) / 4096);
   \                     ??halSleep_14: (+1)
   \   000001A0   0x207D             MOVS     R0,#+125
   \   000001A2   0xFB00 0xF005      MUL      R0,R0,R5
   \   000001A6   0x0B01             LSRS     R1,R0,#+12
    445                
    446                if(sleepTimeinms)
   \   000001A8   0x2900             CMP      R1,#+0
   \   000001AA   0xD002             BEQ.N    ??halSleep_16
    447                {
    448                  /* Update the osal timers and clock with the sleep time */
    449                  osalAdjustTimer(sleepTimeinms);
   \   000001AC   0x0008             MOVS     R0,R1
   \   000001AE   0x.... 0x....      BL       osalAdjustTimer
    450                }
    451                
    452                /* Enable Systick interrupts*/
    453                SysTickIntEnable();
   \                     ??halSleep_16: (+1)
   \   000001B2   0x.... 0x....      BL       SysTickIntEnable
    454                /* power on the MAC; blocks until completion */
    455                MAC_PwrOnReq();
   \   000001B6   0x.... 0x....      BL       MAC_PwrOnReq
    456                
    457          
    458                /* Enable the interrupts */
    459                HAL_ENABLE_INTERRUPTS();
   \   000001BA   0x.... 0x....      BL       IntMasterEnable
    460          
    461                /* For CC2530, T2 interrupt won’t be generated when the current count is greater than
    462                 * the comparator. The interrupt is only generated when the current count is equal to
    463                 * the comparator. When the CC2530 is waking up from sleep, there is a small window
    464                 * that the count may be grater than the comparator, therefore, missing the interrupt.
    465                 * This workaround will call the T2 ISR when the current T2 count is greater than the
    466                 * comparator. The problem only occurs when POWER_SAVING is turned on, i.e. the 32KHz
    467                 * drives the chip in sleep and SYNC start is used.
    468                 */
    469                macMcuTimer2OverflowWorkaround();
   \   000001BE   0x.... 0x....      BL       macMcuTimer2OverflowWorkaround
   \   000001C2   0xE001             B.N      ??halSleep_5
    470              }
    471              else
    472              {
    473                /* An interrupt may have changed the sleep decision. Do not sleep at all. Turn on
    474                 * the interrupt, exit normally, and the next sleep will be allowed.
    475                 */
    476                HAL_ENABLE_INTERRUPTS();
   \                     ??halSleep_7: (+1)
   \   000001C4   0x.... 0x....      BL       IntMasterEnable
    477              }
    478          #if defined FEATURE_8MHZ_HYBRID_POWER_SAVING
    479              SysCtrlClockSet(OSC_32KHZ, 
    480                              false,  
    481                              SYS_CTRL_SYSDIV_8MHZ);
    482          #endif
    483            }
    484          }
   \                     ??halSleep_5: (+1)
   \   000001C8   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    485          
    486          /**************************************************************************************************
    487           * @fn          halSleepSetTimer
    488           *
    489           * @brief       This function sets the CC2538 sleep timer compare value.  First it reads and
    490           *              stores the value of the sleep timer; this value is used later to update OSAL
    491           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    492           *              period units and the compare value is set to the timeout.
    493           *
    494           * input parameters
    495           *
    496           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    497           *                        this value.
    498           *
    499           * output parameters
    500           *
    501           * None.
    502           *
    503           * @return      None.
    504           **************************************************************************************************
    505           */

   \                                 In section .text, align 2, keep-with-next
    506          uint32 halSleepSetTimer(uint32 timeout)
    507          {
   \                     halSleepSetTimer: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    508            uint32 ticks;
    509            uint32 sleeptime;
    510          
    511            /* read the sleep timer; ST0 must be read first */
    512            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   00000002   0x....             LDR.N    R1,??DataTable2_14  ;; 0x400d5040
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
    513            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   0000000A   0x....             LDR.N    R1,??DataTable2_15  ;; 0x400d5044
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0xF88D 0x1001      STRB     R1,[SP, #+1]
    514            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   00000012   0x....             LDR.N    R1,??DataTable2_16  ;; 0x400d5048
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF88D 0x1002      STRB     R1,[SP, #+2]
    515            ((uint8 *) &ticks)[UINT32_NDX3] = ST3;
   \   0000001A   0x....             LDR.N    R1,??DataTable2_17  ;; 0x400d504c
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF88D 0x1003      STRB     R1,[SP, #+3]
    516            
    517            /* store ticks in sleeptime */
    518            sleeptime = ticks;
   \   00000022   0x9900             LDR      R1,[SP, #+0]
    519            
    520            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    521             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    522             */
    523            ticks += (timeout * 671) / 64;
   \   00000024   0x9A00             LDR      R2,[SP, #+0]
   \   00000026   0xF240 0x239F      MOVW     R3,#+671
   \   0000002A   0x4358             MULS     R0,R3,R0
   \   0000002C   0xEB12 0x1090      ADDS     R0,R2,R0, LSR #+6
   \   00000030   0x9000             STR      R0,[SP, #+0]
    524          
    525            /* subtract the processing time spent in function halSleep() */
    526            if(ticks >= HAL_SLEEP_ADJ_TICKS)
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x2817             CMP      R0,#+23
   \   00000036   0xD302             BCC.N    ??halSleepSetTimer_0
    527            {  
    528              ticks -= HAL_SLEEP_ADJ_TICKS;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x3817             SUBS     R0,R0,#+23
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    529            }
    530            
    531            /* set sleep timer compare; ST0 must be written last */
    532            ST3 = ((uint8 *) &ticks)[UINT32_NDX3];
   \                     ??halSleepSetTimer_0: (+1)
   \   0000003E   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000042   0x....             LDR.N    R2,??DataTable2_17  ;; 0x400d504c
   \   00000044   0x6010             STR      R0,[R2, #+0]
    533            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
   \   00000046   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000004A   0x....             LDR.N    R2,??DataTable2_16  ;; 0x400d5048
   \   0000004C   0x6010             STR      R0,[R2, #+0]
    534            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
   \   0000004E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000052   0x....             LDR.N    R2,??DataTable2_15  ;; 0x400d5044
   \   00000054   0x6010             STR      R0,[R2, #+0]
    535            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
   \   00000056   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005A   0x....             LDR.N    R2,??DataTable2_14  ;; 0x400d5040
   \   0000005C   0x6010             STR      R0,[R2, #+0]
    536            
    537            return sleeptime; 
   \   0000005E   0x0008             MOVS     R0,R1
   \   00000060   0xB001             ADD      SP,SP,#+4
   \   00000062   0x4770             BX       LR               ;; return
    538          }
    539          
    540          /**************************************************************************************************
    541           * @fn          TimerElapsed
    542           *
    543           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    544           *              Deprecated for CC2538 and CC2430 SoC.
    545           *
    546           * input parameters
    547           *
    548           * @param       None.
    549           *
    550           * output parameters
    551           *
    552           * None.
    553           *
    554           * @return      Number of timer ticks elapsed during sleep.
    555           **************************************************************************************************
    556           */

   \                                 In section .text, align 2, keep-with-next
    557          uint32 TimerElapsed( void )
    558          {
    559            /* Stubs */
    560            return (0);
   \                     TimerElapsed: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    561          }
    562          
    563          /**************************************************************************************************
    564           * @fn          halRestoreSleepLevel
    565           *
    566           * @brief       Restore the deepest timer sleep level.
    567           *
    568           * input parameters
    569           *
    570           * @param       None
    571           *
    572           * output parameters
    573           *
    574           *              None.
    575           *
    576           * @return      None.
    577           **************************************************************************************************
    578           */

   \                                 In section .text, align 2, keep-with-next
    579          void halRestoreSleepLevel( void )
    580          {
    581            /* Stubs */
    582          }
   \                     halRestoreSleepLevel: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    583          
    584          /**************************************************************************************************
    585           * @fn          halSleepTimerIsr
    586           *
    587           * @brief       Sleep timer ISR.
    588           *
    589           * input parameters
    590           *
    591           * None.
    592           *
    593           * output parameters
    594           *
    595           * None.
    596           *
    597           * @return      None.
    598           **************************************************************************************************
    599           */

   \                                 In section .text, align 2, keep-with-next
    600          void halSleepTimerIsr(void)
    601          {
   \                     halSleepTimerIsr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    602            /* Clear any pending sleep interrupts */
    603            HAL_SLEEP_TIMER_CLEAR_INT();
   \   00000002   0x2030             MOVS     R0,#+48
   \   00000004   0x.... 0x....      BL       IntPendClear
    604            
    605          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    606            halSleepInt = TRUE;
    607          #endif
    608            
    609            /* Disable sleep mode till the next Hal_ProcessPoll  */
    610            CLEAR_SLEEP_MODE();
    611          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     halSleepPconValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     halPwrMgtMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x00FD2001         DC32     0xfd2001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x00FD2000         DC32     0xfd2000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x00185197         DC32     0x185197

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0xFFE7AE6A         DC32     0xffe7ae6a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x00185196         DC32     0x185196

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x400D2058         DC32     0x400d2058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x400D5050         DC32     0x400d5050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0xE000E104         DC32     0xe000e104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0xE000E108         DC32     0xe000e108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0xE000E10C         DC32     0xe000e10c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0xE000E110         DC32     0xe000e110

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x400D5040         DC32     0x400d5040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x400D5044         DC32     0x400d5044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x400D5048         DC32     0x400d5048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_17:
   \   00000000   0x400D504C         DC32     0x400d504c
    612          
    613          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TimerElapsed
       8   halIntsAreEnabled
         8   -> IntMasterDisable
         8   -> IntMasterEnable
       0   halRestoreSleepLevel
       8   halSetSleepMode
         8   -> IntMasterDisable
         8   -> SysCtrlDeepSleep
         8   -> SysCtrlPowIntClear
         8   -> SysCtrlPowIntDisableSetting
         8   -> SysCtrlPowIntEnableSetting
      40   halSleep
        40   -> HalKeyEnterSleep
        40   -> HalKeyExitSleep
        40   -> HalLedEnterSleep
        40   -> HalLedExitSleep
        40   -> IntDisable
        40   -> IntEnable
        40   -> IntMasterDisable
        40   -> IntMasterEnable
        40   -> IntPendClear
        40   -> MAC_PwrNextTimeout
        40   -> MAC_PwrOffReq
        40   -> MAC_PwrOnReq
        40   -> SysTickIntDisable
        40   -> SysTickIntEnable
        40   -> halAssertHandler
        40   -> halIntsAreEnabled
        40   -> halSetSleepMode
        40   -> halSleepSetTimer
        40   -> macMcuTimer2OverflowWorkaround
        40   -> osalAdjustTimer
       4   halSleepSetTimer
       8   halSleepTimerIsr
         8   -> IntPendClear


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       4  TimerElapsed
      30  halIntsAreEnabled
       1  halPwrMgtMode
       2  halRestoreSleepLevel
      32  halSetSleepMode
     460  halSleep
       1  halSleepPconValue
     100  halSleepSetTimer
      10  halSleepTimerIsr

 
   1 byte  in section .bss
   1 byte  in section .data
 710 bytes in section .text
 
 710 bytes of CODE memory
   2 bytes of DATA memory

Errors: none
Warnings: none
