###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        06/Aug/2015  22:29:21
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\stack\zdo\ZDProfile.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\stack\zdo\ZDProfile.c" -D EVERWRIST -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Projects\zstack\ZMain\TI2538DB\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\" -I "C:\Texas Instruments\Z-Stack
#        Mesh 1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -I
#        "C:\Texas
#        Instruments\cc2538_foundation_firmware_1_0_1_0\driverlib\cc2538\source\"
#        -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ZDProfile.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\ZDProfile.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\ZDProfile.c
      1          /**************************************************************************************************
      2            Filename:       ZDProfile.c
      3            Revised:        $Date: 2013-10-02 15:57:50 -0700 (Wed, 02 Oct 2013) $
      4            Revision:       $Revision: 35529 $
      5          
      6            Description:    This is the Zigbee Device Profile.
      7          
      8          
      9            Copyright 2004-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "AF.h"
     46          #include "NLMEDE.h"
     47          #include "nwk_util.h"
     48          #include "APS.h"
     49          
     50          #include "AddrMgr.h"
     51          #include "ZDConfig.h"
     52          #include "ZDProfile.h"
     53          #include "ZDObject.h"
     54          #include "ZDNwkMgr.h"
     55          
     56          #if defined( LCD_SUPPORTED )
     57            #include "OnBoard.h"
     58          #endif
     59          
     60          #include "nwk_util.h"
     61          
     62          #if defined( MT_ZDO_FUNC )
     63            #include "MT_ZDO.h"
     64          #endif
     65          
     66          /*********************************************************************
     67           * MACROS
     68           */
     69          
     70          #define ZADDR_TO_AFADDR( pZADDR, AFADDR ) {                            \
     71            (AFADDR).endPoint = ZDP_AF_ENDPOINT;                                 \
     72            (AFADDR).addrMode = (afAddrMode_t)(pZADDR)->addrMode;                \
     73            (AFADDR).addr.shortAddr = (pZADDR)->addr.shortAddr;                  \
     74          }
     75          
     76          #define FillAndSendBuffer( TRANSSEQ, ADDR, ID, LEN, BUF ) {     \
     77            afStatus_t stat;                                    \
     78            ZDP_TmpBuf = (BUF)+1;                               \
     79            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     80            osal_mem_free( (BUF) );                             \
     81            ZDP_TmpBuf = ZDP_Buf+1;                             \
     82            return stat;                                        \
     83          }
     84          
     85          #define FillAndSendTxOptions( TRANSSEQ, ADDR, ID, LEN, TxO ) {  \
     86            afStatus_t stat;                                    \
     87            ZDP_TxOptions = (TxO);                              \
     88            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     89            ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
     90            return stat;                                        \
     91          }
     92          
     93          #define FillAndSendBufferTxOptions( TRANSSEQ, ADDR, ID, LEN, BUF, TxO ) { \
     94            afStatus_t stat;                                    \
     95            ZDP_TmpBuf = (BUF)+1;                               \
     96            ZDP_TxOptions = (TxO);                              \
     97            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     98            osal_mem_free( (BUF) );                             \
     99            ZDP_TmpBuf = ZDP_Buf+1;                             \
    100            ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
    101            return stat;                                        \
    102          }
    103          
    104          /*********************************************************************
    105           * CONSTANTS
    106           */
    107          
    108          #define ZDP_BUF_SZ          80
    109          

   \                                 In section .rodata, align 1
    110          CONST byte ZDP_AF_ENDPOINT = 0;
   \                     ZDP_AF_ENDPOINT:
   \   00000000   0x00               DC8 0
    111          
    112          // Routing table options
    113          #define ZP_RTG_RECORD       0x04       // Routing table indication that a route record is needed
    114          #define ZP_MTO_ROUTE_RC     0x08       // Concentrator with routing cache
    115          #define ZP_MTO_ROUTE_NRC    0x10       // Concentrator with limited cache
    116          
    117          
    118          /*********************************************************************
    119           * TYPEDEFS
    120           */
    121          typedef struct
    122          {
    123            void *next;
    124            uint8 taskID;
    125            uint16 clusterID;
    126          } ZDO_MsgCB_t;
    127          
    128          
    129          /*********************************************************************
    130           * GLOBAL VARIABLES
    131           */
    132          

   \                                 In section .bss, align 1
    133          byte ZDP_TransID = 0;
   \                     ZDP_TransID:
   \   00000000                      DS8 1
    134          
    135          /*********************************************************************
    136           * EXTERNAL VARIABLES
    137           */
    138          
    139          extern endPointDesc_t ZDApp_epDesc;
    140          
    141          /*********************************************************************
    142           * EXTERNAL FUNCTIONS
    143           */
    144          
    145          /*********************************************************************
    146           * LOCAL FUNCTIONS
    147           */
    148          
    149          static afStatus_t fillAndSend( uint8 *transSeq, zAddrType_t *addr, cId_t clusterID, byte len );
    150          uint8 ZDO_SendMsgCBs( zdoIncomingMsg_t *inMsg );
    151          void zdpProcessAddrReq( zdoIncomingMsg_t *inMsg );
    152          
    153          /*********************************************************************
    154           * LOCAL VARIABLES
    155           */
    156          

   \                                 In section .bss, align 4
    157          static uint8  ZDP_Buf[ ZDP_BUF_SZ ];
   \                     ZDP_Buf:
   \   00000000                      DS8 80

   \                                 In section .data, align 4
    158          static uint8 *ZDP_TmpBuf = ZDP_Buf+1;
   \                     ZDP_TmpBuf:
   \   00000000   0x........         DC32 ZDP_Buf + 1H
    159          

   \                                 In section .bss, align 1
    160          byte ZDP_TxOptions = AF_TX_OPTIONS_NONE;
   \                     ZDP_TxOptions:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    161          ZDO_MsgCB_t *zdoMsgCBs = (ZDO_MsgCB_t *)NULL;
   \                     zdoMsgCBs:
   \   00000000                      DS8 4
    162          
    163          /*********************************************************************
    164           * ZDO Message Processing table
    165           */
    166          
    167          typedef void (*pfnZDPMsgProcessor)( zdoIncomingMsg_t *inMsg );
    168          
    169          typedef struct
    170          {
    171            uint16                clusterID;
    172            pfnZDPMsgProcessor    pFn;
    173          } zdpMsgProcItem_t;
    174          

   \                                 In section .rodata, align 4
    175          CONST zdpMsgProcItem_t zdpMsgProcs[] =
   \                     zdpMsgProcs:
   \   00000000   0x0001             DC16 1
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 zdpProcessAddrReq
   \   00000008   0x0002             DC16 2
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 ZDO_ProcessNodeDescReq
   \   00000010   0x0003             DC16 3
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x........         DC32 ZDO_ProcessPowerDescReq
   \   00000018   0x0004             DC16 4
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x........         DC32 ZDO_ProcessSimpleDescReq
   \   00000020   0x0005             DC16 5
   \   00000022   0x00 0x00          DC8 0, 0
   \   00000024   0x........         DC32 ZDO_ProcessActiveEPReq
   \   00000028   0x0006             DC16 6
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 ZDO_ProcessMatchDescReq
   \   00000030   0xFFFF             DC16 65535
   \   00000032   0x00 0x00          DC8 0, 0
   \   00000034   0x00000000         DC32 0H
    176          {
    177          #if ( RFD_RCVC_ALWAYS_ON==TRUE ) || ( ZG_BUILD_RTR_TYPE )
    178            // These aren't processed by sleeping end devices.
    179            { NWK_addr_req,           zdpProcessAddrReq },
    180            { Device_annce,           ZDO_ProcessDeviceAnnce },
    181          #endif
    182            { IEEE_addr_req,          zdpProcessAddrReq },
    183            { Node_Desc_req,          ZDO_ProcessNodeDescReq },
    184            { Power_Desc_req,         ZDO_ProcessPowerDescReq },
    185            { Simple_Desc_req,        ZDO_ProcessSimpleDescReq },
    186            { Active_EP_req,          ZDO_ProcessActiveEPReq },
    187            { Match_Desc_req,         ZDO_ProcessMatchDescReq },
    188          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
    189            { Mgmt_NWK_Disc_req,      ZDO_ProcessMgmtNwkDiscReq },
    190          #endif
    191          #if defined ( ZDO_MGMT_LQI_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    192            { Mgmt_Lqi_req,           ZDO_ProcessMgmtLqiReq },
    193          #endif
    194          #if defined ( ZDO_MGMT_RTG_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    195            { Mgmt_Rtg_req,           ZDO_ProcessMgmtRtgReq },
    196          #endif
    197          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && defined ( REFLECTOR )
    198            { Mgmt_Bind_req,          ZDO_ProcessMgmtBindReq },
    199          #endif
    200          #if defined ( ZDO_MGMT_JOINDIRECT_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    201            { Mgmt_Direct_Join_req,   ZDO_ProcessMgmtDirectJoinReq },
    202          #endif
    203          #if defined ( ZDO_MGMT_LEAVE_RESPONSE )
    204            { Mgmt_Leave_req,         ZDO_ProcessMgmtLeaveReq },
    205          #endif
    206          #if defined ( ZDO_MGMT_PERMIT_JOIN_RESPONSE )  && ( ZG_BUILD_RTR_TYPE )
    207            { Mgmt_Permit_Join_req,   ZDO_ProcessMgmtPermitJoinReq },
    208          #endif
    209          #if defined ( ZDO_USERDESC_RESPONSE )
    210            { User_Desc_req,          ZDO_ProcessUserDescReq },
    211          #endif
    212          #if defined ( ZDO_USERDESCSET_RESPONSE )
    213            { User_Desc_set,          ZDO_ProcessUserDescSet },
    214          #endif
    215          #if defined ( ZDO_SERVERDISC_RESPONSE )
    216            { Server_Discovery_req,   ZDO_ProcessServerDiscReq },
    217          #endif
    218          #if defined ( ZIGBEE_CHILD_AGING )
    219          #if defined ( ZDO_ENDDEVICETIMEOUT_REQUEST )
    220            { End_Device_Timeout_req, ZDO_ProcessEndDeviceTimeoutReq },
    221          #endif
    222          #endif // ZIGBEE_CHILD_AGING
    223            {0xFFFF, NULL} // Last
    224          };
    225          
    226          /*********************************************************************
    227           * @fn          fillAndSend
    228           *
    229           * @brief       Combined to reduce space
    230           *
    231           * @param
    232           * @param
    233           *
    234           * @return      afStatus_t
    235           */

   \                                 In section .text, align 2, keep-with-next
    236          static afStatus_t fillAndSend( uint8 *transSeq, zAddrType_t *addr, cId_t clusterID, byte len )
    237          {
   \                     fillAndSend: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
    238            afAddrType_t afAddr;
    239          
    240            osal_memset( &afAddr, 0, sizeof(afAddrType_t) );
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xA804             ADD      R0,SP,#+16
   \   00000012   0x.... 0x....      BL       osal_memset
    241            ZADDR_TO_AFADDR( addr, afAddr );
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xF88D 0x0019      STRB     R0,[SP, #+25]
   \   00000020   0x7A38             LDRB     R0,[R7, #+8]
   \   00000022   0xF88D 0x0018      STRB     R0,[SP, #+24]
   \   00000026   0x8838             LDRH     R0,[R7, #+0]
   \   00000028   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    242          
    243            *(ZDP_TmpBuf-1) = *transSeq;
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0xF801 0x0C01      STRB     R0,[R1, #-1]
    244          
    245            return AF_DataRequest( &afAddr, &ZDApp_epDesc, clusterID,
    246                                     (uint16)(len+1), (uint8*)(ZDP_TmpBuf-1),
    247                                     transSeq, ZDP_TxOptions,  AF_DEFAULT_RADIUS );
   \   00000038   0x201E             MOVS     R0,#+30
   \   0000003A   0x9003             STR      R0,[SP, #+12]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x9002             STR      R0,[SP, #+8]
   \   00000044   0x9401             STR      R4,[SP, #+4]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x1C73             ADDS     R3,R6,#+1
   \   00000054   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000056   0x002A             MOVS     R2,R5
   \   00000058   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable28
   \   0000005E   0xA804             ADD      R0,SP,#+16
   \   00000060   0x.... 0x....      BL       AF_DataRequest
   \   00000064   0xB007             ADD      SP,SP,#+28
   \   00000066   0xBDF0             POP      {R4-R7,PC}       ;; return
    248          
    249          }
    250          
    251          /*********************************************************************
    252           * @fn          ZDP_SendData
    253           *
    254           * @brief       This builds and send a request message that has
    255           *              NWKAddrOfInterest as its only parameter.
    256           *
    257           * @param       dstAddr - destination address
    258           * @param       cmd - clusterID
    259           * @param       dataLen - number of bytes of data
    260           * @param       data - pointer to the data
    261           * @param       SecurityEnable - Security Options
    262           *
    263           * @return      afStatus_t
    264           */

   \                                 In section .text, align 2, keep-with-next
    265          afStatus_t ZDP_SendData( uint8 *TransSeq, zAddrType_t *dstAddr, uint16 cmd,
    266                                  byte len, uint8 *buf, byte SecurityEnable )
    267          {
   \                     ZDP_SendData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    268            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000006   0x6825             LDR      R5,[R4, #+0]
    269            byte cnt = len;
   \   00000008   0x001E             MOVS     R6,R3
   \   0000000A   0x9C06             LDR      R4,[SP, #+24]
   \   0000000C   0xE003             B.N      ??ZDP_SendData_0
    270          
    271            while ( cnt-- )
    272            {
    273              *pBuf++ = *buf++;
   \                     ??ZDP_SendData_1: (+1)
   \   0000000E   0x7827             LDRB     R7,[R4, #+0]
   \   00000010   0x702F             STRB     R7,[R5, #+0]
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
    274            }
   \                     ??ZDP_SendData_0: (+1)
   \   00000016   0x0037             MOVS     R7,R6
   \   00000018   0x1E7E             SUBS     R6,R7,#+1
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD1F6             BNE.N    ??ZDP_SendData_1
    275          
    276            FillAndSendTxOptions( TransSeq, dstAddr, cmd, len, ((SecurityEnable) ? AF_EN_SECURITY : 0) );
   \   00000020   0x9C07             LDR      R4,[SP, #+28]
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD004             BEQ.N    ??ZDP_SendData_2
   \   00000026   0x2440             MOVS     R4,#+64
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable27_2
   \   0000002C   0x702C             STRB     R4,[R5, #+0]
   \   0000002E   0xE003             B.N      ??ZDP_SendData_3
   \                     ??ZDP_SendData_2: (+1)
   \   00000030   0x2400             MOVS     R4,#+0
   \   00000032   0x.... 0x....      LDR.W    R5,??DataTable27_2
   \   00000036   0x702C             STRB     R4,[R5, #+0]
   \                     ??ZDP_SendData_3: (+1)
   \   00000038   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   0x.... 0x....      BL       fillAndSend
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   00000046   0x7011             STRB     R1,[R2, #+0]
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    277          }
    278          
    279          /*********************************************************************
    280           * @fn          ZDP_NWKAddrOfInterestReq
    281           *
    282           * @brief       This builds and send a request message that has
    283           *              NWKAddrOfInterest as its only parameter.
    284           *
    285           * @param       dstAddr - destination address
    286           * @param       nwkAddr - 16 bit address
    287           * @param       SecurityEnable - Security Options
    288           *
    289           * @return      afStatus_t
    290           */

   \                                 In section .text, align 2, keep-with-next
    291          afStatus_t ZDP_NWKAddrOfInterestReq( zAddrType_t *dstAddr, uint16 nwkAddr,
    292                                               byte cmd, byte SecurityEnable )
    293          {
   \                     ZDP_NWKAddrOfInterestReq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    294            (void)SecurityEnable;  // Intentionally unreferenced parameter
    295          
    296            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x7019             STRB     R1,[R3, #+0]
    297            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x0A09             LSRS     R1,R1,#+8
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   00000012   0x681B             LDR      R3,[R3, #+0]
   \   00000014   0x7059             STRB     R1,[R3, #+1]
    298          
    299            return fillAndSend( &ZDP_TransID, dstAddr, cmd, 2 );
   \   00000016   0x2302             MOVS     R3,#+2
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000022   0x.... 0x....      BL       fillAndSend
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    300          }
    301          
    302          /*********************************************************************
    303           * Address Requests
    304           */
    305          
    306          /*********************************************************************
    307           * @fn          ZDP_NwkAddrReq
    308           *
    309           * @brief       This builds and send a NWK_addr_req message.  This
    310           *              function sends a broadcast message looking for a 16
    311           *              bit address with a 64 bit address as bait.
    312           *
    313           * @param       IEEEAddress - looking for this device
    314           * @param       SecurityEnable - Security Options
    315           *
    316           * @return      afStatus_t
    317           */

   \                                 In section .text, align 2, keep-with-next
    318          afStatus_t ZDP_NwkAddrReq( uint8 *IEEEAddress, byte ReqType,
    319                                     byte StartIndex, byte SecurityEnable )
    320          {
   \                     ZDP_NwkAddrReq: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    321            uint8 *pBuf = ZDP_TmpBuf;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000010   0x6807             LDR      R7,[R0, #+0]
    322            byte len = Z_EXTADDR_LEN + 1 + 1;  // IEEEAddress + ReqType + StartIndex.
   \   00000012   0xF05F 0x080A      MOVS     R8,#+10
    323            zAddrType_t dstAddr;
    324          
    325            (void)SecurityEnable;  // Intentionally unreferenced parameter
    326          
    327            if ( osal_ExtAddrEqual( saveExtAddr, IEEEAddress ) == FALSE )
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \   0000001C   0x.... 0x....      BL       sAddrExtCmp
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD107             BNE.N    ??ZDP_NwkAddrReq_0
    328            {
    329              dstAddr.addrMode = AddrBroadcast;
   \   00000024   0x200F             MOVS     R0,#+15
   \   00000026   0xF88D 0x0008      STRB     R0,[SP, #+8]
    330              dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   0000002A   0xF64F 0x70FD      MOVW     R0,#+65533
   \   0000002E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000032   0xE007             B.N      ??ZDP_NwkAddrReq_1
    331            }
    332            else
    333            {
    334              dstAddr.addrMode = Addr16Bit;
   \                     ??ZDP_NwkAddrReq_0: (+1)
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF88D 0x0008      STRB     R0,[SP, #+8]
    335              dstAddr.addr.shortAddr = ZDAppNwkAddr.addr.shortAddr;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   0000003E   0x8800             LDRH     R0,[R0, #+0]
   \   00000040   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    336            }
    337          
    338            pBuf = osal_cpyExtAddr( pBuf, IEEEAddress );
   \                     ??ZDP_NwkAddrReq_1: (+1)
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0x.... 0x....      BL       sAddrExtCpy
   \   0000004C   0x0007             MOVS     R7,R0
    339          
    340            *pBuf++ = ReqType;
   \   0000004E   0x703D             STRB     R5,[R7, #+0]
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
    341            *pBuf++ = StartIndex;
   \   00000052   0x703E             STRB     R6,[R7, #+0]
   \   00000054   0x1C7F             ADDS     R7,R7,#+1
    342          
    343            return fillAndSend( &ZDP_TransID, &dstAddr, NWK_addr_req, len );
   \   00000056   0x4643             MOV      R3,R8
   \   00000058   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000062   0x.... 0x....      BL       fillAndSend
   \   00000066   0xB004             ADD      SP,SP,#+16
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    344          }
    345          
    346          /*********************************************************************
    347           * @fn          ZDP_IEEEAddrReq
    348           *
    349           * @brief       This builds and send a IEEE_addr_req message.  This
    350           *              function sends a unicast message looking for a 64
    351           *              bit IEEE address with a 16 bit address as bait.
    352           *
    353           * @param       ReqType - ZDP_IEEEADDR_REQTYPE_SINGLE or
    354           *                        ZDP_IEEEADDR_REQTYPE_EXTENDED
    355           * @param       SecurityEnable - Security Options
    356           *
    357           * @return      afStatus_t
    358           */

   \                                 In section .text, align 2, keep-with-next
    359          afStatus_t ZDP_IEEEAddrReq( uint16 shortAddr, byte ReqType,
    360                                      byte StartIndex, byte SecurityEnable )
    361          {
   \                     ZDP_IEEEAddrReq: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    362            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   00000006   0x681C             LDR      R4,[R3, #+0]
    363            byte len = 2 + 1 + 1;  // shortAddr + ReqType + StartIndex.
   \   00000008   0x2304             MOVS     R3,#+4
    364            zAddrType_t dstAddr;
    365          
    366            (void)SecurityEnable;  // Intentionally unreferenced parameter
    367          
    368            dstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   0000000A   0x2502             MOVS     R5,#+2
   \   0000000C   0xF88D 0x5008      STRB     R5,[SP, #+8]
    369            dstAddr.addr.shortAddr = shortAddr;
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    370          
    371            *pBuf++ = LO_UINT16( shortAddr );
   \   00000014   0x7020             STRB     R0,[R4, #+0]
   \   00000016   0x1C64             ADDS     R4,R4,#+1
    372            *pBuf++ = HI_UINT16( shortAddr );
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x0A00             LSRS     R0,R0,#+8
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
    373          
    374            *pBuf++ = ReqType;
   \   00000020   0x7021             STRB     R1,[R4, #+0]
   \   00000022   0x1C64             ADDS     R4,R4,#+1
    375            *pBuf++ = StartIndex;
   \   00000024   0x7022             STRB     R2,[R4, #+0]
   \   00000026   0x1C64             ADDS     R4,R4,#+1
    376          
    377            return fillAndSend( &ZDP_TransID, &dstAddr, IEEE_addr_req, len );
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000032   0x.... 0x....      BL       fillAndSend
   \   00000036   0xBD3E             POP      {R1-R5,PC}       ;; return
    378          }
    379          
    380          /*********************************************************************
    381           * @fn          ZDP_MatchDescReq
    382           *
    383           * @brief       This builds and send a Match_Desc_req message.  This
    384           *              function sends a broadcast or unicast message
    385           *              requesting the list of endpoint/interfaces that
    386           *              match profile ID and cluster IDs.
    387           *
    388           * @param       dstAddr - destination address
    389           * @param       nwkAddr - network address of interest
    390           * @param       ProfileID - Profile ID
    391           * @param       NumInClusters - number of input clusters
    392           * @param       InClusterList - input cluster ID list
    393           * @param       NumOutClusters - number of output clusters
    394           * @param       OutClusterList - output cluster ID list
    395           * @param       SecurityEnable - Security Options
    396           *
    397           * @return      afStatus_t
    398           */

   \                                 In section .text, align 2, keep-with-next
    399          afStatus_t ZDP_MatchDescReq( zAddrType_t *dstAddr, uint16 nwkAddr,
    400                                          uint16 ProfileID,
    401                                          byte NumInClusters, cId_t *InClusterList,
    402                                          byte NumOutClusters, cId_t *OutClusterList,
    403                                          byte SecurityEnable )
    404          {
   \                     ZDP_MatchDescReq: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    405            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   00000006   0x6826             LDR      R6,[R4, #+0]
    406            // nwkAddr+ProfileID+NumInClusters+NumOutClusters.
    407            byte i, len = 2 + 2 + 1 + 1;  // nwkAddr+ProfileID+NumInClusters+NumOutClusters.
   \   00000008   0x2506             MOVS     R5,#+6
   \   0000000A   0x9C07             LDR      R4,[SP, #+28]
    408          
    409            (void)SecurityEnable;  // Intentionally unreferenced parameter
    410          
    411            len += (NumInClusters + NumOutClusters) * sizeof(uint16);
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x18E7             ADDS     R7,R4,R3
   \   00000014   0xEB15 0x0547      ADDS     R5,R5,R7, LSL #+1
    412          
    413            if ( len >= ZDP_BUF_SZ-1 )
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D4F             CMP      R5,#+79
   \   0000001C   0xDB01             BLT.N    ??ZDP_MatchDescReq_0
    414            {
    415              return afStatus_MEM_FAIL;
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0xE05A             B.N      ??ZDP_MatchDescReq_1
    416            }
    417          
    418            // The spec changed in Zigbee 2007 (2.4.3.1.7.1) to not allow sending
    419            // this command to 0xFFFF.  So, here we will filter this and replace
    420            // with 0xFFFD to only send to devices with RX ON.  This includes the
    421            // network address of interest.
    422            if ( ((dstAddr->addrMode == AddrBroadcast) || (dstAddr->addrMode == Addr16Bit))
    423                && (dstAddr->addr.shortAddr == NWK_BROADCAST_SHORTADDR_DEVALL) )
   \                     ??ZDP_MatchDescReq_0: (+1)
   \   00000022   0x7A07             LDRB     R7,[R0, #+8]
   \   00000024   0x2F0F             CMP      R7,#+15
   \   00000026   0xD002             BEQ.N    ??ZDP_MatchDescReq_2
   \   00000028   0x7A07             LDRB     R7,[R0, #+8]
   \   0000002A   0x2F02             CMP      R7,#+2
   \   0000002C   0xD107             BNE.N    ??ZDP_MatchDescReq_3
   \                     ??ZDP_MatchDescReq_2: (+1)
   \   0000002E   0x8807             LDRH     R7,[R0, #+0]
   \   00000030   0xF64F 0x7CFF      MOVW     R12,#+65535
   \   00000034   0x4567             CMP      R7,R12
   \   00000036   0xD102             BNE.N    ??ZDP_MatchDescReq_3
    424            {
    425              dstAddr->addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   00000038   0xF64F 0x77FD      MOVW     R7,#+65533
   \   0000003C   0x8007             STRH     R7,[R0, #+0]
    426            }
    427            if ( nwkAddr == NWK_BROADCAST_SHORTADDR_DEVALL )
   \                     ??ZDP_MatchDescReq_3: (+1)
   \   0000003E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000040   0xF64F 0x77FF      MOVW     R7,#+65535
   \   00000044   0x42B9             CMP      R1,R7
   \   00000046   0xD101             BNE.N    ??ZDP_MatchDescReq_4
    428            {
    429              nwkAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   00000048   0xF64F 0x71FD      MOVW     R1,#+65533
    430            }
    431          
    432            *pBuf++ = LO_UINT16( nwkAddr );   // NWKAddrOfInterest
   \                     ??ZDP_MatchDescReq_4: (+1)
   \   0000004C   0x7031             STRB     R1,[R6, #+0]
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
    433            *pBuf++ = HI_UINT16( nwkAddr );
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x0A09             LSRS     R1,R1,#+8
   \   00000054   0x7031             STRB     R1,[R6, #+0]
   \   00000056   0x1C76             ADDS     R6,R6,#+1
    434          
    435            *pBuf++ = LO_UINT16( ProfileID );   // Profile ID
   \   00000058   0x7032             STRB     R2,[R6, #+0]
   \   0000005A   0x1C76             ADDS     R6,R6,#+1
    436            *pBuf++ = HI_UINT16( ProfileID );
   \   0000005C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005E   0x0A11             LSRS     R1,R2,#+8
   \   00000060   0x7031             STRB     R1,[R6, #+0]
   \   00000062   0x1C76             ADDS     R6,R6,#+1
    437          
    438            *pBuf++ = NumInClusters; // Input cluster list
   \   00000064   0x7033             STRB     R3,[R6, #+0]
   \   00000066   0x1C76             ADDS     R6,R6,#+1
    439            if ( NumInClusters )
   \   00000068   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000006A   0x2B00             CMP      R3,#+0
   \   0000006C   0xD013             BEQ.N    ??ZDP_MatchDescReq_5
    440            {
    441              for (i=0; i<NumInClusters; ++i)  {
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x9906             LDR      R1,[SP, #+24]
   \   00000072   0xE00C             B.N      ??ZDP_MatchDescReq_6
    442                *pBuf++ = LO_UINT16( InClusterList[i] );
   \                     ??ZDP_MatchDescReq_7: (+1)
   \   00000074   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000076   0xF831 0x7012      LDRH     R7,[R1, R2, LSL #+1]
   \   0000007A   0x7037             STRB     R7,[R6, #+0]
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
    443                *pBuf++ = HI_UINT16( InClusterList[i] );
   \   0000007E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000080   0xF831 0x7012      LDRH     R7,[R1, R2, LSL #+1]
   \   00000084   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000086   0x0A3F             LSRS     R7,R7,#+8
   \   00000088   0x7037             STRB     R7,[R6, #+0]
   \   0000008A   0x1C76             ADDS     R6,R6,#+1
    444              }
   \   0000008C   0x1C52             ADDS     R2,R2,#+1
   \                     ??ZDP_MatchDescReq_6: (+1)
   \   0000008E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000090   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000092   0x429A             CMP      R2,R3
   \   00000094   0xD3EE             BCC.N    ??ZDP_MatchDescReq_7
    445            }
    446          
    447            *pBuf++ = NumOutClusters; // Output cluster list
   \                     ??ZDP_MatchDescReq_5: (+1)
   \   00000096   0x7034             STRB     R4,[R6, #+0]
   \   00000098   0x1C76             ADDS     R6,R6,#+1
    448            if ( NumOutClusters )
   \   0000009A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009C   0x2C00             CMP      R4,#+0
   \   0000009E   0xD013             BEQ.N    ??ZDP_MatchDescReq_8
    449            {
    450              for (i=0; i<NumOutClusters; ++i)  {
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x9908             LDR      R1,[SP, #+32]
   \   000000A4   0xE00C             B.N      ??ZDP_MatchDescReq_9
    451                *pBuf++ = LO_UINT16( OutClusterList[i] );
   \                     ??ZDP_MatchDescReq_10: (+1)
   \   000000A6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A8   0xF831 0x3012      LDRH     R3,[R1, R2, LSL #+1]
   \   000000AC   0x7033             STRB     R3,[R6, #+0]
   \   000000AE   0x1C76             ADDS     R6,R6,#+1
    452                *pBuf++ = HI_UINT16( OutClusterList[i] );
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0xF831 0x3012      LDRH     R3,[R1, R2, LSL #+1]
   \   000000B6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000B8   0x0A1B             LSRS     R3,R3,#+8
   \   000000BA   0x7033             STRB     R3,[R6, #+0]
   \   000000BC   0x1C76             ADDS     R6,R6,#+1
    453              }
   \   000000BE   0x1C52             ADDS     R2,R2,#+1
   \                     ??ZDP_MatchDescReq_9: (+1)
   \   000000C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0x42A2             CMP      R2,R4
   \   000000C6   0xD3EE             BCC.N    ??ZDP_MatchDescReq_10
    454            }
    455          
    456            return fillAndSend( &ZDP_TransID, dstAddr, Match_Desc_req, len );
   \                     ??ZDP_MatchDescReq_8: (+1)
   \   000000C8   0x002B             MOVS     R3,R5
   \   000000CA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000CC   0x2206             MOVS     R2,#+6
   \   000000CE   0x0001             MOVS     R1,R0
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   000000D4   0x.... 0x....      BL       fillAndSend
   \                     ??ZDP_MatchDescReq_1: (+1)
   \   000000D8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    457          }
    458          
    459          /*********************************************************************
    460           * @fn          ZDP_SimpleDescReq
    461           *
    462           * @brief       This builds and send a NWK_Simple_Desc_req
    463           *              message.  This function sends unicast message to the
    464           *              destination device.
    465           *
    466           * @param       dstAddr - destination address
    467           * @param       nwkAddr - 16 bit address
    468           * @param       epIntf - endpoint/interface
    469           * @param       SecurityEnable - Security Options
    470           *
    471           * @return      afStatus_t
    472           */

   \                                 In section .text, align 2, keep-with-next
    473          afStatus_t ZDP_SimpleDescReq( zAddrType_t *dstAddr, uint16 nwkAddr,
    474                                              byte endPoint, byte SecurityEnable )
    475          
    476          {
   \                     ZDP_SimpleDescReq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    477            (void)SecurityEnable;  // Intentionally unreferenced parameter
    478          
    479            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x7019             STRB     R1,[R3, #+0]
    480            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x0A09             LSRS     R1,R1,#+8
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   00000012   0x681B             LDR      R3,[R3, #+0]
   \   00000014   0x7059             STRB     R1,[R3, #+1]
    481            ZDP_TmpBuf[2] = endPoint;
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x708A             STRB     R2,[R1, #+2]
    482          
    483            return fillAndSend( &ZDP_TransID, dstAddr, Simple_Desc_req, 3 );
   \   0000001E   0x2303             MOVS     R3,#+3
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000028   0x.... 0x....      BL       fillAndSend
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
    484          }
    485          
    486          /*********************************************************************
    487           * @fn          ZDP_UserDescSet
    488           *
    489           * @brief       This builds and send a User_Desc_set message to set
    490           *              the user descriptor.  This function sends unicast
    491           *              message to the destination device.
    492           *
    493           * @param       dstAddr - destination address
    494           * @param       nwkAddr - 16 bit address
    495           * @param       UserDescriptor - user descriptor
    496           * @param       SecurityEnable - Security Options
    497           *
    498           * @return      afStatus_t
    499           */

   \                                 In section .text, align 2, keep-with-next
    500          afStatus_t ZDP_UserDescSet( zAddrType_t *dstAddr, uint16 nwkAddr,
    501                                    UserDescriptorFormat_t *UserDescriptor,
    502                                    byte SecurityEnable )
    503          {
   \                     ZDP_UserDescSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0013             MOVS     R3,R2
    504            uint8 *pBuf = ZDP_TmpBuf;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
    505            byte len = (UserDescriptor->len < AF_MAX_USER_DESCRIPTOR_LEN) ?
    506                        UserDescriptor->len : AF_MAX_USER_DESCRIPTOR_LEN;
   \   0000000C   0x781A             LDRB     R2,[R3, #+0]
   \   0000000E   0x2A10             CMP      R2,#+16
   \   00000010   0xDA01             BGE.N    ??ZDP_UserDescSet_0
   \   00000012   0x781D             LDRB     R5,[R3, #+0]
   \   00000014   0xE000             B.N      ??ZDP_UserDescSet_1
   \                     ??ZDP_UserDescSet_0: (+1)
   \   00000016   0x2510             MOVS     R5,#+16
    507            byte addrLen = 2;
   \                     ??ZDP_UserDescSet_1: (+1)
   \   00000018   0x2602             MOVS     R6,#+2
    508          
    509            (void)SecurityEnable;  // Intentionally unreferenced parameter
    510          
    511            *pBuf++ = LO_UINT16( nwkAddr );
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    512            *pBuf++ = HI_UINT16( nwkAddr );
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x0A09             LSRS     R1,R1,#+8
   \   00000022   0x7001             STRB     R1,[R0, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
    513          
    514            *pBuf++ = len;
   \   00000026   0x7005             STRB     R5,[R0, #+0]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
    515            addrLen = 3;
   \   0000002A   0x2603             MOVS     R6,#+3
    516          
    517            pBuf = osal_memcpy( pBuf, UserDescriptor->desc, len );
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x002A             MOVS     R2,R5
   \   00000030   0x1C59             ADDS     R1,R3,#+1
   \   00000032   0x.... 0x....      BL       osal_memcpy
    518            osal_memset( pBuf, AF_USER_DESCRIPTOR_FILL, AF_MAX_USER_DESCRIPTOR_LEN-len );
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0xF1D5 0x0210      RSBS     R2,R5,#+16
   \   0000003C   0x2120             MOVS     R1,#+32
   \   0000003E   0x.... 0x....      BL       osal_memset
    519          
    520            return fillAndSend( &ZDP_TransID, dstAddr, User_Desc_set, (AF_MAX_USER_DESCRIPTOR_LEN + addrLen) );
   \   00000042   0xF116 0x0310      ADDS     R3,R6,#+16
   \   00000046   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000048   0x2214             MOVS     R2,#+20
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000050   0x.... 0x....      BL       fillAndSend
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    521          }
    522          
    523          /*********************************************************************
    524           * @fn          ZDP_ServerDiscReq
    525           *
    526           * @brief       Build and send a Server_Discovery_req request message.
    527           *
    528           * @param       serverMask - 16-bit bit-mask of server services being sought.
    529           * @param       SecurityEnable - Security Options
    530           *
    531           * @return      afStatus_t
    532           */

   \                                 In section .text, align 2, keep-with-next
    533          afStatus_t ZDP_ServerDiscReq( uint16 serverMask, byte SecurityEnable )
    534          {
   \                     ZDP_ServerDiscReq: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    535            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable27_1
   \   00000006   0x6812             LDR      R2,[R2, #+0]
    536            zAddrType_t dstAddr;
    537          
    538            dstAddr.addrMode = AddrBroadcast;
   \   00000008   0x230F             MOVS     R3,#+15
   \   0000000A   0xF88D 0x3008      STRB     R3,[SP, #+8]
    539            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   0000000E   0xF64F 0x73FD      MOVW     R3,#+65533
   \   00000012   0xF8AD 0x3000      STRH     R3,[SP, #+0]
    540          
    541            *pBuf++ = LO_UINT16( serverMask );
   \   00000016   0x7010             STRB     R0,[R2, #+0]
   \   00000018   0x1C52             ADDS     R2,R2,#+1
    542            *pBuf = HI_UINT16( serverMask );
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0x0A00             LSRS     R0,R0,#+8
   \   0000001E   0x7010             STRB     R0,[R2, #+0]
    543          
    544            FillAndSendTxOptions( &ZDP_TransID, &dstAddr, Server_Discovery_req, 2,
    545                       ((SecurityEnable) ? AF_EN_SECURITY : AF_TX_OPTIONS_NONE) );
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD004             BEQ.N    ??ZDP_ServerDiscReq_0
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   \   0000002E   0xE003             B.N      ??ZDP_ServerDiscReq_1
   \                     ??ZDP_ServerDiscReq_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   \                     ??ZDP_ServerDiscReq_1: (+1)
   \   00000038   0x2302             MOVS     R3,#+2
   \   0000003A   0x2215             MOVS     R2,#+21
   \   0000003C   0xA900             ADD      R1,SP,#+0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000042   0x.... 0x....      BL       fillAndSend
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   0000004C   0x7011             STRB     R1,[R2, #+0]
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xBD0E             POP      {R1-R3,PC}       ;; return
    546          }
    547          
    548          /*********************************************************************
    549           * @fn          ZDP_DeviceAnnce
    550           *
    551           * @brief       This builds and send a Device_Annce message.  This
    552           *              function sends a broadcast message.
    553           *
    554           * @param       nwkAddr - 16 bit address of the device
    555           * @param       IEEEAddr - 64 bit address of the device
    556           * @param       capabilities - device capabilities.  This field is only
    557           *                 sent for v1.1 networks.
    558           * @param       SecurityEnable - Security Options
    559           *
    560           * @return      afStatus_t
    561           */

   \                                 In section .text, align 2, keep-with-next
    562          afStatus_t ZDP_DeviceAnnce( uint16 nwkAddr, uint8 *IEEEAddr,
    563                                        byte capabilities, byte SecurityEnable )
    564          {
   \                     ZDP_DeviceAnnce: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0014             MOVS     R4,R2
    565            zAddrType_t dstAddr;
    566            uint8 len;
    567          
    568            (void)SecurityEnable;  // Intentionally unreferenced parameter
    569          
    570            dstAddr.addrMode = (afAddrMode_t)AddrBroadcast;
   \   00000006   0x220F             MOVS     R2,#+15
   \   00000008   0xF88D 0x2008      STRB     R2,[SP, #+8]
    571            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   0000000C   0xF64F 0x72FD      MOVW     R2,#+65533
   \   00000010   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    572          
    573            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable27_1
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x7010             STRB     R0,[R2, #+0]
    574            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x0A00             LSRS     R0,R0,#+8
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable27_1
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x7050             STRB     R0,[R2, #+1]
    575            osal_cpyExtAddr( &ZDP_TmpBuf[2], IEEEAddr );
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1C80             ADDS     R0,R0,#+2
   \   00000030   0x.... 0x....      BL       sAddrExtCpy
    576            len = 2 + Z_EXTADDR_LEN;
   \   00000034   0x230A             MOVS     R3,#+10
    577          
    578            ZDP_TmpBuf[10] = capabilities;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x7284             STRB     R4,[R0, #+10]
    579            len++;
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
    580          
    581            return fillAndSend( &ZDP_TransID, &dstAddr, Device_annce, len );
   \   00000040   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000042   0x2213             MOVS     R2,#+19
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000004A   0x.... 0x....      BL       fillAndSend
   \   0000004E   0xB004             ADD      SP,SP,#+16
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    582          }
    583          
    584          #if defined ( ZIGBEE_CHILD_AGING )
    585          /*********************************************************************
    586           * @fn          ZDP_EndDeviceTimeoutReq
    587           *
    588           * @brief       This builds and send an End_Device_Timeout_req message.
    589           *
    590           * @param       parentAddr - destination address
    591           * @param       reqTimeout - Timeout value the device is requesting
    592           * @param       SecurityEnable - Security Options
    593           *
    594           * @return      afStatus_t
    595           */

   \                                 In section .text, align 2, keep-with-next
    596          afStatus_t ZDP_EndDeviceTimeoutReq( uint16 parentAddr, uint16 reqTimeout,
    597                                              uint8 SecurityEnable )
    598          {
   \                     ZDP_EndDeviceTimeoutReq: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x000C             MOVS     R4,R1
    599            uint8 *pBuf = ZDP_TmpBuf;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   00000008   0x680A             LDR      R2,[R1, #+0]
    600            uint8 len = Z_EXTADDR_LEN + 2;  // Device_IEEEAddress + reqTimeout.
   \   0000000A   0x250A             MOVS     R5,#+10
    601            zAddrType_t dstAddr;
    602          
    603            (void)SecurityEnable;  // Intentionally unreferenced parameter
    604          
    605            dstAddr.addrMode = Addr16Bit;
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0xF88D 0x1008      STRB     R1,[SP, #+8]
    606            dstAddr.addr.shortAddr = parentAddr;
   \   00000012   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    607          
    608            pBuf = osal_cpyExtAddr( pBuf, saveExtAddr );
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   0000001A   0x0010             MOVS     R0,R2
   \   0000001C   0x.... 0x....      BL       sAddrExtCpy
   \   00000020   0x0002             MOVS     R2,R0
    609          
    610            *pBuf++ = LO_UINT16( reqTimeout );
   \   00000022   0x7014             STRB     R4,[R2, #+0]
   \   00000024   0x1C52             ADDS     R2,R2,#+1
    611            *pBuf++ = HI_UINT16( reqTimeout );
   \   00000026   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000028   0x0A20             LSRS     R0,R4,#+8
   \   0000002A   0x7010             STRB     R0,[R2, #+0]
   \   0000002C   0x1C52             ADDS     R2,R2,#+1
    612          
    613            return fillAndSend( &ZDP_TransID, &dstAddr, End_Device_Timeout_req, len );
   \   0000002E   0x002B             MOVS     R3,R5
   \   00000030   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000032   0x221F             MOVS     R2,#+31
   \   00000034   0xA900             ADD      R1,SP,#+0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000003A   0x.... 0x....      BL       fillAndSend
   \   0000003E   0xBD3E             POP      {R1-R5,PC}       ;; return
    614          }
    615          #endif // ZIGBEE_CHILD_AGING
    616          
    617          /*********************************************************************
    618           * Address Responses
    619           */
    620          
    621          /*********************************************************************
    622           * @fn      zdpProcessAddrReq
    623           *
    624           * @brief   Process an incoming NWK_addr_req or IEEE_addr_req message and then
    625           *          build and send a corresponding NWK_addr_rsp or IEEE_addr_rsp msg.
    626           *
    627           * @param   inMsg - incoming message
    628           *
    629           * @return  none
    630           */

   \                                 In section .text, align 2, keep-with-next
    631          void zdpProcessAddrReq( zdoIncomingMsg_t *inMsg )
    632          {
   \                     zdpProcessAddrReq: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    633            associated_devices_t *pAssoc;
    634            uint8 reqType;
    635            uint16 aoi = INVALID_NODE_ADDR;
   \   00000006   0xF64F 0x75FE      MOVW     R5,#+65534
    636            uint8 *ieee = NULL;
   \   0000000A   0x2600             MOVS     R6,#+0
    637          
    638            reqType = inMsg->asdu[(inMsg->clusterID == NWK_addr_req) ? Z_EXTADDR_LEN : sizeof( uint16 ) ];
   \   0000000C   0x89E0             LDRH     R0,[R4, #+14]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??zdpProcessAddrReq_0
   \   00000012   0x2008             MOVS     R0,#+8
   \   00000014   0xE000             B.N      ??zdpProcessAddrReq_1
   \                     ??zdpProcessAddrReq_0: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \                     ??zdpProcessAddrReq_1: (+1)
   \   00000018   0x69A1             LDR      R1,[R4, #+24]
   \   0000001A   0x5C47             LDRB     R7,[R0, R1]
    639          
    640            if ( inMsg->clusterID == NWK_addr_req )
   \   0000001C   0x89E0             LDRH     R0,[R4, #+14]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10C             BNE.N    ??zdpProcessAddrReq_2
    641          
    642            {
    643              ieee = inMsg->asdu;
   \   00000022   0x69A6             LDR      R6,[R4, #+24]
    644          
    645              if ( osal_ExtAddrEqual( saveExtAddr, ieee ) )
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \   0000002A   0x.... 0x....      BL       sAddrExtCmp
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??zdpProcessAddrReq_3
    646              {
    647                aoi = ZDAppNwkAddr.addr.shortAddr;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000036   0x8805             LDRH     R5,[R0, #+0]
   \   00000038   0xE00F             B.N      ??zdpProcessAddrReq_4
    648              }
    649              // Handle response for sleeping end devices
    650              else if ( (ZSTACK_ROUTER_BUILD)
    651                && (((pAssoc = AssocGetWithExt( ieee )) != NULL)
    652                       && (pAssoc->nodeRelation == CHILD_RFD)) )
   \                     ??zdpProcessAddrReq_3: (+1)
   \   0000003A   0xE00E             B.N      ??zdpProcessAddrReq_4
    653              {
    654                aoi = pAssoc->shortAddr;
    655                if ( reqType != ZDP_ADDR_REQTYPE_SINGLE )
    656                  reqType = 0xFF; // Force Invalid
    657              }
    658            }
    659            else  // if ( inMsg->clusterID == IEEE_addr_req )
    660            {
    661              aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \                     ??zdpProcessAddrReq_2: (+1)
   \   0000003C   0x69A0             LDR      R0,[R4, #+24]
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x69A1             LDR      R1,[R4, #+24]
   \   00000042   0x7849             LDRB     R1,[R1, #+1]
   \   00000044   0xEB10 0x2501      ADDS     R5,R0,R1, LSL #+8
    662          
    663              if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD102             BNE.N    ??zdpProcessAddrReq_5
    664              {
    665                ieee = saveExtAddr;
   \   00000054   0x.... 0x....      LDR.W    R6,??DataTable28_2
   \   00000058   0xE7FF             B.N      ??zdpProcessAddrReq_4
    666              }
    667              else if ( (ZSTACK_ROUTER_BUILD)
    668                && (((pAssoc = AssocGetWithShort( aoi )) != NULL)
    669                       && (pAssoc->nodeRelation == CHILD_RFD)) )
    670              {
    671                AddrMgrEntry_t addrEntry;
    672                addrEntry.user = ADDRMGR_USER_DEFAULT;
    673                addrEntry.index = pAssoc->addrIdx;
    674                if ( AddrMgrEntryGet( &addrEntry ) )
    675                {
    676                  ieee = addrEntry.extAddr;
    677                }
    678          
    679                if ( reqType != ZDP_ADDR_REQTYPE_SINGLE )
    680                  reqType = 0xFF; // Force Invalid
    681              }
    682            }
    683          
    684            if ( ((aoi != INVALID_NODE_ADDR) && (ieee != NULL)) || (inMsg->wasBroadcast == FALSE) )
   \                     ??zdpProcessAddrReq_5: (+1)
   \                     ??zdpProcessAddrReq_4: (+1)
   \   0000005A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005C   0xF64F 0x70FE      MOVW     R0,#+65534
   \   00000060   0x4285             CMP      R5,R0
   \   00000062   0xD001             BEQ.N    ??zdpProcessAddrReq_6
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD102             BNE.N    ??zdpProcessAddrReq_7
   \                     ??zdpProcessAddrReq_6: (+1)
   \   00000068   0x7B20             LDRB     R0,[R4, #+12]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD13D             BNE.N    ??zdpProcessAddrReq_8
    685            {
    686              uint8 stat;
    687              uint8 *pBuf = ZDP_TmpBuf;
   \                     ??zdpProcessAddrReq_7: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000072   0x6800             LDR      R0,[R0, #+0]
    688              // Status + IEEE-Addr + Nwk-Addr.
    689              uint8 len = 1 + Z_EXTADDR_LEN + 2;
   \   00000074   0xF05F 0x080B      MOVS     R8,#+11
    690          
    691              // If aoi and iee are both setup, we found results
    692              if ( (aoi != INVALID_NODE_ADDR) && (ieee != NULL) )
   \   00000078   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007A   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000007E   0x428D             CMP      R5,R1
   \   00000080   0xD00B             BEQ.N    ??zdpProcessAddrReq_9
   \   00000082   0x2E00             CMP      R6,#+0
   \   00000084   0xD009             BEQ.N    ??zdpProcessAddrReq_9
    693              {
    694                stat = ((reqType == ZDP_ADDR_REQTYPE_SINGLE) || (reqType == ZDP_ADDR_REQTYPE_EXTENDED))
    695                              ? ZDP_SUCCESS : ZDP_INVALID_REQTYPE;
   \   00000086   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD002             BEQ.N    ??zdpProcessAddrReq_10
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x2F01             CMP      R7,#+1
   \   00000090   0xD101             BNE.N    ??zdpProcessAddrReq_11
   \                     ??zdpProcessAddrReq_10: (+1)
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0xE00B             B.N      ??zdpProcessAddrReq_12
   \                     ??zdpProcessAddrReq_11: (+1)
   \   00000096   0x2180             MOVS     R1,#+128
   \   00000098   0xE009             B.N      ??zdpProcessAddrReq_12
    696              }
    697              else
    698              {
    699                // not found and the req was unicast to this device
    700                stat = ZDP_DEVICE_NOT_FOUND;
   \                     ??zdpProcessAddrReq_9: (+1)
   \   0000009A   0x2181             MOVS     R1,#+129
    701          
    702                // Fill in the missing field with this device's address
    703                if ( inMsg->clusterID == NWK_addr_req )
   \   0000009C   0x89E2             LDRH     R2,[R4, #+14]
   \   0000009E   0x2A00             CMP      R2,#+0
   \   000000A0   0xD103             BNE.N    ??zdpProcessAddrReq_13
    704                {
    705                  aoi = ZDAppNwkAddr.addr.shortAddr;
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable28_3
   \   000000A6   0x8815             LDRH     R5,[R2, #+0]
   \   000000A8   0xE001             B.N      ??zdpProcessAddrReq_12
    706                }
    707                else
    708                {
    709                  ieee = saveExtAddr;
   \                     ??zdpProcessAddrReq_13: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R6,??DataTable28_2
    710                }
    711              }
    712          
    713              *pBuf++ = stat;
   \                     ??zdpProcessAddrReq_12: (+1)
   \   000000AE   0x7001             STRB     R1,[R0, #+0]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
    714          
    715              pBuf = osal_cpyExtAddr( pBuf, ieee );
   \   000000B2   0x0031             MOVS     R1,R6
   \   000000B4   0x.... 0x....      BL       sAddrExtCpy
    716          
    717              *pBuf++ = LO_UINT16( aoi );
   \   000000B8   0x7005             STRB     R5,[R0, #+0]
   \   000000BA   0x1C40             ADDS     R0,R0,#+1
    718              *pBuf++ = HI_UINT16( aoi );
   \   000000BC   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BE   0x0A29             LSRS     R1,R5,#+8
   \   000000C0   0x7001             STRB     R1,[R0, #+0]
   \   000000C2   0x1C40             ADDS     R0,R0,#+1
    719          
    720              if ( ZSTACK_ROUTER_BUILD )
    721              {
    722                if ( (reqType == ZDP_ADDR_REQTYPE_EXTENDED) && (aoi == ZDAppNwkAddr.addr.shortAddr)
    723                     && (stat == ZDP_SUCCESS) )
    724                {
    725                  uint8  cnt = 0;
    726                  uint16 *list = AssocMakeList( &cnt );
    727          
    728                  if ( list != NULL )
    729                  {
    730                    byte idx = inMsg->asdu[(((inMsg->clusterID == NWK_addr_req) ? Z_EXTADDR_LEN : sizeof( uint16 )) + 1)];
    731                    uint16 *pList = list + idx;
    732          
    733                    // NumAssocDev field is only present on success.
    734                    if ( cnt > idx )
    735                    {
    736                      cnt -= idx;
    737                      len += (cnt * sizeof( uint16 ));
    738                    }
    739                    else
    740                    {
    741                      cnt = 0;
    742                    }
    743                    *pBuf++ = cnt;
    744                    len++;
    745          
    746                    // StartIndex field is only present if NumAssocDev field is non-zero.
    747                    *pBuf++ = idx;
    748                    len++;
    749          
    750                    while ( cnt != 0 )
    751                    {
    752                      *pBuf++ = LO_UINT16( *pList );
    753                      *pBuf++ = HI_UINT16( *pList );
    754                      pList++;
    755                      cnt--;
    756                    }
    757          
    758                    osal_mem_free( (uint8 *)list );
    759                  }
    760                  else
    761                  {
    762                    // NumAssocDev field is only present on success.
    763                    *pBuf++ = 0;
    764                    len++;
    765                  }
    766                }
    767              }
    768          
    769              ZDP_TxOptions = AF_MSG_ACK_REQUEST;
   \   000000C4   0x2010             MOVS     R0,#+16
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   000000CA   0x7008             STRB     R0,[R1, #+0]
    770              fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), (cId_t)(inMsg->clusterID | ZDO_RESPONSE_BIT), len );
   \   000000CC   0x4643             MOV      R3,R8
   \   000000CE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D0   0x89E0             LDRH     R0,[R4, #+14]
   \   000000D2   0xF450 0x4200      ORRS     R2,R0,#0x8000
   \   000000D6   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000D8   0x1CA1             ADDS     R1,R4,#+2
   \   000000DA   0xF114 0x0011      ADDS     R0,R4,#+17
   \   000000DE   0x.... 0x....      BL       fillAndSend
    771              ZDP_TxOptions = AF_TX_OPTIONS_NONE;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
    772            }
    773          }
   \                     ??zdpProcessAddrReq_8: (+1)
   \   000000EA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    774          
    775          /*********************************************************************
    776           * @fn          ZDP_NodeDescMsg
    777           *
    778           * @brief       Builds and sends a Node Descriptor message, unicast to the
    779           *              specified device.
    780           *
    781           * @param       inMsg - incoming message
    782           * @param       nwkAddr - 16 bit network address for device
    783           * @param       pNodeDesc - pointer to the node descriptor
    784           *
    785           * @return      afStatus_t
    786           */

   \                                 In section .text, align 2, keep-with-next
    787          afStatus_t ZDP_NodeDescMsg( zdoIncomingMsg_t *inMsg,
    788                                     uint16 nwkAddr, NodeDescriptorFormat_t *pNodeDesc )
    789          {
   \                     ZDP_NodeDescMsg: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    790            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable34
   \   00000006   0x681C             LDR      R4,[R3, #+0]
    791            byte len;
    792          
    793            len = 1 + 2 + 13;  // Status + nwkAddr + Node descriptor
   \   00000008   0x2310             MOVS     R3,#+16
    794          
    795            *pBuf++ = ZDP_SUCCESS;
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x7025             STRB     R5,[R4, #+0]
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
    796          
    797            *pBuf++ = LO_UINT16( nwkAddr );
   \   00000010   0x7021             STRB     R1,[R4, #+0]
   \   00000012   0x1C64             ADDS     R4,R4,#+1
    798            *pBuf++ = HI_UINT16( nwkAddr );
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x0A09             LSRS     R1,R1,#+8
   \   00000018   0x7021             STRB     R1,[R4, #+0]
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
    799          
    800            *pBuf++ = (byte)((pNodeDesc->ComplexDescAvail << 3) |
    801                               (pNodeDesc->UserDescAvail << 4) |
    802                               (pNodeDesc->LogicalType & 0x07));
   \   0000001C   0x7811             LDRB     R1,[R2, #+0]
   \   0000001E   0xF3C1 0x01C0      UBFX     R1,R1,#+3,#+1
   \   00000022   0x7815             LDRB     R5,[R2, #+0]
   \   00000024   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \   00000028   0x012D             LSLS     R5,R5,#+4
   \   0000002A   0xEA55 0x01C1      ORRS     R1,R5,R1, LSL #+3
   \   0000002E   0x7815             LDRB     R5,[R2, #+0]
   \   00000030   0xF015 0x0507      ANDS     R5,R5,#0x7
   \   00000034   0x4329             ORRS     R1,R5,R1
   \   00000036   0x7021             STRB     R1,[R4, #+0]
   \   00000038   0x1C64             ADDS     R4,R4,#+1
    803          
    804            *pBuf++ = (byte)((pNodeDesc->FrequencyBand << 3) | (pNodeDesc->APSFlags & 0x07));
   \   0000003A   0x7851             LDRB     R1,[R2, #+1]
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x08C9             LSRS     R1,R1,#+3
   \   00000040   0x7855             LDRB     R5,[R2, #+1]
   \   00000042   0xF015 0x0507      ANDS     R5,R5,#0x7
   \   00000046   0xEA55 0x01C1      ORRS     R1,R5,R1, LSL #+3
   \   0000004A   0x7021             STRB     R1,[R4, #+0]
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
    805            *pBuf++ = pNodeDesc->CapabilityFlags;
   \   0000004E   0x7891             LDRB     R1,[R2, #+2]
   \   00000050   0x7021             STRB     R1,[R4, #+0]
   \   00000052   0x1C64             ADDS     R4,R4,#+1
    806            *pBuf++ = pNodeDesc->ManufacturerCode[0];
   \   00000054   0x78D1             LDRB     R1,[R2, #+3]
   \   00000056   0x7021             STRB     R1,[R4, #+0]
   \   00000058   0x1C64             ADDS     R4,R4,#+1
    807            *pBuf++ = pNodeDesc->ManufacturerCode[1];
   \   0000005A   0x7911             LDRB     R1,[R2, #+4]
   \   0000005C   0x7021             STRB     R1,[R4, #+0]
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
    808            *pBuf++ = pNodeDesc->MaxBufferSize;
   \   00000060   0x7951             LDRB     R1,[R2, #+5]
   \   00000062   0x7021             STRB     R1,[R4, #+0]
   \   00000064   0x1C64             ADDS     R4,R4,#+1
    809            *pBuf++ = pNodeDesc->MaxInTransferSize[0];
   \   00000066   0x7991             LDRB     R1,[R2, #+6]
   \   00000068   0x7021             STRB     R1,[R4, #+0]
   \   0000006A   0x1C64             ADDS     R4,R4,#+1
    810            *pBuf++ = pNodeDesc->MaxInTransferSize[1];
   \   0000006C   0x79D1             LDRB     R1,[R2, #+7]
   \   0000006E   0x7021             STRB     R1,[R4, #+0]
   \   00000070   0x1C64             ADDS     R4,R4,#+1
    811          
    812            *pBuf++ = LO_UINT16( pNodeDesc->ServerMask );
   \   00000072   0x8911             LDRH     R1,[R2, #+8]
   \   00000074   0x7021             STRB     R1,[R4, #+0]
   \   00000076   0x1C64             ADDS     R4,R4,#+1
    813            *pBuf++ = HI_UINT16( pNodeDesc->ServerMask );
   \   00000078   0x8911             LDRH     R1,[R2, #+8]
   \   0000007A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007C   0x0A09             LSRS     R1,R1,#+8
   \   0000007E   0x7021             STRB     R1,[R4, #+0]
   \   00000080   0x1C64             ADDS     R4,R4,#+1
    814            *pBuf++ = pNodeDesc->MaxOutTransferSize[0];
   \   00000082   0x7A91             LDRB     R1,[R2, #+10]
   \   00000084   0x7021             STRB     R1,[R4, #+0]
   \   00000086   0x1C64             ADDS     R4,R4,#+1
    815            *pBuf++ = pNodeDesc->MaxOutTransferSize[1];
   \   00000088   0x7AD1             LDRB     R1,[R2, #+11]
   \   0000008A   0x7021             STRB     R1,[R4, #+0]
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
    816            *pBuf = pNodeDesc->DescriptorCapability;
   \   0000008E   0x7B11             LDRB     R1,[R2, #+12]
   \   00000090   0x7021             STRB     R1,[R4, #+0]
    817          
    818            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Node_Desc_rsp, len );
   \   00000092   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000094   0xF248 0x0202      MOVW     R2,#+32770
   \   00000098   0x1C81             ADDS     R1,R0,#+2
   \   0000009A   0x3011             ADDS     R0,R0,#+17
   \   0000009C   0x.... 0x....      BL       fillAndSend
   \   000000A0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    819          }
    820          
    821          /*********************************************************************
    822           * @fn          ZDP_PowerDescMsg
    823           *
    824           * @brief       Builds and sends a Power Descriptor message, unicast to the
    825           *              specified device.
    826           *
    827           * @param       inMsg - incoming message (request)
    828           * @param       nwkAddr - 16 bit network address for device
    829           * @param       pPowerDesc - pointer to the node descriptor
    830           *
    831           * @return      afStatus_t
    832           */

   \                                 In section .text, align 2, keep-with-next
    833          afStatus_t ZDP_PowerDescMsg( zdoIncomingMsg_t *inMsg,
    834                               uint16 nwkAddr, NodePowerDescriptorFormat_t *pPowerDesc )
    835          {
   \                     ZDP_PowerDescMsg: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    836            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable34
   \   00000006   0x681C             LDR      R4,[R3, #+0]
    837            byte len = 1 + 2 + 2;  // Status + nwkAddr + Node Power descriptor.
   \   00000008   0x2305             MOVS     R3,#+5
    838          
    839            *pBuf++ = ZDP_SUCCESS;
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x7025             STRB     R5,[R4, #+0]
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
    840          
    841            *pBuf++ = LO_UINT16( nwkAddr );
   \   00000010   0x7021             STRB     R1,[R4, #+0]
   \   00000012   0x1C64             ADDS     R4,R4,#+1
    842            *pBuf++ = HI_UINT16( nwkAddr );
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x0A09             LSRS     R1,R1,#+8
   \   00000018   0x7021             STRB     R1,[R4, #+0]
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
    843          
    844            *pBuf++ = (byte)((pPowerDesc->AvailablePowerSources << 4)
    845                              | (pPowerDesc->PowerMode & 0x0F));
   \   0000001C   0x6811             LDR      R1,[R2, #+0]
   \   0000001E   0x0909             LSRS     R1,R1,#+4
   \   00000020   0x7815             LDRB     R5,[R2, #+0]
   \   00000022   0xF015 0x050F      ANDS     R5,R5,#0xF
   \   00000026   0xEA55 0x1101      ORRS     R1,R5,R1, LSL #+4
   \   0000002A   0x7021             STRB     R1,[R4, #+0]
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
    846            *pBuf++ = (byte)((pPowerDesc->CurrentPowerSourceLevel << 4)
    847                              | (pPowerDesc->CurrentPowerSource & 0x0F));
   \   0000002E   0x6811             LDR      R1,[R2, #+0]
   \   00000030   0x0B09             LSRS     R1,R1,#+12
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x0A12             LSRS     R2,R2,#+8
   \   00000036   0xF012 0x020F      ANDS     R2,R2,#0xF
   \   0000003A   0xEA52 0x1101      ORRS     R1,R2,R1, LSL #+4
   \   0000003E   0x7021             STRB     R1,[R4, #+0]
   \   00000040   0x1C64             ADDS     R4,R4,#+1
    848          
    849            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Power_Desc_rsp, len );
   \   00000042   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000044   0xF248 0x0203      MOVW     R2,#+32771
   \   00000048   0x1C81             ADDS     R1,R0,#+2
   \   0000004A   0x3011             ADDS     R0,R0,#+17
   \   0000004C   0x.... 0x....      BL       fillAndSend
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    850          }
    851          
    852          /*********************************************************************
    853           * @fn          ZDP_SimpleDescMsg
    854           *
    855           * @brief       Builds and sends a Simple Descriptor message, unicast to the
    856           *              specified device.
    857           *
    858           * @param       inMsg - incoming message (request)
    859           * @param       Status - message status (ZDP_SUCCESS or other)
    860           * @param       pSimpleDesc - pointer to the node descriptor
    861           *
    862           * @return      afStatus_t
    863           */

   \                                 In section .text, align 2, keep-with-next
    864          afStatus_t ZDP_SimpleDescMsg( zdoIncomingMsg_t *inMsg, byte Status,
    865                                        SimpleDescriptionFormat_t *pSimpleDesc )
    866          {
   \                     ZDP_SimpleDescMsg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    867            uint8 *pBuf = ZDP_TmpBuf;
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   00000006   0x681C             LDR      R4,[R3, #+0]
    868            uint8 i, len;
    869          
    870            if ( Status == ZDP_SUCCESS && pSimpleDesc )
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD109             BNE.N    ??ZDP_SimpleDescMsg_0
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD007             BEQ.N    ??ZDP_SimpleDescMsg_0
    871            {
    872              // Status + NWKAddrOfInterest + desc length + empty simple descriptor.
    873              len = 1 + 2 + 1 + 8;
   \   00000012   0x230C             MOVS     R3,#+12
    874              len += (pSimpleDesc->AppNumInClusters + pSimpleDesc->AppNumOutClusters) * sizeof ( uint16 );
   \   00000014   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000016   0x79D5             LDRB     R5,[R2, #+7]
   \   00000018   0x7B16             LDRB     R6,[R2, #+12]
   \   0000001A   0x1975             ADDS     R5,R6,R5
   \   0000001C   0xEB13 0x0345      ADDS     R3,R3,R5, LSL #+1
   \   00000020   0xE000             B.N      ??ZDP_SimpleDescMsg_1
    875            }
    876            else
    877            {
    878              len = 1 + 2 + 1; // Status + desc length
   \                     ??ZDP_SimpleDescMsg_0: (+1)
   \   00000022   0x2304             MOVS     R3,#+4
    879            }
    880            if ( len >= ZDP_BUF_SZ-1 )
   \                     ??ZDP_SimpleDescMsg_1: (+1)
   \   00000024   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000026   0x2B4F             CMP      R3,#+79
   \   00000028   0xDB01             BLT.N    ??ZDP_SimpleDescMsg_2
    881            {
    882              return afStatus_MEM_FAIL;
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0xE06A             B.N      ??ZDP_SimpleDescMsg_3
    883            }
    884          
    885            *pBuf++ = Status;
   \                     ??ZDP_SimpleDescMsg_2: (+1)
   \   0000002E   0x7021             STRB     R1,[R4, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
    886          
    887            *pBuf++ = LO_UINT16( ZDAppNwkAddr.addr.shortAddr );
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable28_3
   \   00000036   0x8809             LDRH     R1,[R1, #+0]
   \   00000038   0x7021             STRB     R1,[R4, #+0]
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
    888            *pBuf++ = HI_UINT16( ZDAppNwkAddr.addr.shortAddr );
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable28_3
   \   00000040   0x8809             LDRH     R1,[R1, #+0]
   \   00000042   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000044   0x0A09             LSRS     R1,R1,#+8
   \   00000046   0x7021             STRB     R1,[R4, #+0]
   \   00000048   0x1C64             ADDS     R4,R4,#+1
    889          
    890            if ( len > 4 )
   \   0000004A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004C   0x2B05             CMP      R3,#+5
   \   0000004E   0xDB50             BLT.N    ??ZDP_SimpleDescMsg_4
    891            {
    892              *pBuf++ = len - 4;   // Simple descriptor length
   \   00000050   0x1F19             SUBS     R1,R3,#+4
   \   00000052   0x7021             STRB     R1,[R4, #+0]
   \   00000054   0x1C64             ADDS     R4,R4,#+1
    893          
    894              *pBuf++ = pSimpleDesc->EndPoint;
   \   00000056   0x7811             LDRB     R1,[R2, #+0]
   \   00000058   0x7021             STRB     R1,[R4, #+0]
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
    895              *pBuf++ = LO_UINT16( pSimpleDesc->AppProfId );
   \   0000005C   0x8851             LDRH     R1,[R2, #+2]
   \   0000005E   0x7021             STRB     R1,[R4, #+0]
   \   00000060   0x1C64             ADDS     R4,R4,#+1
    896              *pBuf++ = HI_UINT16( pSimpleDesc->AppProfId );
   \   00000062   0x8851             LDRH     R1,[R2, #+2]
   \   00000064   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000066   0x0A09             LSRS     R1,R1,#+8
   \   00000068   0x7021             STRB     R1,[R4, #+0]
   \   0000006A   0x1C64             ADDS     R4,R4,#+1
    897              *pBuf++ = LO_UINT16( pSimpleDesc->AppDeviceId );
   \   0000006C   0x8891             LDRH     R1,[R2, #+4]
   \   0000006E   0x7021             STRB     R1,[R4, #+0]
   \   00000070   0x1C64             ADDS     R4,R4,#+1
    898              *pBuf++ = HI_UINT16( pSimpleDesc->AppDeviceId );
   \   00000072   0x8891             LDRH     R1,[R2, #+4]
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0x7021             STRB     R1,[R4, #+0]
   \   0000007A   0x1C64             ADDS     R4,R4,#+1
    899          
    900              *pBuf++ = (byte)(pSimpleDesc->AppDevVer & 0x0F);
   \   0000007C   0x7991             LDRB     R1,[R2, #+6]
   \   0000007E   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   00000082   0x7021             STRB     R1,[R4, #+0]
   \   00000084   0x1C64             ADDS     R4,R4,#+1
    901          
    902              *pBuf++ = pSimpleDesc->AppNumInClusters;
   \   00000086   0x79D1             LDRB     R1,[R2, #+7]
   \   00000088   0x7021             STRB     R1,[R4, #+0]
   \   0000008A   0x1C64             ADDS     R4,R4,#+1
    903              if ( pSimpleDesc->AppNumInClusters )
   \   0000008C   0x79D1             LDRB     R1,[R2, #+7]
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD014             BEQ.N    ??ZDP_SimpleDescMsg_5
    904              {
    905                for (i=0; i<pSimpleDesc->AppNumInClusters; ++i)
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0xE00E             B.N      ??ZDP_SimpleDescMsg_6
    906                {
    907                  *pBuf++ = LO_UINT16( pSimpleDesc->pAppInClusterList[i] );
   \                     ??ZDP_SimpleDescMsg_7: (+1)
   \   00000096   0x6895             LDR      R5,[R2, #+8]
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0xF835 0x5011      LDRH     R5,[R5, R1, LSL #+1]
   \   0000009E   0x7025             STRB     R5,[R4, #+0]
   \   000000A0   0x1C64             ADDS     R4,R4,#+1
    908                  *pBuf++ = HI_UINT16( pSimpleDesc->pAppInClusterList[i] );
   \   000000A2   0x6895             LDR      R5,[R2, #+8]
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0xF835 0x5011      LDRH     R5,[R5, R1, LSL #+1]
   \   000000AA   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000AC   0x0A2D             LSRS     R5,R5,#+8
   \   000000AE   0x7025             STRB     R5,[R4, #+0]
   \   000000B0   0x1C64             ADDS     R4,R4,#+1
    909                }
   \   000000B2   0x1C49             ADDS     R1,R1,#+1
   \                     ??ZDP_SimpleDescMsg_6: (+1)
   \   000000B4   0x79D5             LDRB     R5,[R2, #+7]
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0x42A9             CMP      R1,R5
   \   000000BA   0xD3EC             BCC.N    ??ZDP_SimpleDescMsg_7
    910              }
    911          
    912              *pBuf++ = pSimpleDesc->AppNumOutClusters;
   \                     ??ZDP_SimpleDescMsg_5: (+1)
   \   000000BC   0x7B11             LDRB     R1,[R2, #+12]
   \   000000BE   0x7021             STRB     R1,[R4, #+0]
   \   000000C0   0x1C64             ADDS     R4,R4,#+1
    913              if ( pSimpleDesc->AppNumOutClusters )
   \   000000C2   0x7B11             LDRB     R1,[R2, #+12]
   \   000000C4   0x2900             CMP      R1,#+0
   \   000000C6   0xD016             BEQ.N    ??ZDP_SimpleDescMsg_8
    914              {
    915                for (i=0; i<pSimpleDesc->AppNumOutClusters; ++i)
   \   000000C8   0x2100             MOVS     R1,#+0
   \                     ??ZDP_SimpleDescMsg_9: (+1)
   \   000000CA   0x7B15             LDRB     R5,[R2, #+12]
   \   000000CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CE   0x42A9             CMP      R1,R5
   \   000000D0   0xD211             BCS.N    ??ZDP_SimpleDescMsg_8
    916                {
    917                  *pBuf++ = LO_UINT16( pSimpleDesc->pAppOutClusterList[i] );
   \   000000D2   0x6915             LDR      R5,[R2, #+16]
   \   000000D4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D6   0xF835 0x5011      LDRH     R5,[R5, R1, LSL #+1]
   \   000000DA   0x7025             STRB     R5,[R4, #+0]
   \   000000DC   0x1C64             ADDS     R4,R4,#+1
    918                  *pBuf++ = HI_UINT16( pSimpleDesc->pAppOutClusterList[i] );
   \   000000DE   0x6915             LDR      R5,[R2, #+16]
   \   000000E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E2   0xF835 0x5011      LDRH     R5,[R5, R1, LSL #+1]
   \   000000E6   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000E8   0x0A2D             LSRS     R5,R5,#+8
   \   000000EA   0x7025             STRB     R5,[R4, #+0]
   \   000000EC   0x1C64             ADDS     R4,R4,#+1
    919                }
   \   000000EE   0x1C49             ADDS     R1,R1,#+1
   \   000000F0   0xE7EB             B.N      ??ZDP_SimpleDescMsg_9
    920              }
    921            }
    922          
    923            else
    924            {
    925              *pBuf = 0; // Description Length = 0;
   \                     ??ZDP_SimpleDescMsg_4: (+1)
   \   000000F2   0x2100             MOVS     R1,#+0
   \   000000F4   0x7021             STRB     R1,[R4, #+0]
    926            }
    927          
    928            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Simple_Desc_rsp, len );
   \                     ??ZDP_SimpleDescMsg_8: (+1)
   \   000000F6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000F8   0xF248 0x0204      MOVW     R2,#+32772
   \   000000FC   0x1C81             ADDS     R1,R0,#+2
   \   000000FE   0x3011             ADDS     R0,R0,#+17
   \   00000100   0x.... 0x....      BL       fillAndSend
   \                     ??ZDP_SimpleDescMsg_3: (+1)
   \   00000104   0xBD70             POP      {R4-R6,PC}       ;; return
    929          }
    930          
    931          /*********************************************************************
    932           * @fn          ZDP_EPRsp
    933           *
    934           * @brief       This builds and send an endpoint list. Used in
    935           *              Active_EP_rsp and Match_Desc_Rsp
    936           *              message.  This function sends unicast message to the
    937           *              requesting device.
    938           *
    939           * @param       MsgType - either Active_EP_rsp or Match_Desc_Rsp
    940           * @param       dstAddr - destination address
    941           * @param       Status - message status (ZDP_SUCCESS or other)
    942           * @param       nwkAddr - Device's short address that this response describes
    943           * @param       Count - number of endpoint/interfaces in list
    944           * @param       pEPIntfList - Array of Endpoint/Interfaces
    945           * @param       SecurityEnable - Security Options
    946           *
    947           * @return      afStatus_t
    948           */

   \                                 In section .text, align 2, keep-with-next
    949          afStatus_t ZDP_EPRsp( uint16 MsgType, byte TransSeq, zAddrType_t *dstAddr,
    950                                  byte Status, uint16 nwkAddr, byte Count,
    951                                  uint8 *pEPList,
    952                                  byte SecurityEnable )
    953          {
   \                     ZDP_EPRsp: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
    954            uint8 *pBuf = ZDP_TmpBuf;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
    955            byte len = 1 + 2 + 1;  // Status + nwkAddr + endpoint/interface count.
   \   0000000C   0x2604             MOVS     R6,#+4
    956            byte txOptions;
    957          
    958            (void)SecurityEnable;  // Intentionally unreferenced parameter
    959          
    960            if ( MsgType == Match_Desc_rsp )
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0xF248 0x0106      MOVW     R1,#+32774
   \   00000014   0x428C             CMP      R4,R1
   \   00000016   0xD101             BNE.N    ??ZDP_EPRsp_0
    961              txOptions = AF_MSG_ACK_REQUEST;
   \   00000018   0x2710             MOVS     R7,#+16
   \   0000001A   0xE000             B.N      ??ZDP_EPRsp_1
    962            else
    963              txOptions = 0;
   \                     ??ZDP_EPRsp_0: (+1)
   \   0000001C   0x2700             MOVS     R7,#+0
    964          
    965              *pBuf++ = Status;
   \                     ??ZDP_EPRsp_1: (+1)
   \   0000001E   0x7003             STRB     R3,[R0, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x9906             LDR      R1,[SP, #+24]
    966            *pBuf++ = LO_UINT16( nwkAddr );
   \   00000024   0x7001             STRB     R1,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
    967            *pBuf++ = HI_UINT16( nwkAddr );
   \   00000028   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002A   0x0A09             LSRS     R1,R1,#+8
   \   0000002C   0x7001             STRB     R1,[R0, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x9A07             LDR      R2,[SP, #+28]
    968          
    969            *pBuf++ = Count;   // Endpoint/Interface count
   \   00000032   0x7002             STRB     R2,[R0, #+0]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
    970          
    971            if ( Count )
   \   00000036   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD004             BEQ.N    ??ZDP_EPRsp_2
    972            {
    973              len += Count;
   \   0000003C   0x1996             ADDS     R6,R2,R6
    974              osal_memcpy( pBuf, pEPList, Count );
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x9908             LDR      R1,[SP, #+32]
   \   00000042   0x.... 0x....      BL       osal_memcpy
    975            }
    976          
    977            FillAndSendTxOptions( &TransSeq, dstAddr, MsgType, len, txOptions );
   \                     ??ZDP_EPRsp_2: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable27_2
   \   0000004A   0x7007             STRB     R7,[R0, #+0]
   \   0000004C   0x0033             MOVS     R3,R6
   \   0000004E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000050   0x0022             MOVS     R2,R4
   \   00000052   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      BL       fillAndSend
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   00000062   0x7011             STRB     R1,[R2, #+0]
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    978          }
    979          
    980          /*********************************************************************
    981           * @fn          ZDP_UserDescRsp
    982           *
    983           * @brief       Build and send the User Decriptor Response.
    984           *
    985           *
    986           * @param       dstAddr - destination address
    987           * @param       nwkAddrOfInterest -
    988           * @param       userDesc -
    989           * @param       SecurityEnable - Security Options
    990           *
    991           * @return      ZStatus_t
    992           */

   \                                 In section .text, align 2, keep-with-next
    993          ZStatus_t ZDP_UserDescRsp( byte TransSeq, zAddrType_t *dstAddr,
    994                          uint16 nwkAddrOfInterest, UserDescriptorFormat_t *userDesc,
    995                          byte SecurityEnable )
    996          {
   \                     ZDP_UserDescRsp: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0x000C             MOVS     R4,R1
    997            uint8 *pBuf = ZDP_TmpBuf;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable34
   \   00000008   0x6800             LDR      R0,[R0, #+0]
    998            byte len = 1 + 2 + 1;  // Status + nwkAddr + descriptor length.
   \   0000000A   0x2504             MOVS     R5,#+4
    999          
   1000            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1001          
   1002            len += userDesc->len;
   \   0000000C   0x7819             LDRB     R1,[R3, #+0]
   \   0000000E   0x194D             ADDS     R5,R1,R5
   1003          
   1004            *pBuf++ = ZSUCCESS;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   1005          
   1006            *pBuf++ = LO_UINT16( nwkAddrOfInterest );
   \   00000016   0x7002             STRB     R2,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   1007            *pBuf++ = HI_UINT16( nwkAddrOfInterest );
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x0A11             LSRS     R1,R2,#+8
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   1008          
   1009            *pBuf++ = userDesc->len;
   \   00000022   0x7819             LDRB     R1,[R3, #+0]
   \   00000024   0x7001             STRB     R1,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   1010            osal_memcpy( pBuf, userDesc->desc, userDesc->len );
   \   00000028   0x781A             LDRB     R2,[R3, #+0]
   \   0000002A   0x1C59             ADDS     R1,R3,#+1
   \   0000002C   0x.... 0x....      BL       osal_memcpy
   1011          
   1012            return (ZStatus_t)fillAndSend( &TransSeq, dstAddr, User_Desc_rsp, len );
   \   00000030   0x002B             MOVS     R3,R5
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0xF248 0x0211      MOVW     R2,#+32785
   \   00000038   0x0021             MOVS     R1,R4
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       fillAndSend
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1013          }
   1014          
   1015          /*********************************************************************
   1016           * @fn          ZDP_ServerDiscRsp
   1017           *
   1018           * @brief       Build and send the Server_Discovery_rsp response.
   1019           *
   1020           * @param       transID - Transaction sequence number of request.
   1021           * @param       dstAddr - Network Destination Address.
   1022           * @param       status - Status of response to request.
   1023           * @param       aoi - Network Address of Interest of request.
   1024           * @param       serverMask - Bit map of service(s) being sought.
   1025           * @param       SecurityEnable - Security Options
   1026           *
   1027           * @return      ZStatus_t
   1028           */

   \                                 In section .text, align 2, keep-with-next
   1029          ZStatus_t ZDP_ServerDiscRsp( byte transID, zAddrType_t *dstAddr, byte status,
   1030                                     uint16 aoi, uint16 serverMask, byte SecurityEnable )
   1031          {
   \                     ZDP_ServerDiscRsp: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1032            const byte len = 1  + 2;  // status + aoi + mask.
   \   00000004   0x2303             MOVS     R3,#+3
   1033            uint8 *pBuf = ZDP_TmpBuf;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000000A   0x6804             LDR      R4,[R0, #+0]
   1034            ZStatus_t stat;
   1035          
   1036            // Intentionally unreferenced parameters
   1037            (void)aoi;
   1038            (void)SecurityEnable;
   1039          
   1040            *pBuf++ = status;
   \   0000000C   0x7022             STRB     R2,[R4, #+0]
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \   00000010   0x9804             LDR      R0,[SP, #+16]
   1041          
   1042            *pBuf++ = LO_UINT16( serverMask );
   \   00000012   0x7020             STRB     R0,[R4, #+0]
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   1043            *pBuf++ = HI_UINT16( serverMask );
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x0A00             LSRS     R0,R0,#+8
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   1044          
   1045            ZDP_TxOptions = AF_MSG_ACK_REQUEST;
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   00000024   0x7010             STRB     R0,[R2, #+0]
   1046            stat = fillAndSend( &transID, dstAddr, Server_Discovery_rsp, len );
   \   00000026   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000028   0xF248 0x0215      MOVW     R2,#+32789
   \   0000002C   0xA801             ADD      R0,SP,#+4
   \   0000002E   0x.... 0x....      BL       fillAndSend
   1047            ZDP_TxOptions = AF_TX_OPTIONS_NONE;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable27_2
   \   00000038   0x7011             STRB     R1,[R2, #+0]
   1048          
   1049            return ( stat );
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1050          }
   1051          
   1052          /*********************************************************************
   1053           * @fn          ZDP_GenericRsp
   1054           *
   1055           * @brief       Sends a response message with only the parameter status
   1056           *              byte and the addr of interest for data.
   1057           *              This function sends unicast message to the
   1058           *              requesting device.
   1059           *
   1060           * @param       dstAddr - destination address
   1061           * @param       status  - generic status for response
   1062           * @param       aoi     - address of interest
   1063           * @param       dstAddr - destination address
   1064           * @param       rspId   - response cluster ID
   1065           * @param       SecurityEnable - Security Options
   1066           *
   1067           * @return      afStatus_t
   1068           */

   \                                 In section .text, align 2, keep-with-next
   1069          afStatus_t ZDP_GenericRsp( byte TransSeq, zAddrType_t *dstAddr,
   1070                               byte status, uint16 aoi, uint16 rspID, byte SecurityEnable )
   1071          {
   \                     ZDP_GenericRsp: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   1072            uint8 len;
   1073          
   1074            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1075          
   1076            ZDP_TmpBuf[0] = status;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable34
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7002             STRB     R2,[R0, #+0]
   1077            ZDP_TmpBuf[1] = LO_UINT16( aoi );
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable34
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x7043             STRB     R3,[R0, #+1]
   1078            ZDP_TmpBuf[2] = HI_UINT16( aoi );
   \   00000012   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000014   0x0A18             LSRS     R0,R3,#+8
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable34
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x7090             STRB     R0,[R2, #+2]
   1079          
   1080            // Length byte
   1081            ZDP_TmpBuf[3] = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable34
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x70D0             STRB     R0,[R2, #+3]
   1082            len = 4;
   \   00000028   0x2304             MOVS     R3,#+4
   1083          
   1084            return fillAndSend( &TransSeq, dstAddr, rspID, len );
   \   0000002A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002C   0x9A02             LDR      R2,[SP, #+8]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       fillAndSend
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
   1085          }
   1086          
   1087          /*********************************************************************
   1088           * Binding
   1089           */
   1090          /*********************************************************************
   1091           * @fn          ZDP_EndDeviceBindReq
   1092           *
   1093           * @brief       This builds and sends a End_Device_Bind_req message.
   1094           *              This function sends a unicast message.
   1095           *
   1096           * @param       dstAddr - destination address
   1097           * @param       LocalCoordinator - short address of local coordinator
   1098           * @param       epIntf - Endpoint/Interface of Simple Desc
   1099           * @param       ProfileID - Profile ID
   1100           *
   1101           *   The Input cluster list is the opposite of what you would think.
   1102           *   This is the output cluster list of this device
   1103           * @param       NumInClusters - number of input clusters
   1104           * @param       InClusterList - input cluster ID list
   1105           *
   1106           *   The Output cluster list is the opposite of what you would think.
   1107           *   This is the input cluster list of this device
   1108           * @param       NumOutClusters - number of output clusters
   1109           * @param       OutClusterList - output cluster ID list
   1110           *
   1111           * @param       SecurityEnable - Security Options
   1112           *
   1113           * @return      afStatus_t
   1114           */

   \                                 In section .text, align 2, keep-with-next
   1115          afStatus_t ZDP_EndDeviceBindReq( zAddrType_t *dstAddr,
   1116                                           uint16 LocalCoordinator,
   1117                                           byte endPoint,
   1118                                           uint16 ProfileID,
   1119                                           byte NumInClusters, cId_t *InClusterList,
   1120                                           byte NumOutClusters, cId_t *OutClusterList,
   1121                                           byte SecurityEnable )
   1122          {
   \                     ZDP_EndDeviceBindReq: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x469B             MOV      R11,R3
   1123            uint8 *pBuf = ZDP_TmpBuf;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000010   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   1124            uint8 i, len;
   1125            uint8 *ieeeAddr;
   1126          
   1127            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1128          
   1129            // LocalCoordinator + SrcExtAddr + ep + ProfileID +  NumInClusters + NumOutClusters.
   1130            len = 2 + Z_EXTADDR_LEN + 1 + 2 + 1 + 1;
   \   00000014   0x270F             MOVS     R7,#+15
   \   00000016   0x9C0A             LDR      R4,[SP, #+40]
   \   00000018   0x9D0C             LDR      R5,[SP, #+48]
   1131            len += (NumInClusters + NumOutClusters) * sizeof ( uint16 );
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x1928             ADDS     R0,R5,R4
   \   00000022   0xEB17 0x0740      ADDS     R7,R7,R0, LSL #+1
   1132          
   1133            if ( len >= ZDP_BUF_SZ-1 )
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F4F             CMP      R7,#+79
   \   0000002A   0xDB01             BLT.N    ??ZDP_EndDeviceBindReq_0
   1134            {
   1135              return afStatus_MEM_FAIL;
   \   0000002C   0x2010             MOVS     R0,#+16
   \   0000002E   0xE06A             B.N      ??ZDP_EndDeviceBindReq_1
   1136            }
   1137          
   1138            if ( LocalCoordinator != NLME_GetShortAddr() )
   \                     ??ZDP_EndDeviceBindReq_0: (+1)
   \   00000030   0x.... 0x....      BL       NLME_GetShortAddr
   \   00000034   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   0x4581             CMP      R9,R0
   \   0000003A   0xD001             BEQ.N    ??ZDP_EndDeviceBindReq_2
   1139            {
   1140              return afStatus_INVALID_PARAMETER;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE062             B.N      ??ZDP_EndDeviceBindReq_1
   1141            }
   1142          
   1143            *pBuf++ = LO_UINT16( LocalCoordinator );
   \                     ??ZDP_EndDeviceBindReq_2: (+1)
   \   00000040   0xF888 0x9000      STRB     R9,[R8, #+0]
   \   00000044   0xF118 0x0801      ADDS     R8,R8,#+1
   1144            *pBuf++ = HI_UINT16( LocalCoordinator );
   \   00000048   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000004C   0xEA5F 0x2019      LSRS     R0,R9,#+8
   \   00000050   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000054   0xF118 0x0801      ADDS     R8,R8,#+1
   1145          
   1146            ieeeAddr = NLME_GetExtAddr();
   \   00000058   0x.... 0x....      BL       NLME_GetExtAddr
   1147            pBuf = osal_cpyExtAddr( pBuf, ieeeAddr );
   \   0000005C   0x0001             MOVS     R1,R0
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       sAddrExtCpy
   \   00000064   0x4680             MOV      R8,R0
   1148          
   1149            *pBuf++ = endPoint;
   \   00000066   0xF888 0xA000      STRB     R10,[R8, #+0]
   \   0000006A   0xF118 0x0801      ADDS     R8,R8,#+1
   1150          
   1151            *pBuf++ = LO_UINT16( ProfileID );   // Profile ID
   \   0000006E   0xF888 0xB000      STRB     R11,[R8, #+0]
   \   00000072   0xF118 0x0801      ADDS     R8,R8,#+1
   1152            *pBuf++ = HI_UINT16( ProfileID );
   \   00000076   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000007A   0xEA5F 0x201B      LSRS     R0,R11,#+8
   \   0000007E   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000082   0xF118 0x0801      ADDS     R8,R8,#+1
   1153          
   1154            *pBuf++ = NumInClusters; // Input cluster list
   \   00000086   0xF888 0x4000      STRB     R4,[R8, #+0]
   \   0000008A   0xF118 0x0801      ADDS     R8,R8,#+1
   1155            for ( i = 0; i < NumInClusters; ++i )
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x980B             LDR      R0,[SP, #+44]
   \   00000092   0xE010             B.N      ??ZDP_EndDeviceBindReq_3
   1156            {
   1157              *pBuf++ = LO_UINT16(InClusterList[i]);
   \                     ??ZDP_EndDeviceBindReq_4: (+1)
   \   00000094   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000096   0xF830 0x2011      LDRH     R2,[R0, R1, LSL #+1]
   \   0000009A   0xF888 0x2000      STRB     R2,[R8, #+0]
   \   0000009E   0xF118 0x0801      ADDS     R8,R8,#+1
   1158              *pBuf++ = HI_UINT16(InClusterList[i]);
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0xF830 0x2011      LDRH     R2,[R0, R1, LSL #+1]
   \   000000A8   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AA   0x0A12             LSRS     R2,R2,#+8
   \   000000AC   0xF888 0x2000      STRB     R2,[R8, #+0]
   \   000000B0   0xF118 0x0801      ADDS     R8,R8,#+1
   1159            }
   \   000000B4   0x1C49             ADDS     R1,R1,#+1
   \                     ??ZDP_EndDeviceBindReq_3: (+1)
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   0x42A1             CMP      R1,R4
   \   000000BC   0xD3EA             BCC.N    ??ZDP_EndDeviceBindReq_4
   1160          
   1161            *pBuf++ = NumOutClusters; // Output cluster list
   \   000000BE   0xF888 0x5000      STRB     R5,[R8, #+0]
   \   000000C2   0xF118 0x0801      ADDS     R8,R8,#+1
   1162            for ( i = 0; i < NumOutClusters; ++i )
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x980D             LDR      R0,[SP, #+52]
   \   000000CA   0xE010             B.N      ??ZDP_EndDeviceBindReq_5
   1163            {
   1164              *pBuf++ = LO_UINT16(OutClusterList[i]);
   \                     ??ZDP_EndDeviceBindReq_6: (+1)
   \   000000CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CE   0xF830 0x2011      LDRH     R2,[R0, R1, LSL #+1]
   \   000000D2   0xF888 0x2000      STRB     R2,[R8, #+0]
   \   000000D6   0xF118 0x0801      ADDS     R8,R8,#+1
   1165              *pBuf++ = HI_UINT16(OutClusterList[i]);
   \   000000DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DC   0xF830 0x2011      LDRH     R2,[R0, R1, LSL #+1]
   \   000000E0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000E2   0x0A12             LSRS     R2,R2,#+8
   \   000000E4   0xF888 0x2000      STRB     R2,[R8, #+0]
   \   000000E8   0xF118 0x0801      ADDS     R8,R8,#+1
   1166            }
   \   000000EC   0x1C49             ADDS     R1,R1,#+1
   \                     ??ZDP_EndDeviceBindReq_5: (+1)
   \   000000EE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F2   0x42A9             CMP      R1,R5
   \   000000F4   0xD3EA             BCC.N    ??ZDP_EndDeviceBindReq_6
   1167          
   1168            return fillAndSend( &ZDP_TransID, dstAddr, End_Device_Bind_req, len );
   \   000000F6   0x003B             MOVS     R3,R7
   \   000000F8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000FA   0x2220             MOVS     R2,#+32
   \   000000FC   0x0031             MOVS     R1,R6
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000102   0x.... 0x....      BL       fillAndSend
   \                     ??ZDP_EndDeviceBindReq_1: (+1)
   \   00000106   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1169          }
   1170          
   1171          /*********************************************************************
   1172           * @fn          ZDP_BindUnbindReq
   1173           *
   1174           * @brief       This builds and send a Bind_req or Unbind_req message
   1175           *              Depending on the ClusterID. This function
   1176           *              sends a unicast message to the local coordinator.
   1177           *
   1178           * @param       BindOrUnbind - either Bind_req or Unbind_req
   1179           * @param       dstAddr - destination address of the message
   1180           * @param       SourceAddr - source 64 bit address of the binding
   1181           * @param       SrcEPIntf - Source endpoint/interface
   1182           * @param       ClusterID - Binding cluster ID
   1183           * @param       DestinationAddr - destination 64 bit addr of binding
   1184           * @param       DstEPIntf - destination endpoint/interface
   1185           * @param       SecurityEnable - Security Options
   1186           *
   1187           * @return      afStatus_t
   1188           */

   \                                 In section .text, align 2, keep-with-next
   1189          afStatus_t ZDP_BindUnbindReq( uint16 BindOrUnbind, zAddrType_t *dstAddr,
   1190                                        uint8 *SourceAddr, byte SrcEndPoint,
   1191                                        cId_t ClusterID,
   1192                                        zAddrType_t *destinationAddr, byte DstEndPoint,
   1193                                        byte SecurityEnable )
   1194          {
   \                     ZDP_BindUnbindReq: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0011             MOVS     R1,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1195            uint8 *pBuf = ZDP_TmpBuf;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   1196            byte len;
   1197          
   1198            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1199          
   1200            // SourceAddr + SrcEPIntf + ClusterID +  addrMode.
   1201            len = Z_EXTADDR_LEN + 1 + sizeof( cId_t ) + sizeof( uint8 );
   \   00000012   0x260C             MOVS     R6,#+12
   \   00000014   0xF8DD 0x801C      LDR      R8,[SP, #+28]
   1202            if ( destinationAddr->addrMode == Addr64Bit )
   \   00000018   0xF898 0x2008      LDRB     R2,[R8, #+8]
   \   0000001C   0x2A03             CMP      R2,#+3
   \   0000001E   0xD101             BNE.N    ??ZDP_BindUnbindReq_0
   1203              len += Z_EXTADDR_LEN + 1;     // +1 for DstEPIntf
   \   00000020   0x3609             ADDS     R6,R6,#+9
   \   00000022   0xE004             B.N      ??ZDP_BindUnbindReq_1
   1204            else if ( destinationAddr->addrMode == AddrGroup )
   \                     ??ZDP_BindUnbindReq_0: (+1)
   \   00000024   0xF898 0x2008      LDRB     R2,[R8, #+8]
   \   00000028   0x2A01             CMP      R2,#+1
   \   0000002A   0xD100             BNE.N    ??ZDP_BindUnbindReq_1
   1205              len += sizeof ( uint16 );
   \   0000002C   0x1CB6             ADDS     R6,R6,#+2
   1206          
   1207            pBuf = osal_cpyExtAddr( pBuf, SourceAddr );
   \                     ??ZDP_BindUnbindReq_1: (+1)
   \   0000002E   0x.... 0x....      BL       sAddrExtCpy
   1208            *pBuf++ = SrcEndPoint;
   \   00000032   0x7007             STRB     R7,[R0, #+0]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x9906             LDR      R1,[SP, #+24]
   1209          
   1210            *pBuf++ = LO_UINT16( ClusterID );
   \   00000038   0x7001             STRB     R1,[R0, #+0]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   1211          
   1212            *pBuf++ = HI_UINT16( ClusterID );
   \   0000003C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003E   0x0A09             LSRS     R1,R1,#+8
   \   00000040   0x7001             STRB     R1,[R0, #+0]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   1213            *pBuf++ = destinationAddr->addrMode;
   \   00000044   0xF898 0x1008      LDRB     R1,[R8, #+8]
   \   00000048   0x7001             STRB     R1,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   1214            if ( destinationAddr->addrMode == Addr64Bit )
   \   0000004C   0xF898 0x1008      LDRB     R1,[R8, #+8]
   \   00000050   0x2903             CMP      R1,#+3
   \   00000052   0xD105             BNE.N    ??ZDP_BindUnbindReq_2
   1215            {
   1216              pBuf = osal_cpyExtAddr( pBuf, destinationAddr->addr.extAddr );
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0x.... 0x....      BL       sAddrExtCpy
   1217              *pBuf = DstEndPoint;
   \   0000005A   0x9908             LDR      R1,[SP, #+32]
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
   \   0000005E   0xE00D             B.N      ??ZDP_BindUnbindReq_3
   1218            }
   1219            else if ( destinationAddr->addrMode == AddrGroup )
   \                     ??ZDP_BindUnbindReq_2: (+1)
   \   00000060   0xF898 0x1008      LDRB     R1,[R8, #+8]
   \   00000064   0x2901             CMP      R1,#+1
   \   00000066   0xD109             BNE.N    ??ZDP_BindUnbindReq_3
   1220            {
   1221              *pBuf++ = LO_UINT16( destinationAddr->addr.shortAddr );
   \   00000068   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   1222              *pBuf++ = HI_UINT16( destinationAddr->addr.shortAddr );
   \   00000070   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0x7001             STRB     R1,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   1223            }
   1224          
   1225            FillAndSendTxOptions( &ZDP_TransID, dstAddr, BindOrUnbind, len, AF_MSG_ACK_REQUEST );
   \                     ??ZDP_BindUnbindReq_3: (+1)
   \   0000007C   0x2010             MOVS     R0,#+16
   \   0000007E   0x....             LDR.N    R1,??DataTable27_2
   \   00000080   0x7008             STRB     R0,[R1, #+0]
   \   00000082   0x0033             MOVS     R3,R6
   \   00000084   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000086   0x0022             MOVS     R2,R4
   \   00000088   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \   00000090   0x.... 0x....      BL       fillAndSend
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x....             LDR.N    R2,??DataTable27_2
   \   00000098   0x7011             STRB     R1,[R2, #+0]
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1226          }
   1227          
   1228          /*********************************************************************
   1229           * Network Management
   1230           */
   1231          
   1232          /*********************************************************************
   1233           * @fn          ZDP_MgmtNwkDiscReq
   1234           *
   1235           * @brief       This builds and send a Mgmt_NWK_Disc_req message. This
   1236           *              function sends a unicast message.
   1237           *
   1238           * @param       dstAddr - destination address of the message
   1239           * @param       ScanChannels - 32 bit address bit map
   1240           * @param       StartIndex - Starting index within the reporting network
   1241           *                           list
   1242           * @param       SecurityEnable - Security Options
   1243           *
   1244           * @return      afStatus_t
   1245           */

   \                                 In section .text, align 2, keep-with-next
   1246          afStatus_t ZDP_MgmtNwkDiscReq( zAddrType_t *dstAddr,
   1247                                         uint32 ScanChannels,
   1248                                         byte ScanDuration,
   1249                                         byte StartIndex,
   1250                                         byte SecurityEnable )
   1251          {
   \                     ZDP_MgmtNwkDiscReq: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001E             MOVS     R6,R3
   1252            uint8 *pBuf = ZDP_TmpBuf;
   \   00000008   0x....             LDR.N    R0,??DataTable27_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   1253            byte len = sizeof( uint32 )+1+1;  // ScanChannels + ScanDuration + StartIndex.
   \   0000000C   0x2706             MOVS     R7,#+6
   1254          
   1255            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1256          
   1257            pBuf = osal_buffer_uint32( pBuf, ScanChannels );
   \   0000000E   0x.... 0x....      BL       osal_buffer_uint32
   1258          
   1259            *pBuf++ = ScanDuration;
   \   00000012   0x7005             STRB     R5,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   1260            *pBuf = StartIndex;
   \   00000016   0x7006             STRB     R6,[R0, #+0]
   1261          
   1262            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_NWK_Disc_req, len );
   \   00000018   0x003B             MOVS     R3,R7
   \   0000001A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001C   0x2230             MOVS     R2,#+48
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000024   0x.... 0x....      BL       fillAndSend
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1263          }
   1264          
   1265          /*********************************************************************
   1266           * @fn          ZDP_MgmtDirectJoinReq
   1267           *
   1268           * @brief       This builds and send a Mgmt_Direct_Join_req message. This
   1269           *              function sends a unicast message.
   1270           *
   1271           * @param       dstAddr - destination address of the message
   1272           * @param       deviceAddr - 64 bit IEEE Address
   1273           * @param       SecurityEnable - Security Options
   1274           *
   1275           * @return      afStatus_t
   1276           */

   \                                 In section .text, align 2, keep-with-next
   1277          afStatus_t ZDP_MgmtDirectJoinReq( zAddrType_t *dstAddr,
   1278                                         uint8 *deviceAddr,
   1279                                         byte capInfo,
   1280                                         byte SecurityEnable )
   1281          {
   \                     ZDP_MgmtDirectJoinReq: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1282            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1283          
   1284            osal_cpyExtAddr( ZDP_TmpBuf, deviceAddr );
   \   00000006   0x....             LDR.N    R0,??DataTable27_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x.... 0x....      BL       sAddrExtCpy
   1285            ZDP_TmpBuf[Z_EXTADDR_LEN] = capInfo;
   \   0000000E   0x....             LDR.N    R0,??DataTable27_1
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x7205             STRB     R5,[R0, #+8]
   1286          
   1287            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Direct_Join_req, (Z_EXTADDR_LEN + 1) );
   \   00000014   0x2309             MOVS     R3,#+9
   \   00000016   0x2235             MOVS     R2,#+53
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001E   0x.... 0x....      BL       fillAndSend
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1288          }
   1289          
   1290          /*********************************************************************
   1291           * @fn          ZDP_MgmtPermitJoinReq
   1292           *
   1293           * @brief       This builds and send a Mgmt_Permit_Join_req message.
   1294           *
   1295           * @param       dstAddr - destination address of the message
   1296           * @param       duration - Permit duration
   1297           * @param       TcSignificance - Trust Center Significance
   1298           *
   1299           * @return      afStatus_t
   1300           */

   \                                 In section .text, align 2, keep-with-next
   1301          afStatus_t ZDP_MgmtPermitJoinReq( zAddrType_t *dstAddr, byte duration,
   1302                                            byte TcSignificance, byte SecurityEnable )
   1303          {
   \                     ZDP_MgmtPermitJoinReq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1304            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1305          
   1306            // Build buffer
   1307            ZDP_TmpBuf[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION] = duration;
   \   00000002   0x....             LDR.N    R3,??DataTable27_1
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x7019             STRB     R1,[R3, #+0]
   1308            ZDP_TmpBuf[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG]   = TcSignificance;
   \   00000008   0x....             LDR.N    R1,??DataTable27_1
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x704A             STRB     R2,[R1, #+1]
   1309          
   1310            // Send the message
   1311            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Permit_Join_req,
   1312                                ZDP_MGMT_PERMIT_JOIN_REQ_SIZE );
   \   0000000E   0x2302             MOVS     R3,#+2
   \   00000010   0x2236             MOVS     R2,#+54
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000018   0x.... 0x....      BL       fillAndSend
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   1313          }
   1314          
   1315          /*********************************************************************
   1316           * @fn          ZDP_MgmtLeaveReq
   1317           *
   1318           * @brief       This builds and send a Mgmt_Leave_req message.
   1319           *
   1320           * @param       dstAddr - destination address of the message
   1321           *              IEEEAddr - IEEE adddress of device that is removed
   1322           *              RemoveChildren - set to 1 to remove the children of the
   1323           *                                device as well. 0 otherwise.
   1324           *              Rejoin - set to 1 if the removed device should rejoin
   1325                                   afterwards. 0 otherwise.
   1326           *
   1327           * @return      afStatus_t
   1328           */

   \                                 In section .text, align 2, keep-with-next
   1329          afStatus_t ZDP_MgmtLeaveReq( zAddrType_t *dstAddr, uint8 *IEEEAddr, uint8 RemoveChildren,
   1330                           uint8 Rejoin, uint8 SecurityEnable )
   1331          
   1332          {
   \                     ZDP_MgmtLeaveReq: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
   1333            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1334          
   1335            osal_cpyExtAddr( ZDP_TmpBuf, IEEEAddr );
   \   00000008   0x....             LDR.N    R0,??DataTable27_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x.... 0x....      BL       sAddrExtCpy
   1336            ZDP_TmpBuf[Z_EXTADDR_LEN] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable27_1
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x7208             STRB     R0,[R1, #+8]
   1337          
   1338            if ( RemoveChildren == TRUE )
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E01             CMP      R6,#+1
   \   0000001C   0xD107             BNE.N    ??ZDP_MgmtLeaveReq_0
   1339            {
   1340              ZDP_TmpBuf[Z_EXTADDR_LEN] |= ZDP_MGMT_LEAVE_REQ_RC;
   \   0000001E   0x....             LDR.N    R0,??DataTable27_1
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x7A00             LDRB     R0,[R0, #+8]
   \   00000024   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000028   0x....             LDR.N    R1,??DataTable27_1
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0x7208             STRB     R0,[R1, #+8]
   1341            }
   1342            if ( Rejoin == TRUE )
   \                     ??ZDP_MgmtLeaveReq_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD107             BNE.N    ??ZDP_MgmtLeaveReq_1
   1343            {
   1344              ZDP_TmpBuf[Z_EXTADDR_LEN] |= ZDP_MGMT_LEAVE_REQ_REJOIN;
   \   00000034   0x....             LDR.N    R0,??DataTable27_1
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x7A00             LDRB     R0,[R0, #+8]
   \   0000003A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000003E   0x....             LDR.N    R1,??DataTable27_1
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x7208             STRB     R0,[R1, #+8]
   1345            }
   1346          
   1347            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Leave_req, (Z_EXTADDR_LEN + 1) );
   \                     ??ZDP_MgmtLeaveReq_1: (+1)
   \   00000044   0x2309             MOVS     R3,#+9
   \   00000046   0x2234             MOVS     R2,#+52
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000004E   0x.... 0x....      BL       fillAndSend
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1348          }
   1349          
   1350          /*********************************************************************
   1351           * @fn          ZDP_MgmtNwkUpdateReq
   1352           *
   1353           * @brief       This builds and send a Mgmt_NWK_Update_req message. This
   1354           *              function sends a unicast or broadcast message.
   1355           *
   1356           * @param       dstAddr - destination address of the message
   1357           * @param       ChannelMask - 32 bit address bit map
   1358           * @param       ScanDuration - length of time to spend scanning each channel
   1359           * @param       ScanCount - number of energy scans to be conducted
   1360           * @param       NwkUpdateId - NWk Update Id value
   1361           * @param       NwkManagerAddr - NWK address for device with Network Manager
   1362           *                               bit set in its Node Descriptor
   1363           *
   1364           * @return      afStatus_t
   1365           */

   \                                 In section .text, align 2, keep-with-next
   1366          afStatus_t ZDP_MgmtNwkUpdateReq( zAddrType_t *dstAddr,
   1367                                           uint32 ChannelMask,
   1368                                           uint8 ScanDuration,
   1369                                           uint8 ScanCount,
   1370                                           uint8 NwkUpdateId,
   1371                                           uint16 NwkManagerAddr )
   1372          {
   \                     ZDP_MgmtNwkUpdateReq: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001E             MOVS     R6,R3
   1373            uint8 *pBuf = ZDP_TmpBuf;
   \   00000008   0x....             LDR.N    R0,??DataTable27_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   1374            byte len = sizeof( uint32 ) + 1;  // ChannelMask + ScanDuration
   \   0000000C   0x2705             MOVS     R7,#+5
   1375          
   1376            pBuf = osal_buffer_uint32( pBuf, ChannelMask );
   \   0000000E   0x.... 0x....      BL       osal_buffer_uint32
   1377          
   1378            *pBuf++ = ScanDuration;
   \   00000012   0x7005             STRB     R5,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   1379          
   1380            if ( ScanDuration <= 0x05 )
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D06             CMP      R5,#+6
   \   0000001A   0xDA03             BGE.N    ??ZDP_MgmtNwkUpdateReq_0
   1381            {
   1382              // Request is to scan over channelMask
   1383              len += sizeof( uint8 );
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
   1384          
   1385              *pBuf++ = ScanCount;
   \   0000001E   0x7006             STRB     R6,[R0, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE014             B.N      ??ZDP_MgmtNwkUpdateReq_1
   1386            }
   1387            else if ( ( ScanDuration == 0xFE ) || ( ScanDuration == 0xFF ) )
   \                     ??ZDP_MgmtNwkUpdateReq_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2DFE             CMP      R5,#+254
   \   00000028   0xD002             BEQ.N    ??ZDP_MgmtNwkUpdateReq_2
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2DFF             CMP      R5,#+255
   \   0000002E   0xD10E             BNE.N    ??ZDP_MgmtNwkUpdateReq_1
   1388            {
   1389              // Request is to change Channel (0xFE) or apsChannelMask and NwkManagerAddr (0xFF)
   1390              len += sizeof( uint8 );
   \                     ??ZDP_MgmtNwkUpdateReq_2: (+1)
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
   1391          
   1392              *pBuf++ = NwkUpdateId;
   \   00000032   0x9906             LDR      R1,[SP, #+24]
   \   00000034   0x7001             STRB     R1,[R0, #+0]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   1393          
   1394              if ( ScanDuration == 0xFF )
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2DFF             CMP      R5,#+255
   \   0000003C   0xD107             BNE.N    ??ZDP_MgmtNwkUpdateReq_1
   1395              {
   1396                len += sizeof( uint16 );
   \   0000003E   0x1CBF             ADDS     R7,R7,#+2
   \   00000040   0x9907             LDR      R1,[SP, #+28]
   1397          
   1398                *pBuf++  = LO_UINT16( NwkManagerAddr );
   \   00000042   0x7001             STRB     R1,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   1399                *pBuf++  = HI_UINT16( NwkManagerAddr );
   \   00000046   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000048   0x0A09             LSRS     R1,R1,#+8
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   1400              }
   1401            }
   1402          
   1403            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_NWK_Update_req, len );
   \                     ??ZDP_MgmtNwkUpdateReq_1: (+1)
   \   0000004E   0x003B             MOVS     R3,R7
   \   00000050   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000052   0x2238             MOVS     R2,#+56
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000005A   0x.... 0x....      BL       fillAndSend
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1404          }
   1405          
   1406          
   1407          /*********************************************************************
   1408           * Network Management Responses
   1409           */
   1410          
   1411          /*********************************************************************
   1412           * @fn          ZDP_MgmtNwkDiscRsp
   1413           *
   1414           * @brief       This builds and send a Mgmt_NWK_Disc_rsp message. This
   1415           *              function sends a unicast message.
   1416           *
   1417           * @param       dstAddr - destination address of the message
   1418           * @param       Status - message status (ZDP_SUCCESS or other)
   1419           * @param       NetworkCount - Total number of networks found
   1420           * @param       StartIndex - Starting index within the reporting network
   1421           *                           list
   1422           * @param       NetworkListCount - number of network lists included
   1423           *                                 in this message
   1424           * @param       NetworkList - List of network descriptors
   1425           * @param       SecurityEnable - Security Options
   1426           *
   1427           * @return      afStatus_t
   1428           */

   \                                 In section .text, align 2, keep-with-next
   1429          afStatus_t ZDP_MgmtNwkDiscRsp( byte TransSeq, zAddrType_t *dstAddr,
   1430                                      byte Status,
   1431                                      byte NetworkCount,
   1432                                      byte StartIndex,
   1433                                      byte NetworkListCount,
   1434                                      networkDesc_t *NetworkList,
   1435                                      byte SecurityEnable )
   1436          {
   \                     ZDP_MgmtNwkDiscRsp: (+1)
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
   1437            uint8 *buf;
   1438            uint8 *pBuf;
   1439            byte len = 1+1+1+1;  // Status + NetworkCount + StartIndex + NetworkCountList.
   \   0000000C   0x2604             MOVS     R6,#+4
   \   0000000E   0x9C0B             LDR      R4,[SP, #+44]
   1440            byte idx;
   1441          
   1442            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1443          
   1444            len += (NetworkListCount * ( ZDP_NETWORK_EXTENDED_DISCRIPTOR_SIZE - 2 ));
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0xFB00 0x6604      MLA      R6,R0,R4,R6
   1445          
   1446            buf = osal_mem_alloc( len+1 );
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x1C70             ADDS     R0,R6,#+1
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x.... 0x....      BL       osal_mem_alloc
   \   00000024   0x0007             MOVS     R7,R0
   1447            if ( buf == NULL )
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD101             BNE.N    ??ZDP_MgmtNwkDiscRsp_0
   1448            {
   1449              return afStatus_MEM_FAIL;
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0xE06E             B.N      ??ZDP_MgmtNwkDiscRsp_1
   1450            }
   1451          
   1452            pBuf = buf+1;
   \                     ??ZDP_MgmtNwkDiscRsp_0: (+1)
   \   0000002E   0xF117 0x0801      ADDS     R8,R7,#+1
   1453          
   1454            *pBuf++ = Status;
   \   00000032   0xF888 0x9000      STRB     R9,[R8, #+0]
   \   00000036   0xF118 0x0801      ADDS     R8,R8,#+1
   1455            *pBuf++ = NetworkCount;
   \   0000003A   0xF888 0xA000      STRB     R10,[R8, #+0]
   \   0000003E   0xF118 0x0801      ADDS     R8,R8,#+1
   1456            *pBuf++ = StartIndex;
   \   00000042   0x980A             LDR      R0,[SP, #+40]
   \   00000044   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000048   0xF118 0x0801      ADDS     R8,R8,#+1
   1457            *pBuf++ = NetworkListCount;
   \   0000004C   0xF888 0x4000      STRB     R4,[R8, #+0]
   \   00000050   0xF118 0x0801      ADDS     R8,R8,#+1
   1458          
   1459            for ( idx = 0; idx < NetworkListCount; idx++ )
   \   00000054   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000058   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   0000005C   0xE008             B.N      ??ZDP_MgmtNwkDiscRsp_2
   1460            {
   1461              osal_cpyExtAddr( pBuf, NetworkList->extendedPANID);
   1462              pBuf += Z_EXTADDR_LEN;
   1463          
   1464              *pBuf++  = NetworkList->logicalChannel;                // LogicalChannel
   1465              *pBuf    = NetworkList->stackProfile;                  // Stack profile
   1466              *pBuf++ |= (byte)(NetworkList->version << 4);          // ZigBee Version
   1467              *pBuf    = BEACON_ORDER_NO_BEACONS;                    // Beacon Order
   1468              *pBuf++ |= (uint8)(BEACON_ORDER_NO_BEACONS << 4);      // Superframe Order
   1469          
   1470              if ( NetworkList->chosenRouter != INVALID_NODE_ADDR )
   1471              {
   1472                *pBuf++ = TRUE;                         // Permit Joining
   1473              }
   1474              else
   1475              {
   1476                *pBuf++ = FALSE;
   \                     ??ZDP_MgmtNwkDiscRsp_3: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000064   0xF118 0x0801      ADDS     R8,R8,#+1
   1477              }
   1478          
   1479              NetworkList = NetworkList->nextDesc;    // Move to next list entry
   \                     ??ZDP_MgmtNwkDiscRsp_4: (+1)
   \   00000068   0xF8D9 0x9018      LDR      R9,[R9, #+24]
   \   0000006C   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??ZDP_MgmtNwkDiscRsp_2: (+1)
   \   00000070   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x45A2             CMP      R10,R4
   \   00000078   0xD231             BCS.N    ??ZDP_MgmtNwkDiscRsp_5
   \   0000007A   0xF119 0x010C      ADDS     R1,R9,#+12
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x.... 0x....      BL       sAddrExtCpy
   \   00000084   0xF118 0x0808      ADDS     R8,R8,#+8
   \   00000088   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \   0000008C   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000090   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000094   0xF899 0x0006      LDRB     R0,[R9, #+6]
   \   00000098   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000009C   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000A0   0xF899 0x1005      LDRB     R1,[R9, #+5]
   \   000000A4   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000A8   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000AC   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000B0   0x200F             MOVS     R0,#+15
   \   000000B2   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000B6   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000BA   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \   000000BE   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000C2   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000C6   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   000000CA   0xF64F 0x71FE      MOVW     R1,#+65534
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD0C5             BEQ.N    ??ZDP_MgmtNwkDiscRsp_3
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000D8   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000DC   0xE7C4             B.N      ??ZDP_MgmtNwkDiscRsp_4
   1480            }
   1481          
   1482            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_NWK_Disc_rsp, len, buf );
   \                     ??ZDP_MgmtNwkDiscRsp_5: (+1)
   \   000000DE   0x1C78             ADDS     R0,R7,#+1
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable34
   \   000000E4   0x6008             STR      R0,[R1, #+0]
   \   000000E6   0x0033             MOVS     R3,R6
   \   000000E8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000EA   0xF248 0x0230      MOVW     R2,#+32816
   \   000000EE   0x0029             MOVS     R1,R5
   \   000000F0   0xA801             ADD      R0,SP,#+4
   \   000000F2   0x.... 0x....      BL       fillAndSend
   \   000000F6   0x0004             MOVS     R4,R0
   \   000000F8   0x0038             MOVS     R0,R7
   \   000000FA   0x.... 0x....      BL       osal_mem_free
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable34
   \   00000106   0x6008             STR      R0,[R1, #+0]
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??ZDP_MgmtNwkDiscRsp_1: (+1)
   \   0000010C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1483          }
   1484          
   1485          /*********************************************************************
   1486           * @fn          ZDP_MgmtLqiRsp
   1487           *
   1488           * @brief       This builds and send a Mgmt_Lqi_rsp message. This
   1489           *              function sends a unicast message.
   1490           *
   1491           * @param       dstAddr - destination address of the message
   1492           * @param       Status - message status (ZDP_SUCCESS or other)
   1493           * @param       NeighborLqiEntries - Total number of entries found
   1494           * @param       StartIndex - Starting index within the reporting list
   1495           * @param       NeighborLqiCount - number of lists included
   1496           *                                 in this message
   1497           * @param       NeighborLqiList - List of NeighborLqiItems.  This list
   1498           *                is the list to be sent, not the entire list
   1499           * @param       SecurityEnable - true if secure
   1500           *
   1501           * @return      ZStatus_t
   1502           */

   \                                 In section .text, align 2, keep-with-next
   1503          ZStatus_t ZDP_MgmtLqiRsp( byte TransSeq, zAddrType_t *dstAddr,
   1504                                    byte Status,
   1505                                    byte NeighborLqiEntries,
   1506                                    byte StartIndex,
   1507                                    byte NeighborLqiCount,
   1508                                    ZDP_MgmtLqiItem_t* NeighborList,
   1509                                    byte SecurityEnable )
   1510          {
   \                     ZDP_MgmtLqiRsp: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4692             MOV      R10,R2
   \   00000008   0x469B             MOV      R11,R3
   1511            ZDP_MgmtLqiItem_t* list = NeighborList;
   \   0000000A   0x9E0C             LDR      R6,[SP, #+48]
   1512            uint8 *buf, *pBuf;
   1513            byte len, x;
   1514          
   1515            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1516          
   1517            if ( ZSuccess != Status )
   \   0000000C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000010   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000014   0xD00C             BEQ.N    ??ZDP_MgmtLqiRsp_0
   1518            {
   1519              ZDP_TmpBuf[0] = Status;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF880 0xA000      STRB     R10,[R0, #+0]
   1520              return fillAndSend( &TransSeq, dstAddr, Mgmt_Lqi_rsp, 1 );
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0xF248 0x0231      MOVW     R2,#+32817
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       fillAndSend
   \   0000002E   0xE080             B.N      ??ZDP_MgmtLqiRsp_1
   1521            }
   \                     ??ZDP_MgmtLqiRsp_0: (+1)
   \   00000030   0x9C0B             LDR      R4,[SP, #+44]
   1522          
   1523            // (Status + NeighborLqiEntries + StartIndex + NeighborLqiCount) +
   1524            //  neighbor LQI data.
   1525            len = (1 + 1 + 1 + 1) + (NeighborLqiCount * ZDP_MGMTLQI_EXTENDED_SIZE);
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2016             MOVS     R0,#+22
   \   00000036   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000003A   0x1D07             ADDS     R7,R0,#+4
   1526          
   1527            buf = osal_mem_alloc( len+1 );
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x1C78             ADDS     R0,R7,#+1
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x.... 0x....      BL       osal_mem_alloc
   \   00000046   0x4680             MOV      R8,R0
   1528            if ( buf == NULL )
   \   00000048   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004C   0xD101             BNE.N    ??ZDP_MgmtLqiRsp_2
   1529            {
   1530              return afStatus_MEM_FAIL;
   \   0000004E   0x2010             MOVS     R0,#+16
   \   00000050   0xE06F             B.N      ??ZDP_MgmtLqiRsp_1
   1531            }
   1532          
   1533            pBuf = buf+1;
   \                     ??ZDP_MgmtLqiRsp_2: (+1)
   \   00000052   0xF118 0x0901      ADDS     R9,R8,#+1
   1534          
   1535            *pBuf++ = Status;
   \   00000056   0xF889 0xA000      STRB     R10,[R9, #+0]
   \   0000005A   0xF119 0x0901      ADDS     R9,R9,#+1
   1536            *pBuf++ = NeighborLqiEntries;
   \   0000005E   0xF889 0xB000      STRB     R11,[R9, #+0]
   \   00000062   0xF119 0x0901      ADDS     R9,R9,#+1
   1537            *pBuf++ = StartIndex;
   \   00000066   0x980A             LDR      R0,[SP, #+40]
   \   00000068   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000006C   0xF119 0x0901      ADDS     R9,R9,#+1
   1538            *pBuf++ = NeighborLqiCount;
   \   00000070   0xF889 0x4000      STRB     R4,[R9, #+0]
   \   00000074   0xF119 0x0901      ADDS     R9,R9,#+1
   1539          
   1540            for ( x = 0; x < NeighborLqiCount; x++ )
   \   00000078   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000007C   0xE03C             B.N      ??ZDP_MgmtLqiRsp_3
   1541            {
   1542              osal_cpyExtAddr( pBuf, list->extPanID);         // Extended PanID
   \                     ??ZDP_MgmtLqiRsp_4: (+1)
   \   0000007E   0x1CB1             ADDS     R1,R6,#+2
   \   00000080   0x4648             MOV      R0,R9
   \   00000082   0x.... 0x....      BL       sAddrExtCpy
   1543              pBuf += Z_EXTADDR_LEN;
   \   00000086   0xF119 0x0908      ADDS     R9,R9,#+8
   1544          
   1545              // EXTADDR
   1546              pBuf = osal_cpyExtAddr( pBuf, list->extAddr );
   \   0000008A   0xF116 0x010A      ADDS     R1,R6,#+10
   \   0000008E   0x4648             MOV      R0,R9
   \   00000090   0x.... 0x....      BL       sAddrExtCpy
   \   00000094   0x4681             MOV      R9,R0
   1547          
   1548              // NWKADDR
   1549              *pBuf++ = LO_UINT16( list->nwkAddr );
   \   00000096   0x8A70             LDRH     R0,[R6, #+18]
   \   00000098   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000009C   0xF119 0x0901      ADDS     R9,R9,#+1
   1550              *pBuf++ = HI_UINT16( list->nwkAddr );
   \   000000A0   0x8A70             LDRH     R0,[R6, #+18]
   \   000000A2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A4   0x0A00             LSRS     R0,R0,#+8
   \   000000A6   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000AA   0xF119 0x0901      ADDS     R9,R9,#+1
   1551          
   1552              // DEVICETYPE
   1553              *pBuf = list->devType;
   \   000000AE   0x7D30             LDRB     R0,[R6, #+20]
   \   000000B0   0xF889 0x0000      STRB     R0,[R9, #+0]
   1554          
   1555              // RXONIDLE
   1556              *pBuf |= (uint8)(list->rxOnIdle << 2);
   \   000000B4   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000B8   0x7D71             LDRB     R1,[R6, #+21]
   \   000000BA   0xEA50 0x0081      ORRS     R0,R0,R1, LSL #+2
   \   000000BE   0xF889 0x0000      STRB     R0,[R9, #+0]
   1557          
   1558              // RELATIONSHIP
   1559              *pBuf++ |= (uint8)(list->relation << 4);
   \   000000C2   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000C6   0x7DB1             LDRB     R1,[R6, #+22]
   \   000000C8   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000CC   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000D0   0xF119 0x0901      ADDS     R9,R9,#+1
   1560          
   1561              // PERMITJOINING
   1562              *pBuf++ = (uint8)(list->permit);
   \   000000D4   0x7DF0             LDRB     R0,[R6, #+23]
   \   000000D6   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000DA   0xF119 0x0901      ADDS     R9,R9,#+1
   1563          
   1564              // DEPTH
   1565              *pBuf++ = list->depth;
   \   000000DE   0x7E30             LDRB     R0,[R6, #+24]
   \   000000E0   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000E4   0xF119 0x0901      ADDS     R9,R9,#+1
   1566          
   1567              // LQI
   1568              *pBuf++ = list->lqi;
   \   000000E8   0x7E70             LDRB     R0,[R6, #+25]
   \   000000EA   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000EE   0xF119 0x0901      ADDS     R9,R9,#+1
   1569          
   1570              list++; // next list entry
   \   000000F2   0x361A             ADDS     R6,R6,#+26
   1571            }
   \   000000F4   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??ZDP_MgmtLqiRsp_3: (+1)
   \   000000F8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x45A2             CMP      R10,R4
   \   00000100   0xD3BD             BCC.N    ??ZDP_MgmtLqiRsp_4
   1572          
   1573            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Lqi_rsp, len, buf );
   \   00000102   0xF118 0x0001      ADDS     R0,R8,#+1
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable34
   \   0000010A   0x6008             STR      R0,[R1, #+0]
   \   0000010C   0x003B             MOVS     R3,R7
   \   0000010E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000110   0xF248 0x0231      MOVW     R2,#+32817
   \   00000114   0x0029             MOVS     R1,R5
   \   00000116   0xA800             ADD      R0,SP,#+0
   \   00000118   0x.... 0x....      BL       fillAndSend
   \   0000011C   0x0004             MOVS     R4,R0
   \   0000011E   0x4640             MOV      R0,R8
   \   00000120   0x.... 0x....      BL       osal_mem_free
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable34
   \   0000012C   0x6008             STR      R0,[R1, #+0]
   \   0000012E   0x0020             MOVS     R0,R4
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??ZDP_MgmtLqiRsp_1: (+1)
   \   00000132   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1574          }
   1575          
   1576          /*********************************************************************
   1577           * @fn          ZDP_MgmtRtgRsp
   1578           *
   1579           * @brief       This builds and send a Mgmt_Rtg_rsp message. This
   1580           *              function sends a unicast message.
   1581           *
   1582           * @param       dstAddr - destination address of the message
   1583           * @param       Status - message status (ZDP_SUCCESS or other)
   1584           * @param       RoutingTableEntries - Total number of entries
   1585           * @param       StartIndex - Starting index within the reporting list
   1586           * @param       RoutingTableListCount - number of entries included
   1587           *                                      in this message
   1588           * @param       RoutingTableList - List of Routing Table entries
   1589           * @param       SecurityEnable - true to enable security for this message
   1590           *
   1591           * @return      ZStatus_t
   1592           */

   \                                 In section .text, align 2, keep-with-next
   1593          ZStatus_t ZDP_MgmtRtgRsp( byte TransSeq, zAddrType_t *dstAddr,
   1594                                      byte Status,
   1595                                      byte RoutingTableEntries,
   1596                                      byte StartIndex,
   1597                                      byte RoutingListCount,
   1598                                      rtgItem_t *RoutingTableList,
   1599                                      byte SecurityEnable )
   1600          {
   \                     ZDP_MgmtRtgRsp: (+1)
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4690             MOV      R8,R2
   \   00000008   0x4699             MOV      R9,R3
   1601            uint8 *buf;
   1602            uint8 *pBuf;
   1603            // Status + RoutingTableEntries + StartIndex + RoutingListCount.
   1604            byte len = 1 + 1 + 1 + 1;
   \   0000000A   0x2704             MOVS     R7,#+4
   \   0000000C   0x9C09             LDR      R4,[SP, #+36]
   1605            byte x;
   1606          
   1607            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1608          
   1609            // Add an array for Routing List data
   1610            len += (RoutingListCount * ZDP_ROUTINGENTRY_SIZE);
   \   0000000E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2005             MOVS     R0,#+5
   \   00000014   0xFB00 0x7704      MLA      R7,R0,R4,R7
   1611          
   1612            buf = osal_mem_alloc( (short)(len+1) );
   \   00000018   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001A   0x1C78             ADDS     R0,R7,#+1
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x.... 0x....      BL       osal_mem_alloc
   \   00000022   0x0006             MOVS     R6,R0
   1613            if ( buf == NULL )
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD101             BNE.N    ??ZDP_MgmtRtgRsp_0
   1614            {
   1615              return afStatus_MEM_FAIL;
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0xE05A             B.N      ??ZDP_MgmtRtgRsp_1
   1616            }
   1617          
   1618            pBuf = buf+1;
   \                     ??ZDP_MgmtRtgRsp_0: (+1)
   \   0000002C   0x1C71             ADDS     R1,R6,#+1
   1619          
   1620            *pBuf++ = Status;
   \   0000002E   0xF881 0x8000      STRB     R8,[R1, #+0]
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   1621            *pBuf++ = RoutingTableEntries;
   \   00000034   0xF881 0x9000      STRB     R9,[R1, #+0]
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   1622            *pBuf++ = StartIndex;
   \   0000003A   0x9808             LDR      R0,[SP, #+32]
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   1623            *pBuf++ = RoutingListCount;
   \   00000040   0x700C             STRB     R4,[R1, #+0]
   \   00000042   0x1C49             ADDS     R1,R1,#+1
   1624          
   1625            for ( x = 0; x < RoutingListCount; x++ )
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9A0A             LDR      R2,[SP, #+40]
   \   00000048   0xE032             B.N      ??ZDP_MgmtRtgRsp_2
   1626            {
   1627              *pBuf++ = LO_UINT16( RoutingTableList->dstAddress );  // Destination Address
   \                     ??ZDP_MgmtRtgRsp_3: (+1)
   \   0000004A   0x8813             LDRH     R3,[R2, #+0]
   \   0000004C   0x700B             STRB     R3,[R1, #+0]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   1628              *pBuf++ = HI_UINT16( RoutingTableList->dstAddress );
   \   00000050   0x8813             LDRH     R3,[R2, #+0]
   \   00000052   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000054   0x0A1B             LSRS     R3,R3,#+8
   \   00000056   0x700B             STRB     R3,[R1, #+0]
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   1629          
   1630              *pBuf = (RoutingTableList->status & 0x07);
   \   0000005A   0x7953             LDRB     R3,[R2, #+5]
   \   0000005C   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000060   0x700B             STRB     R3,[R1, #+0]
   1631              if ( RoutingTableList->options & (ZP_MTO_ROUTE_RC | ZP_MTO_ROUTE_NRC) )
   \   00000062   0x7993             LDRB     R3,[R2, #+6]
   \   00000064   0xF05F 0x0C18      MOVS     R12,#+24
   \   00000068   0xEA13 0x0F0C      TST      R3,R12
   \   0000006C   0xD015             BEQ.N    ??ZDP_MgmtRtgRsp_4
   1632              {
   1633                uint8 options = 0;
   \   0000006E   0x2300             MOVS     R3,#+0
   1634                options |= ZDO_MGMT_RTG_ENTRY_MANYTOONE;
   \   00000070   0xF053 0x0302      ORRS     R3,R3,#0x2
   1635          
   1636                if ( RoutingTableList->options & ZP_RTG_RECORD )
   \   00000074   0xF892 0xC006      LDRB     R12,[R2, #+6]
   \   00000078   0xEA5F 0x7C4C      LSLS     R12,R12,#+29
   \   0000007C   0xD501             BPL.N    ??ZDP_MgmtRtgRsp_5
   1637                {
   1638                  options |= ZDO_MGMT_RTG_ENTRY_ROUTE_RECORD_REQUIRED;
   \   0000007E   0xF053 0x0304      ORRS     R3,R3,#0x4
   1639                }
   1640          
   1641                if ( RoutingTableList->options & ZP_MTO_ROUTE_NRC )
   \                     ??ZDP_MgmtRtgRsp_5: (+1)
   \   00000082   0xF892 0xC006      LDRB     R12,[R2, #+6]
   \   00000086   0xEA5F 0x6CCC      LSLS     R12,R12,#+27
   \   0000008A   0xD501             BPL.N    ??ZDP_MgmtRtgRsp_6
   1642                {
   1643                  options |= ZDO_MGMT_RTG_ENTRY_MEMORY_CONSTRAINED;
   \   0000008C   0xF053 0x0301      ORRS     R3,R3,#0x1
   1644                }
   1645          
   1646                *pBuf |= (options << 3);
   \                     ??ZDP_MgmtRtgRsp_6: (+1)
   \   00000090   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \   00000094   0xEA5C 0x03C3      ORRS     R3,R12,R3, LSL #+3
   \   00000098   0x700B             STRB     R3,[R1, #+0]
   1647              }
   1648              pBuf++;
   \                     ??ZDP_MgmtRtgRsp_4: (+1)
   \   0000009A   0x1C49             ADDS     R1,R1,#+1
   1649          
   1650              *pBuf++ = LO_UINT16( RoutingTableList->nextHopAddress );  // Next hop
   \   0000009C   0x8853             LDRH     R3,[R2, #+2]
   \   0000009E   0x700B             STRB     R3,[R1, #+0]
   \   000000A0   0x1C49             ADDS     R1,R1,#+1
   1651              *pBuf++ = HI_UINT16( RoutingTableList->nextHopAddress );
   \   000000A2   0x8853             LDRH     R3,[R2, #+2]
   \   000000A4   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A6   0x0A1B             LSRS     R3,R3,#+8
   \   000000A8   0x700B             STRB     R3,[R1, #+0]
   \   000000AA   0x1C49             ADDS     R1,R1,#+1
   1652              RoutingTableList++;    // Move to next list entry
   \   000000AC   0x3208             ADDS     R2,R2,#+8
   1653            }
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \                     ??ZDP_MgmtRtgRsp_2: (+1)
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B4   0x42A0             CMP      R0,R4
   \   000000B6   0xD3C8             BCC.N    ??ZDP_MgmtRtgRsp_3
   1654          
   1655            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Rtg_rsp, len, buf );
   \   000000B8   0x1C70             ADDS     R0,R6,#+1
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable34
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0x003B             MOVS     R3,R7
   \   000000C2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000C4   0xF248 0x0232      MOVW     R2,#+32818
   \   000000C8   0x0029             MOVS     R1,R5
   \   000000CA   0xA800             ADD      R0,SP,#+0
   \   000000CC   0x.... 0x....      BL       fillAndSend
   \   000000D0   0x0004             MOVS     R4,R0
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0x.... 0x....      BL       osal_mem_free
   \   000000D8   0x....             LDR.N    R0,??DataTable34_1
   \   000000DA   0x....             LDR.N    R1,??DataTable34
   \   000000DC   0x6008             STR      R0,[R1, #+0]
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??ZDP_MgmtRtgRsp_1: (+1)
   \   000000E2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1656          }
   1657          
   1658          /*********************************************************************
   1659           * @fn          ZDP_MgmtBindRsp
   1660           *
   1661           * @brief       This builds and send a Mgmt_Bind_rsp message. This
   1662           *              function sends a unicast message.
   1663           *
   1664           * @param       dstAddr - destination address of the message
   1665           * @param       Status - message status (ZDP_SUCCESS or other)
   1666           * @param       BindingTableEntries - Total number of entries
   1667           * @param       StartIndex - Starting index within the reporting list
   1668           * @param       BindingTableListCount - number of entries included
   1669           *                                 in this message
   1670           * @param       BindingTableList - List of Binding Table entries
   1671           * @param       SecurityEnable - Security Options
   1672           *
   1673           * @return      ZStatus_t
   1674           */

   \                                 In section .text, align 2, keep-with-next
   1675          ZStatus_t ZDP_MgmtBindRsp( byte TransSeq, zAddrType_t *dstAddr,
   1676                                      byte Status,
   1677                                      byte BindingTableEntries,
   1678                                      byte StartIndex,
   1679                                      byte BindingTableListCount,
   1680                                      apsBindingItem_t *BindingTableList,
   1681                                      byte SecurityEnable )
   1682          {
   \                     ZDP_MgmtBindRsp: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4691             MOV      R9,R2
   \   00000008   0x469A             MOV      R10,R3
   1683            uint8 *buf;
   1684            uint8 *pBuf;
   1685            uint8 maxLen; // maxLen is the maximum packet length to allocate enough memory space
   1686            uint8 len;    // Actual length varies due to different addrMode
   1687            uint8 x;
   1688            byte extZdpBindEntrySize = ZDP_BINDINGENTRY_SIZE + 1 + 1; // One more byte for cluserID and DstAddrMode
   \   0000000A   0x2715             MOVS     R7,#+21
   1689            byte shortZdpBindEntrySize = ZDP_BINDINGENTRY_SIZE + 1 + 1 + 2 - 8 - 1; // clusterID + DstAddrMode + shortAddr - ExtAddr - DstEndpoint
   \   0000000C   0xF05F 0x080E      MOVS     R8,#+14
   1690          
   1691            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1692          
   1693            // Status + BindingTableEntries + StartIndex + BindingTableListCount.
   1694            maxLen = 1 + 1 + 1 + 1;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0x9C0B             LDR      R4,[SP, #+44]
   1695            maxLen += (BindingTableListCount * extZdpBindEntrySize );  //max length
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001A   0xFB07 0x0004      MLA      R0,R7,R4,R0
   1696            buf = osal_mem_alloc( maxLen + 1 );  // +1 for transaction ID
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x.... 0x....      BL       osal_mem_alloc
   \   00000028   0x0006             MOVS     R6,R0
   1697          
   1698            if ( buf == NULL )
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD101             BNE.N    ??ZDP_MgmtBindRsp_0
   1699            {
   1700              return afStatus_MEM_FAIL;
   \   0000002E   0x2010             MOVS     R0,#+16
   \   00000030   0xE05F             B.N      ??ZDP_MgmtBindRsp_1
   1701            }
   1702          
   1703            pBuf = buf+1;
   \                     ??ZDP_MgmtBindRsp_0: (+1)
   \   00000032   0x1C70             ADDS     R0,R6,#+1
   1704          
   1705            *pBuf++ = Status;
   \   00000034   0xF880 0x9000      STRB     R9,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   1706            *pBuf++ = BindingTableEntries;
   \   0000003A   0xF880 0xA000      STRB     R10,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   1707            *pBuf++ = StartIndex;
   \   00000040   0x990A             LDR      R1,[SP, #+40]
   \   00000042   0x7001             STRB     R1,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   1708            *pBuf++ = BindingTableListCount;
   \   00000046   0x7004             STRB     R4,[R0, #+0]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   1709          
   1710            // Initial length = Status + BindingTableEntries + StartIndex + BindingTableListCount.
   1711            // length += ZDP_BINDINGENTRY_SIZE   -- Version 1.0
   1712            //           extZdpBindEntrySize     -- Version 1.1 extended address mode
   1713            //           shortZdpBindEntrySize   -- Version 1.1 group address mode
   1714          
   1715            len = 1 + 1 + 1 + 1;
   \   0000004A   0xF05F 0x0B04      MOVS     R11,#+4
   1716            for ( x = 0; x < BindingTableListCount; x++ )
   \   0000004E   0xF05F 0x0900      MOVS     R9,#+0
   \   00000052   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   \   00000056   0xE00F             B.N      ??ZDP_MgmtBindRsp_2
   1717            {
   1718              pBuf = osal_cpyExtAddr( pBuf, BindingTableList->srcAddr );
   1719              *pBuf++ = BindingTableList->srcEP;
   1720          
   1721              // Cluster ID
   1722              *pBuf++ = LO_UINT16( BindingTableList->clusterID );
   1723              *pBuf++ = HI_UINT16( BindingTableList->clusterID );
   1724          
   1725              *pBuf++ = BindingTableList->dstAddr.addrMode;
   1726              if ( BindingTableList->dstAddr.addrMode == Addr64Bit )
   1727              {
   1728                len += extZdpBindEntrySize;
   1729                pBuf = osal_cpyExtAddr( pBuf, BindingTableList->dstAddr.addr.extAddr );
   1730                *pBuf++ = BindingTableList->dstEP;
   1731              }
   1732              else
   1733              {
   1734                len += shortZdpBindEntrySize;
   \                     ??ZDP_MgmtBindRsp_3: (+1)
   \   00000058   0xEB18 0x0B0B      ADDS     R11,R8,R11
   1735                *pBuf++ = LO_UINT16( BindingTableList->dstAddr.addr.shortAddr );
   \   0000005C   0xF8BA 0x100C      LDRH     R1,[R10, #+12]
   \   00000060   0x7001             STRB     R1,[R0, #+0]
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   1736                *pBuf++ = HI_UINT16( BindingTableList->dstAddr.addr.shortAddr );
   \   00000064   0xF8BA 0x100C      LDRH     R1,[R10, #+12]
   \   00000068   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000006A   0x0A09             LSRS     R1,R1,#+8
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   1737              }
   1738              BindingTableList++;    // Move to next list entry
   \                     ??ZDP_MgmtBindRsp_4: (+1)
   \   00000070   0xF11A 0x0A18      ADDS     R10,R10,#+24
   \   00000074   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??ZDP_MgmtBindRsp_2: (+1)
   \   00000078   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x45A1             CMP      R9,R4
   \   00000080   0xD223             BCS.N    ??ZDP_MgmtBindRsp_5
   \   00000082   0x4651             MOV      R1,R10
   \   00000084   0x.... 0x....      BL       sAddrExtCpy
   \   00000088   0xF89A 0x1008      LDRB     R1,[R10, #+8]
   \   0000008C   0x7001             STRB     R1,[R0, #+0]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0xF8BA 0x100A      LDRH     R1,[R10, #+10]
   \   00000094   0x7001             STRB     R1,[R0, #+0]
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0xF8BA 0x100A      LDRH     R1,[R10, #+10]
   \   0000009C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009E   0x0A09             LSRS     R1,R1,#+8
   \   000000A0   0x7001             STRB     R1,[R0, #+0]
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0xF89A 0x1014      LDRB     R1,[R10, #+20]
   \   000000A8   0x7001             STRB     R1,[R0, #+0]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0xF89A 0x1014      LDRB     R1,[R10, #+20]
   \   000000B0   0x2903             CMP      R1,#+3
   \   000000B2   0xD1D1             BNE.N    ??ZDP_MgmtBindRsp_3
   \   000000B4   0xEB17 0x0B0B      ADDS     R11,R7,R11
   \   000000B8   0xF11A 0x010C      ADDS     R1,R10,#+12
   \   000000BC   0x.... 0x....      BL       sAddrExtCpy
   \   000000C0   0xF89A 0x1016      LDRB     R1,[R10, #+22]
   \   000000C4   0x7001             STRB     R1,[R0, #+0]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0xE7D2             B.N      ??ZDP_MgmtBindRsp_4
   1739            }
   1740          
   1741            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Bind_rsp, len, buf );
   \                     ??ZDP_MgmtBindRsp_5: (+1)
   \   000000CA   0x1C70             ADDS     R0,R6,#+1
   \   000000CC   0x....             LDR.N    R1,??DataTable34
   \   000000CE   0x6008             STR      R0,[R1, #+0]
   \   000000D0   0x465B             MOV      R3,R11
   \   000000D2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D4   0xF248 0x0233      MOVW     R2,#+32819
   \   000000D8   0x0029             MOVS     R1,R5
   \   000000DA   0xA800             ADD      R0,SP,#+0
   \   000000DC   0x.... 0x....      BL       fillAndSend
   \   000000E0   0x0004             MOVS     R4,R0
   \   000000E2   0x0030             MOVS     R0,R6
   \   000000E4   0x.... 0x....      BL       osal_mem_free
   \   000000E8   0x....             LDR.N    R0,??DataTable34_1
   \   000000EA   0x....             LDR.N    R1,??DataTable34
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??ZDP_MgmtBindRsp_1: (+1)
   \   000000F2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1742          }
   1743          
   1744          /*********************************************************************
   1745           * @fn          ZDP_MgmtNwkUpdateNotify
   1746           *
   1747           * @brief       This builds and send a Mgmt_NWK_Update_notify message. This
   1748           *              function sends a unicast message.
   1749           *
   1750           * @param       dstAddr - destination address of the message
   1751           * @param       status - message status (ZDP_SUCCESS or other)
   1752           * @param       scannedChannels - List of channels scanned by the request
   1753           * @param       totalTransmissions - Total transmissions
   1754           * @param       transmissionFailures - Sum of transmission failures
   1755           * @param       listCount - Number of records contained in the energyValues list
   1756           * @param       energyValues - List of descriptors, one for each of ListCount,
   1757           *                             of the enegry detect descriptors
   1758           * @param       txOptions - Transmit options
   1759           * @param       securityEnable - Security options
   1760           *
   1761           * @return      afStatus_t
   1762           */

   \                                 In section .text, align 2, keep-with-next
   1763          afStatus_t ZDP_MgmtNwkUpdateNotify( uint8 TransSeq, zAddrType_t *dstAddr,
   1764                                              uint8 status, uint32 scannedChannels,
   1765                                              uint16 totalTransmissions, uint16 transmissionFailures,
   1766                                              uint8 listCount, uint8 *energyValues, uint8 txOptions,
   1767                                              uint8 securityEnable )
   1768          {
   \                     ZDP_MgmtNwkUpdateNotify: (+1)
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4690             MOV      R8,R2
   \   00000008   0x4699             MOV      R9,R3
   \   0000000A   0x9C0A             LDR      R4,[SP, #+40]
   1769            uint8 *buf;
   1770            uint8 *pBuf;
   1771            uint8 len;
   1772          
   1773            (void)securityEnable;  // Intentionally unreferenced parameter
   1774          
   1775            // Status + ScannedChannels + totalTransmissions + transmissionFailures + ListCount + energyValues
   1776            len = 1 + 4 + 2 + 2 + 1 + listCount;
   \   0000000C   0xF114 0x060A      ADDS     R6,R4,#+10
   1777          
   1778            buf = osal_mem_alloc( len+1 ); // +1 for transaction ID
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x1C70             ADDS     R0,R6,#+1
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x.... 0x....      BL       osal_mem_alloc
   \   0000001A   0x0007             MOVS     R7,R0
   1779            if ( buf == NULL )
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD101             BNE.N    ??ZDP_MgmtNwkUpdateNotify_0
   1780            {
   1781              return afStatus_MEM_FAIL;
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0xE038             B.N      ??ZDP_MgmtNwkUpdateNotify_1
   1782            }
   1783          
   1784            pBuf = buf+1;
   \                     ??ZDP_MgmtNwkUpdateNotify_0: (+1)
   \   00000024   0x1C78             ADDS     R0,R7,#+1
   1785          
   1786            *pBuf++ = status;
   \   00000026   0xF880 0x8000      STRB     R8,[R0, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   1787          
   1788            pBuf = osal_buffer_uint32( pBuf, scannedChannels );
   \   0000002C   0x4649             MOV      R1,R9
   \   0000002E   0x.... 0x....      BL       osal_buffer_uint32
   \   00000032   0x9908             LDR      R1,[SP, #+32]
   1789          
   1790            *pBuf++ = LO_UINT16( totalTransmissions );
   \   00000034   0x7001             STRB     R1,[R0, #+0]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   1791            *pBuf++ = HI_UINT16( totalTransmissions );
   \   00000038   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003A   0x0A09             LSRS     R1,R1,#+8
   \   0000003C   0x7001             STRB     R1,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x9909             LDR      R1,[SP, #+36]
   1792          
   1793            *pBuf++ = LO_UINT16( transmissionFailures );
   \   00000042   0x7001             STRB     R1,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   1794            *pBuf++ = HI_UINT16( transmissionFailures );
   \   00000046   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000048   0x0A09             LSRS     R1,R1,#+8
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   1795          
   1796            *pBuf++ = listCount;
   \   0000004E   0x7004             STRB     R4,[R0, #+0]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   1797          
   1798            if ( listCount > 0 )
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C00             CMP      R4,#+0
   \   00000056   0xD004             BEQ.N    ??ZDP_MgmtNwkUpdateNotify_2
   1799              osal_memcpy( pBuf, energyValues, listCount );
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0x990B             LDR      R1,[SP, #+44]
   \   0000005E   0x.... 0x....      BL       osal_memcpy
   1800          
   1801            FillAndSendBufferTxOptions( &TransSeq, dstAddr, Mgmt_NWK_Update_notify, len, buf, txOptions );
   \                     ??ZDP_MgmtNwkUpdateNotify_2: (+1)
   \   00000062   0x1C78             ADDS     R0,R7,#+1
   \   00000064   0x....             LDR.N    R1,??DataTable34
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0x980C             LDR      R0,[SP, #+48]
   \   0000006A   0x....             LDR.N    R1,??DataTable34_2
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
   \   0000006E   0x0033             MOVS     R3,R6
   \   00000070   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000072   0xF248 0x0238      MOVW     R2,#+32824
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0xA800             ADD      R0,SP,#+0
   \   0000007A   0x.... 0x....      BL       fillAndSend
   \   0000007E   0x0004             MOVS     R4,R0
   \   00000080   0x0038             MOVS     R0,R7
   \   00000082   0x.... 0x....      BL       osal_mem_free
   \   00000086   0x....             LDR.N    R0,??DataTable34_1
   \   00000088   0x....             LDR.N    R1,??DataTable34
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x....             LDR.N    R1,??DataTable34_2
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??ZDP_MgmtNwkUpdateNotify_1: (+1)
   \   00000096   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1802          }
   1803          
   1804          /*********************************************************************
   1805           * Functions to register for ZDO Over-the-air messages
   1806           */
   1807          
   1808          /*********************************************************************
   1809           * @fn          ZDO_RegisterForZDOMsg
   1810           *
   1811           * @brief       Call this function to register of an incoming over
   1812           *              the air ZDO message - probably a response message
   1813           *              but requests can also be received.
   1814           *              Messages are delivered to the task with ZDO_CB_MSG
   1815           *              as the message ID.
   1816           *
   1817           * @param       taskID - Where you would like the message delivered
   1818           * @param       clusterID - What message?
   1819           *                          ZDO_ALL_MSGS_CLUSTERID - all responses
   1820           *                          and device announce
   1821           *
   1822           * @return      ZSuccess - successful, ZMemError if not
   1823           */

   \                                 In section .text, align 2, keep-with-next
   1824          ZStatus_t ZDO_RegisterForZDOMsg( uint8 taskID, uint16 clusterID )
   1825          {
   \                     ZDO_RegisterForZDOMsg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1826            ZDO_MsgCB_t *pList;
   1827            ZDO_MsgCB_t *pLast;
   1828            ZDO_MsgCB_t *pNew;
   1829          
   1830            // Look for duplicate
   1831            pList = pLast = zdoMsgCBs;
   \   00000006   0x....             LDR.N    R0,??DataTable34_3
   \   00000008   0x6806             LDR      R6,[R0, #+0]
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0xE001             B.N      ??ZDO_RegisterForZDOMsg_0
   1832            while ( pList )
   1833            {
   1834              if ( pList->taskID == taskID && pList->clusterID == clusterID )
   1835                return ( ZSuccess );
   1836              pLast = pList;
   \                     ??ZDO_RegisterForZDOMsg_1: (+1)
   \   0000000E   0x0006             MOVS     R6,R0
   1837              pList = (ZDO_MsgCB_t *)pList->next;
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \                     ??ZDO_RegisterForZDOMsg_0: (+1)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD009             BEQ.N    ??ZDO_RegisterForZDOMsg_2
   \   00000016   0x7901             LDRB     R1,[R0, #+4]
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x42A1             CMP      R1,R4
   \   0000001C   0xD1F7             BNE.N    ??ZDO_RegisterForZDOMsg_1
   \   0000001E   0x88C1             LDRH     R1,[R0, #+6]
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xD1F3             BNE.N    ??ZDO_RegisterForZDOMsg_1
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE013             B.N      ??ZDO_RegisterForZDOMsg_3
   1838            }
   1839          
   1840            // Add to the list
   1841            pNew = (ZDO_MsgCB_t *)osal_mem_alloc( sizeof ( ZDO_MsgCB_t ) );
   \                     ??ZDO_RegisterForZDOMsg_2: (+1)
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0x.... 0x....      BL       osal_mem_alloc
   1842            if ( pNew )
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00D             BEQ.N    ??ZDO_RegisterForZDOMsg_4
   1843            {
   1844              pNew->taskID = taskID;
   \   00000034   0x7104             STRB     R4,[R0, #+4]
   1845              pNew->clusterID = clusterID;
   \   00000036   0x80C5             STRH     R5,[R0, #+6]
   1846              pNew->next = NULL;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   1847              if ( zdoMsgCBs )
   \   0000003C   0x....             LDR.N    R1,??DataTable34_3
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD001             BEQ.N    ??ZDO_RegisterForZDOMsg_5
   1848              {
   1849                pLast->next = pNew;
   \   00000044   0x6030             STR      R0,[R6, #+0]
   \   00000046   0xE001             B.N      ??ZDO_RegisterForZDOMsg_6
   1850              }
   1851              else
   1852                zdoMsgCBs = pNew;
   \                     ??ZDO_RegisterForZDOMsg_5: (+1)
   \   00000048   0x....             LDR.N    R1,??DataTable34_3
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1853              return ( ZSuccess );
   \                     ??ZDO_RegisterForZDOMsg_6: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE000             B.N      ??ZDO_RegisterForZDOMsg_3
   1854            }
   1855            else
   1856              return ( ZMemError );
   \                     ??ZDO_RegisterForZDOMsg_4: (+1)
   \   00000050   0x2010             MOVS     R0,#+16
   \                     ??ZDO_RegisterForZDOMsg_3: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1857          }
   1858          
   1859          /*********************************************************************
   1860           * @fn          ZDO_RemoveRegisteredCB
   1861           *
   1862           * @brief       Call this function if you don't want to receive the
   1863           *              incoming message.
   1864           *
   1865           * @param       taskID - Where the messages are being delivered.
   1866           * @param       clusterID - What message?
   1867           *
   1868           * @return      ZSuccess - successful, ZFailure if not found
   1869           */

   \                                 In section .text, align 2, keep-with-next
   1870          ZStatus_t ZDO_RemoveRegisteredCB( uint8 taskID, uint16 clusterID )
   1871          {
   \                     ZDO_RemoveRegisteredCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1872            ZDO_MsgCB_t *pList;
   1873            ZDO_MsgCB_t *pLast = NULL;
   \   00000002   0x2300             MOVS     R3,#+0
   1874          
   1875            pList = zdoMsgCBs;
   \   00000004   0x....             LDR.N    R2,??DataTable34_3
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xE001             B.N      ??ZDO_RemoveRegisteredCB_0
   1876            while ( pList )
   1877            {
   1878              if ( pList->taskID == taskID && pList->clusterID == clusterID )
   1879              {
   1880                if ( pLast )
   1881                {
   1882                  // remove this one from the linked list
   1883                  pLast->next = pList->next;
   1884                }
   1885                else if ( pList->next )
   1886                {
   1887                  // remove the first one from the linked list
   1888                  zdoMsgCBs = pList->next;
   1889                }
   1890                else
   1891                {
   1892                  // remove the only item from the list
   1893                  zdoMsgCBs = (ZDO_MsgCB_t *)NULL;
   1894                }
   1895                osal_mem_free( pList );
   1896                return ( ZSuccess );
   1897              }
   1898              pLast = pList;
   \                     ??ZDO_RemoveRegisteredCB_1: (+1)
   \   0000000A   0x0013             MOVS     R3,R2
   1899              pList = pList->next;
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \                     ??ZDO_RemoveRegisteredCB_0: (+1)
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD01B             BEQ.N    ??ZDO_RemoveRegisteredCB_2
   \   00000012   0x7914             LDRB     R4,[R2, #+4]
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD1F7             BNE.N    ??ZDO_RemoveRegisteredCB_1
   \   0000001A   0x88D4             LDRH     R4,[R2, #+6]
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x428C             CMP      R4,R1
   \   00000020   0xD1F3             BNE.N    ??ZDO_RemoveRegisteredCB_1
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD002             BEQ.N    ??ZDO_RemoveRegisteredCB_3
   \   00000026   0x6810             LDR      R0,[R2, #+0]
   \   00000028   0x6018             STR      R0,[R3, #+0]
   \   0000002A   0xE009             B.N      ??ZDO_RemoveRegisteredCB_4
   \                     ??ZDO_RemoveRegisteredCB_3: (+1)
   \   0000002C   0x6810             LDR      R0,[R2, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??ZDO_RemoveRegisteredCB_5
   \   00000032   0x6810             LDR      R0,[R2, #+0]
   \   00000034   0x....             LDR.N    R1,??DataTable34_3
   \   00000036   0x6008             STR      R0,[R1, #+0]
   \   00000038   0xE002             B.N      ??ZDO_RemoveRegisteredCB_4
   \                     ??ZDO_RemoveRegisteredCB_5: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable34_3
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \                     ??ZDO_RemoveRegisteredCB_4: (+1)
   \   00000040   0x0010             MOVS     R0,R2
   \   00000042   0x.... 0x....      BL       osal_mem_free
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE000             B.N      ??ZDO_RemoveRegisteredCB_6
   1900            }
   1901          
   1902            return ( ZFailure );
   \                     ??ZDO_RemoveRegisteredCB_2: (+1)
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??ZDO_RemoveRegisteredCB_6: (+1)
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
   1903          }
   1904          
   1905          /*********************************************************************
   1906           * @fn          ZDO_SendMsgCBs
   1907           *
   1908           * @brief       This function sends messages to registered tasks.
   1909           *              Local to ZDO and shouldn't be called outside of ZDO.
   1910           *
   1911           * @param       inMsg - incoming message
   1912           *
   1913           * @return      TRUE if sent to at least 1 task, FALSE if not
   1914           */

   \                                 In section .text, align 2, keep-with-next
   1915          uint8 ZDO_SendMsgCBs( zdoIncomingMsg_t *inMsg )
   1916          {
   \                     ZDO_SendMsgCBs: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1917            uint8 ret = FALSE;
   \   00000004   0x2500             MOVS     R5,#+0
   1918            ZDO_MsgCB_t *pList = zdoMsgCBs;
   \   00000006   0x....             LDR.N    R0,??DataTable34_3
   \   00000008   0x6806             LDR      R6,[R0, #+0]
   \   0000000A   0xE02E             B.N      ??ZDO_SendMsgCBs_0
   1919            while ( pList )
   1920            {
   1921              if ( (pList->clusterID == inMsg->clusterID)
   1922                 || ((pList->clusterID == ZDO_ALL_MSGS_CLUSTERID)
   1923                     && ((inMsg->clusterID & ZDO_RESPONSE_BIT) || (inMsg->clusterID == Device_annce))) )
   \                     ??ZDO_SendMsgCBs_1: (+1)
   \   0000000C   0x88F0             LDRH     R0,[R6, #+6]
   \   0000000E   0x89E1             LDRH     R1,[R4, #+14]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD00A             BEQ.N    ??ZDO_SendMsgCBs_2
   \   00000014   0x88F0             LDRH     R0,[R6, #+6]
   \   00000016   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD124             BNE.N    ??ZDO_SendMsgCBs_3
   \   0000001E   0x89E0             LDRH     R0,[R4, #+14]
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0xD402             BMI.N    ??ZDO_SendMsgCBs_2
   \   00000024   0x89E0             LDRH     R0,[R4, #+14]
   \   00000026   0x2813             CMP      R0,#+19
   \   00000028   0xD11E             BNE.N    ??ZDO_SendMsgCBs_3
   1924              {
   1925                zdoIncomingMsg_t *msgPtr;
   1926          
   1927                // Send the address to the task
   1928                msgPtr = (zdoIncomingMsg_t *)osal_msg_allocate( sizeof( zdoIncomingMsg_t ) + inMsg->asduLen );
   \                     ??ZDO_SendMsgCBs_2: (+1)
   \   0000002A   0x7CA0             LDRB     R0,[R4, #+18]
   \   0000002C   0x3020             ADDS     R0,R0,#+32
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0x.... 0x....      BL       osal_msg_allocate
   \   00000034   0x0007             MOVS     R7,R0
   1929                if ( msgPtr )
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD016             BEQ.N    ??ZDO_SendMsgCBs_3
   1930                {
   1931                  // copy struct
   1932                  osal_memcpy( msgPtr, inMsg, sizeof( zdoIncomingMsg_t ));
   \   0000003A   0x2220             MOVS     R2,#+32
   \   0000003C   0x0021             MOVS     R1,R4
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x.... 0x....      BL       osal_memcpy
   1933          
   1934                  if ( inMsg->asduLen )
   \   00000044   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD007             BEQ.N    ??ZDO_SendMsgCBs_4
   1935                  {
   1936                    msgPtr->asdu = (byte*)(((byte*)msgPtr) + sizeof( zdoIncomingMsg_t ));
   \   0000004A   0xF117 0x0020      ADDS     R0,R7,#+32
   \   0000004E   0x61B8             STR      R0,[R7, #+24]
   1937                    osal_memcpy( msgPtr->asdu, inMsg->asdu, inMsg->asduLen );
   \   00000050   0x7CA2             LDRB     R2,[R4, #+18]
   \   00000052   0x69A1             LDR      R1,[R4, #+24]
   \   00000054   0x69B8             LDR      R0,[R7, #+24]
   \   00000056   0x.... 0x....      BL       osal_memcpy
   1938                  }
   1939          
   1940                  msgPtr->hdr.event = ZDO_CB_MSG;
   \                     ??ZDO_SendMsgCBs_4: (+1)
   \   0000005A   0x20D3             MOVS     R0,#+211
   \   0000005C   0x7038             STRB     R0,[R7, #+0]
   1941                  osal_msg_send( pList->taskID, (uint8 *)msgPtr );
   \   0000005E   0x0039             MOVS     R1,R7
   \   00000060   0x7930             LDRB     R0,[R6, #+4]
   \   00000062   0x.... 0x....      BL       osal_msg_send
   1942                  ret = TRUE;
   \   00000066   0x2501             MOVS     R5,#+1
   1943                }
   1944              }
   1945              pList = (ZDO_MsgCB_t *)pList->next;
   \                     ??ZDO_SendMsgCBs_3: (+1)
   \   00000068   0x6836             LDR      R6,[R6, #+0]
   1946            }
   \                     ??ZDO_SendMsgCBs_0: (+1)
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD1CE             BNE.N    ??ZDO_SendMsgCBs_1
   1947            return ( ret );
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1948          }
   1949          
   1950          /*********************************************************************
   1951           * Incoming message processor
   1952           */
   1953          
   1954          /*********************************************************************
   1955           * @fn          ZDP_IncomingData
   1956           *
   1957           * @brief       This function indicates the transfer of a data PDU (ASDU)
   1958           *              from the APS sub-layer to the ZDO.
   1959           *
   1960           * @param       pData - Incoming Message
   1961           *
   1962           * @return      none
   1963           */

   \                                 In section .text, align 2, keep-with-next
   1964          void ZDP_IncomingData( afIncomingMSGPacket_t *pData )
   1965          {
   \                     ZDP_IncomingData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1966            uint8 x = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   1967            uint8 handled;
   1968            zdoIncomingMsg_t inMsg;
   1969          
   1970            inMsg.srcAddr.addrMode = Addr16Bit;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0xF88D 0x100A      STRB     R1,[SP, #+10]
   1971            inMsg.srcAddr.addr.shortAddr = pData->srcAddr.addr.shortAddr;
   \   0000000C   0x88C1             LDRH     R1,[R0, #+6]
   \   0000000E   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   1972            inMsg.wasBroadcast = pData->wasBroadcast;
   \   00000012   0x7D41             LDRB     R1,[R0, #+21]
   \   00000014   0xF88D 0x100C      STRB     R1,[SP, #+12]
   1973            inMsg.clusterID = pData->clusterId;
   \   00000018   0x8881             LDRH     R1,[R0, #+4]
   \   0000001A   0xF8AD 0x100E      STRH     R1,[SP, #+14]
   1974            inMsg.SecurityUse = pData->SecurityUse;
   \   0000001E   0x7E41             LDRB     R1,[R0, #+25]
   \   00000020   0xF88D 0x1010      STRB     R1,[SP, #+16]
   1975          
   1976            inMsg.asduLen = pData->cmd.DataLength-1;
   \   00000024   0x8CC1             LDRH     R1,[R0, #+38]
   \   00000026   0x1E49             SUBS     R1,R1,#+1
   \   00000028   0xF88D 0x1012      STRB     R1,[SP, #+18]
   1977            inMsg.asdu = pData->cmd.Data+1;
   \   0000002C   0x6A81             LDR      R1,[R0, #+40]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x9106             STR      R1,[SP, #+24]
   1978            inMsg.TransSeq = pData->cmd.Data[0];
   \   00000032   0x6A81             LDR      R1,[R0, #+40]
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0xF88D 0x1011      STRB     R1,[SP, #+17]
   1979            inMsg.macDestAddr = pData->macDestAddr;
   \   0000003A   0x8A41             LDRH     R1,[R0, #+18]
   \   0000003C   0xF8AD 0x1014      STRH     R1,[SP, #+20]
   1980            inMsg.macSrcAddr = pData->macSrcAddr;
   \   00000040   0x8D80             LDRH     R0,[R0, #+44]
   \   00000042   0xF8AD 0x001C      STRH     R0,[SP, #+28]
   1981          
   1982            handled = ZDO_SendMsgCBs( &inMsg );
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       ZDO_SendMsgCBs
   \   0000004C   0xE000             B.N      ??ZDP_IncomingData_0
   1983          
   1984          #if (defined MT_ZDO_CB_FUNC)
   1985          #if !defined MT_TASK
   1986            if (zgZdoDirectCB)
   1987          #endif
   1988            {
   1989              MT_ZdoDirectCB( pData, &inMsg );
   1990            }
   1991          #endif
   1992          
   1993            while ( zdpMsgProcs[x].clusterID != 0xFFFF )
   1994            {
   1995              if ( zdpMsgProcs[x].clusterID == inMsg.clusterID )
   1996              {
   1997                zdpMsgProcs[x].pFn( &inMsg );
   1998                return;
   1999              }
   2000              x++;
   \                     ??ZDP_IncomingData_1: (+1)
   \   0000004E   0x1C64             ADDS     R4,R4,#+1
   \                     ??ZDP_IncomingData_0: (+1)
   \   00000050   0x....             LDR.N    R1,??DataTable34_4
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0xF831 0x1034      LDRH     R1,[R1, R4, LSL #+3]
   \   00000058   0xF64F 0x72FF      MOVW     R2,#+65535
   \   0000005C   0x4291             CMP      R1,R2
   \   0000005E   0xD00F             BEQ.N    ??ZDP_IncomingData_2
   \   00000060   0x....             LDR.N    R1,??DataTable34_4
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0xF831 0x1034      LDRH     R1,[R1, R4, LSL #+3]
   \   00000068   0xF8BD 0x200E      LDRH     R2,[SP, #+14]
   \   0000006C   0x4291             CMP      R1,R2
   \   0000006E   0xD1EE             BNE.N    ??ZDP_IncomingData_1
   \   00000070   0xA800             ADD      R0,SP,#+0
   \   00000072   0x....             LDR.N    R1,??DataTable34_4
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0xEB11 0x01C4      ADDS     R1,R1,R4, LSL #+3
   \   0000007A   0x6849             LDR      R1,[R1, #+4]
   \   0000007C   0x4788             BLX      R1
   \   0000007E   0xE005             B.N      ??ZDP_IncomingData_3
   2001            }
   2002          
   2003            // Handle unhandled messages
   2004            if ( !handled )
   \                     ??ZDP_IncomingData_2: (+1)
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD102             BNE.N    ??ZDP_IncomingData_4
   2005              ZDApp_InMsgCB( &inMsg );
   \   00000086   0xA800             ADD      R0,SP,#+0
   \   00000088   0x.... 0x....      BL       ZDApp_InMsgCB
   2006          }
   \                     ??ZDP_IncomingData_4: (+1)
   \                     ??ZDP_IncomingData_3: (+1)
   \   0000008C   0xB008             ADD      SP,SP,#+32
   \   0000008E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     ZDP_AF_ENDPOINT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     ZDP_TmpBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     ZDP_TxOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     ZDApp_epDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x........         DC32     ZDP_TransID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     saveExtAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x........         DC32     ZDAppNwkAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     ZDP_TransID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x........         DC32     ZDP_TmpBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x........         DC32     ZDP_Buf+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x........         DC32     ZDP_TxOptions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x........         DC32     zdoMsgCBs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_4:
   \   00000000   0x........         DC32     zdpMsgProcs
   2007          
   2008          /*********************************************************************
   2009          *********************************************************************/
   2010          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ZDO_RegisterForZDOMsg
        16   -> osal_mem_alloc
       8   ZDO_RemoveRegisteredCB
         8   -> osal_mem_free
      24   ZDO_SendMsgCBs
        24   -> osal_memcpy
        24   -> osal_msg_allocate
        24   -> osal_msg_send
      24   ZDP_BindUnbindReq
        24   -> fillAndSend
        24   -> sAddrExtCpy
      24   ZDP_DeviceAnnce
        24   -> fillAndSend
        24   -> sAddrExtCpy
      24   ZDP_EPRsp
        24   -> fillAndSend
        24   -> osal_memcpy
      40   ZDP_EndDeviceBindReq
        40   -> NLME_GetExtAddr
        40   -> NLME_GetShortAddr
        40   -> fillAndSend
        40   -> sAddrExtCpy
      24   ZDP_EndDeviceTimeoutReq
        24   -> fillAndSend
        24   -> sAddrExtCpy
       8   ZDP_GenericRsp
         8   -> fillAndSend
      24   ZDP_IEEEAddrReq
        24   -> fillAndSend
      40   ZDP_IncomingData
        40   -- Indirect call
        40   -> ZDApp_InMsgCB
        40   -> ZDO_SendMsgCBs
      24   ZDP_MatchDescReq
        24   -> fillAndSend
      40   ZDP_MgmtBindRsp
        40   -> fillAndSend
        40   -> osal_mem_alloc
        40   -> osal_mem_free
        40   -> sAddrExtCpy
      16   ZDP_MgmtDirectJoinReq
        16   -> fillAndSend
        16   -> sAddrExtCpy
      16   ZDP_MgmtLeaveReq
        16   -> fillAndSend
        16   -> sAddrExtCpy
      40   ZDP_MgmtLqiRsp
        40   -> fillAndSend
        40   -> osal_mem_alloc
        40   -> osal_mem_free
        40   -> sAddrExtCpy
      24   ZDP_MgmtNwkDiscReq
        24   -> fillAndSend
        24   -> osal_buffer_uint32
      40   ZDP_MgmtNwkDiscRsp
        40   -> fillAndSend
        40   -> osal_mem_alloc
        40   -> osal_mem_free
        40   -> sAddrExtCpy
      32   ZDP_MgmtNwkUpdateNotify
        32   -> fillAndSend
        32   -> osal_buffer_uint32
        32   -> osal_mem_alloc
        32   -> osal_mem_free
        32   -> osal_memcpy
      24   ZDP_MgmtNwkUpdateReq
        24   -> fillAndSend
        24   -> osal_buffer_uint32
       8   ZDP_MgmtPermitJoinReq
         8   -> fillAndSend
      32   ZDP_MgmtRtgRsp
        32   -> fillAndSend
        32   -> osal_mem_alloc
        32   -> osal_mem_free
       8   ZDP_NWKAddrOfInterestReq
         8   -> fillAndSend
      16   ZDP_NodeDescMsg
        16   -> fillAndSend
      40   ZDP_NwkAddrReq
        40   -> fillAndSend
        40   -> sAddrExtCmp
        40   -> sAddrExtCpy
      16   ZDP_PowerDescMsg
        16   -> fillAndSend
      24   ZDP_SendData
        24   -> fillAndSend
      16   ZDP_ServerDiscReq
        16   -> fillAndSend
      16   ZDP_ServerDiscRsp
        16   -> fillAndSend
      16   ZDP_SimpleDescMsg
        16   -> fillAndSend
       8   ZDP_SimpleDescReq
         8   -> fillAndSend
      16   ZDP_UserDescRsp
        16   -> fillAndSend
        16   -> osal_memcpy
      16   ZDP_UserDescSet
        16   -> fillAndSend
        16   -> osal_memcpy
        16   -> osal_memset
      48   fillAndSend
        48   -> AF_DataRequest
        48   -> osal_memset
      24   zdpProcessAddrReq
        24   -> fillAndSend
        24   -> sAddrExtCmp
        24   -> sAddrExtCpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable32
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
      84  ZDO_RegisterForZDOMsg
      78  ZDO_RemoveRegisteredCB
     116  ZDO_SendMsgCBs
       1  ZDP_AF_ENDPOINT
     160  ZDP_BindUnbindReq
      80  ZDP_Buf
      82  ZDP_DeviceAnnce
     104  ZDP_EPRsp
     266  ZDP_EndDeviceBindReq
      64  ZDP_EndDeviceTimeoutReq
      54  ZDP_GenericRsp
      56  ZDP_IEEEAddrReq
     144  ZDP_IncomingData
     218  ZDP_MatchDescReq
     246  ZDP_MgmtBindRsp
      36  ZDP_MgmtDirectJoinReq
      84  ZDP_MgmtLeaveReq
     310  ZDP_MgmtLqiRsp
      42  ZDP_MgmtNwkDiscReq
     272  ZDP_MgmtNwkDiscRsp
     154  ZDP_MgmtNwkUpdateNotify
      96  ZDP_MgmtNwkUpdateReq
      30  ZDP_MgmtPermitJoinReq
     230  ZDP_MgmtRtgRsp
      40  ZDP_NWKAddrOfInterestReq
     162  ZDP_NodeDescMsg
     108  ZDP_NwkAddrReq
      82  ZDP_PowerDescMsg
      76  ZDP_SendData
      82  ZDP_ServerDiscReq
      62  ZDP_ServerDiscRsp
     262  ZDP_SimpleDescMsg
      46  ZDP_SimpleDescReq
       4  ZDP_TmpBuf
       1  ZDP_TransID
       1  ZDP_TxOptions
      66  ZDP_UserDescRsp
      86  ZDP_UserDescSet
     104  fillAndSend
       4  zdoMsgCBs
      56  zdpMsgProcs
     238  zdpProcessAddrReq

 
    86 bytes in section .bss
     4 bytes in section .data
    57 bytes in section .rodata
 4 392 bytes in section .text
 
 4 392 bytes of CODE  memory
    57 bytes of CONST memory
    90 bytes of DATA  memory

Errors: none
Warnings: none
