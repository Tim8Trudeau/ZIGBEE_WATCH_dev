###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        06/Aug/2015  22:29:12
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\EverWrist_uart_isr.c
#    Command line =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\EverWrist_uart_isr.c
#        -D EVERWRIST -D FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D
#        xPOWER_SAVING -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC
#        -D LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Projects\zstack\ZMain\TI2538DB\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\" -I "C:\Texas Instruments\Z-Stack
#        Mesh 1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -I
#        "C:\Texas
#        Instruments\cc2538_foundation_firmware_1_0_1_0\driverlib\cc2538\source\"
#        -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\EverWrist_uart_isr.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\EverWrist_uart_isr.o
#
###############################################################################

C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\EverWrist_uart_isr.c
      1          /********************************************************************
      2           *     program:  EverWrist_uart_isr.c
      3           *      Project: Zigbee Watch
      4           *     Version:  0.0.1 -- phase 1
      5           *   Copyright:  2014, Barron Associates
      6           *     Written:  Wednesday, March 18, 2015
      7           *      Author:  Tim Trudeau - Timware
      8           *   Processor:  TI CC2538
      9           *        Tool:  IAR Embedded Workbench
     10           *
     11           *-------------------------------------------------------------------
     12           * /brief This contains the interface to the UARTs.
     13           * The CP2102 USB to UART converter is assigned to UART0
     14           * The serial channel to the MSP processor is assinged to UART1
     15           *******************************************************************/
     16          
     17          
     18          /* ------------------------------------------------------------------------------------------------
     19           *                                          Includes
     20           * ------------------------------------------------------------------------------------------------
     21           */
     22          #include "hal_board.h"
     23          #include "hal_types.h"
     24          #include "OSAL.h"
     25          #include "OSAL_Timers.h"
     26          #include "ioc.h"
     27          #include "hw_ioc.h"
     28          #include "hw_uart.h"
     29          #include "hal_uart.h"
     30          #include "EverWrist_bsp.h"
     31          #include "WatchApp.h"
     32          
     33          /* ------------------------------------------------------------------------------------------------
     34           *                                           Constants
     35           * ------------------------------------------------------------------------------------------------
     36           */
     37          #define CP2102_UART_BASE          UART0_BASE
     38          #define MSP_UART_BASE             UART1_BASE
     39          #define CP2102_UART_SYS_CTRL      SYS_CTRL_PERIPH_UART0
     40          #define MSP_UART_SYS_CTRL         SYS_CTRL_PERIPH_UART1
     41          #define UART0                     0
     42          #define UART1                     1
     43          
     44          /* ------------------------------------------------------------------------------------------------
     45           *                                           Local Variables
     46           * ------------------------------------------------------------------------------------------------
     47           */
     48          

   \                                 In section .rodata, align 4
     49          const uint32 UBRRTable[] = {
   \                     UBRRTable:
   \   00000000   0x00002580         DC32 9600, 19200, 38400, 57600, 115200
   \              0x00004B00   
   \              0x00009600   
   \              0x0000E100   
   \              0x0001C200   
     50            9600,
     51            19200,
     52            38400,
     53            57600,
     54            115200
     55          };
     56          

   \                                 In section .bss, align 4
     57          static halUARTCfg_t CP2102_Record;
   \                     CP2102_Record:
   \   00000000                      DS8 44

   \                                 In section .bss, align 4
     58          static halUARTCfg_t MSP_Record;
   \                     MSP_Record:
   \   00000000                      DS8 44
     59          
     60          /* ------------------------------------------------------------------------------------------------
     61           *                                           Local Functions
     62           * ------------------------------------------------------------------------------------------------
     63           */
     64          static void recRst(halUARTCfg_t* config);
     65          static void procRx(uint8 port);
     66          static void procTx(uint8 port);
     67          
     68          void    HalUARTInitIsr(void);
     69          uint8   HalUARTOpenIsr(uint8 port, halUARTCfg_t* config);
     70          void    HalUARTCloseIsr(uint8 port);
     71          uint16  HalUARTReadIsr ( uint8 port, uint8* pBuffer, uint16 length );
     72          uint16  HalUARTWriteIsr(uint8 port, uint8* pBuffer, uint16 length);
     73          uint16  Hal_UART_RxBufLenIsr(uint8 port);
     74          
     75          void    interrupt_uart0(void);
     76          void    interrupt_uart1(void);
     77          void    CP2102_Message_Handler  (uint8 port, uint8 event);
     78          void    MSP_Message_Handler(uint8 port, uint8 event);
     79          
     80          /* ------------------------------------------------------------------------------------------------
     81           *                                           Global Functions
     82           * ------------------------------------------------------------------------------------------------
     83           */
     84          
     85           
     86          /* ------------------------------------------------------------------------------------------------
     87           *                                           Global Varables
     88           * ------------------------------------------------------------------------------------------------
     89           */
     90          
     91          /*************************************************************************************************
     92           * @fn      HalUARTInitIsr()
     93           *
     94           * @brief   Initialize both UARTs using the same port configuration parameters. UART0 is assigned 
     95           *          to the MSP processor. UART 1 is for the USB serial port.
     96           * Note:    HalUARTOpen redirects to HalUARTOpenIsr. HalUARTOpen is called here because the stack may also call it.     
     97           *
     98           * @param   none
     99           *
    100           * @return  none
    101           *
    102           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    103          void HalUARTInitIsr(void)
    104          {
   \                     HalUARTInitIsr: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    105            halUARTCfg_t uartConfig;
    106          
    107            /* UART Configuration */
    108            uartConfig.configured           = TRUE;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    109            uartConfig.baudRate             = UART_SEL_BAUD;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    110            uartConfig.flowControl          = UART_OVERFLOW;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
    111            uartConfig.flowControlThreshold = UART_THRESHOLD;
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    112            uartConfig.rx.maxBufSize        = UART_RX_BUFF_MAX;
   \   0000001C   0x2040             MOVS     R0,#+64
   \   0000001E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    113            uartConfig.tx.maxBufSize        = UART_TX_BUFF_MAX;
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    114            uartConfig.idleTimeout          = UART_IDLE_TIMEOUT;
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    115            uartConfig.intEnable            = TRUE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0020      STRB     R0,[SP, #+32]
    116          
    117            /* Start both UARTs */
    118            uartConfig.callBackFunc         = CP2102_Message_Handler;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000038   0x900A             STR      R0,[SP, #+40]
    119            HalUARTOpen (UART1, &uartConfig);
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       HalUARTOpen
    120            //Uart 0 is for the MSP
    121            uartConfig.callBackFunc         = MSP_Message_Handler;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000046   0x900A             STR      R0,[SP, #+40]
    122            HalUARTOpen (UART0, &uartConfig);
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       HalUARTOpen
    123          
    124          }
   \   00000050   0xB00B             ADD      SP,SP,#+44
   \   00000052   0xBD00             POP      {PC}             ;; return
    125          
    126          /*************************************************************************************************
    127           * @fn      HalUARTOpenIsr()
    128           *
    129           * @brief   Open a port based on the configuration
    130           *
    131           * @param   port   - UART port
    132           *          config - contains configuration information
    133           *          cBack  - Call back function where events will be reported back
    134           *
    135           * @return  Status of the function call
    136           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          uint8 HalUARTOpenIsr(uint8 port, halUARTCfg_t* config)
    138          {
   \                     HalUARTOpenIsr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000C             MOVS     R4,R1
    139            uint32_t      interrupt_assignment;
    140            uint32_t      HAL_UART_port;
    141            halUARTCfg_t* uartRecord;
    142          
    143            if (port == UART1) {
   \   00000008   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000000C   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000010   0xD12B             BNE.N    ??HalUARTOpenIsr_0
    144            /* PA7 as CP2102_UART_RTS  
    145             * PA0 as CP2102_UART_TX and PA1 as CP2102_UART_RX
    146             * CTS, RTS, TX and RX are with respest to the CP2102 thus opposite on the CC2538
    147             */ 
    148                uartRecord = &CP2102_Record;
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable10_2
    149                interrupt_assignment = INT_UART1;
   \   00000016   0x2716             MOVS     R7,#+22
    150                IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_1, IOC_MUX_OUT_SEL_UART1_TXD);
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x2102             MOVS     R1,#+2
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000020   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    151                IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_7, IOC_MUX_OUT_SEL_UART1_RTS);
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   0000002C   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    152                IOCPinConfigPeriphInput(GPIO_A_BASE, GPIO_PIN_0, IOC_UARTRXD_UART1);
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable10_4  ;; 0x400d4108
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   0000003A   0x.... 0x....      BL       IOCPinConfigPeriphInput
    153                GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_1);    
   \   0000003E   0x2102             MOVS     R1,#+2
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000044   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    154                GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_7);    
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   0000004E   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    155                GPIOPinTypeUARTInput(GPIO_A_BASE, GPIO_PIN_0);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000058   0x.... 0x....      BL       GPIOPinTypeUARTInput
    156                HAL_UART_port = CP2102_UART_BASE;
   \   0000005C   0x.... 0x....      LDR.W    R5,??DataTable10_5  ;; 0x4000c000
    157                SysCtrlPeripheralEnable(SYS_CTRL_PERIPH_UART0);
   \   00000060   0xF44F 0x7000      MOV      R0,#+512
   \   00000064   0x.... 0x....      BL       SysCtrlPeripheralEnable
   \   00000068   0xE01C             B.N      ??HalUARTOpenIsr_1
    158            }else{
    159             /* PA3 as MSP_UART_TX and PA4 as MSP_UART_RX
    160             * TX and RX are with respest to the MSP thus opposite on the CC2538
    161             */ 
    162                uartRecord = &MSP_Record;
   \                     ??HalUARTOpenIsr_0: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R6,??DataTable10_6
    163                interrupt_assignment = INT_UART0;
   \   0000006E   0x2715             MOVS     R7,#+21
    164                IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_4, IOC_MUX_OUT_SEL_UART0_TXD);
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x2110             MOVS     R1,#+16
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000078   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    165                IOCPinConfigPeriphInput(GPIO_A_BASE, GPIO_PIN_3, IOC_UARTRXD_UART0);
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable10_7  ;; 0x400d4100
   \   00000080   0x2108             MOVS     R1,#+8
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000086   0x.... 0x....      BL       IOCPinConfigPeriphInput
    166                GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_4);  
   \   0000008A   0x2110             MOVS     R1,#+16
   \   0000008C   0x....             LDR.N    R0,??DataTable10_3  ;; 0x400d9000
   \   0000008E   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    167                GPIOPinTypeUARTInput(GPIO_A_BASE, GPIO_PIN_3);
   \   00000092   0x2108             MOVS     R1,#+8
   \   00000094   0x....             LDR.N    R0,??DataTable10_3  ;; 0x400d9000
   \   00000096   0x.... 0x....      BL       GPIOPinTypeUARTInput
    168                HAL_UART_port = MSP_UART_BASE;
   \   0000009A   0x....             LDR.N    R5,??DataTable10_8  ;; 0x4000d000
    169                SysCtrlPeripheralEnable(SYS_CTRL_PERIPH_UART1);
   \   0000009C   0xF240 0x2001      MOVW     R0,#+513
   \   000000A0   0x.... 0x....      BL       SysCtrlPeripheralEnable
    170            }
    171            recRst(uartRecord);
   \                     ??HalUARTOpenIsr_1: (+1)
   \   000000A4   0x0030             MOVS     R0,R6
   \   000000A6   0x.... 0x....      BL       recRst
    172            
    173            if (uartRecord->configured) { // if already configured don't destroy buffers
   \   000000AA   0x7830             LDRB     R0,[R6, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD003             BEQ.N    ??HalUARTOpenIsr_2
    174              HalUARTClose(port);
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       HalUARTClose
    175            }
    176          
    177            if (config->baudRate > HAL_UART_BR_115200) {
   \                     ??HalUARTOpenIsr_2: (+1)
   \   000000B8   0x7860             LDRB     R0,[R4, #+1]
   \   000000BA   0x2805             CMP      R0,#+5
   \   000000BC   0xDB01             BLT.N    ??HalUARTOpenIsr_3
    178              return HAL_UART_BAUDRATE_ERROR;
   \   000000BE   0x2004             MOVS     R0,#+4
   \   000000C0   0xE05A             B.N      ??HalUARTOpenIsr_4
    179            }
    180          
    181            if (((uartRecord->rx.pBuffer = osal_mem_alloc(config->rx.maxBufSize)) == NULL) ||
    182                ((uartRecord->tx.pBuffer = osal_mem_alloc(config->tx.maxBufSize)) == NULL)) {
   \                     ??HalUARTOpenIsr_3: (+1)
   \   000000C2   0x89A0             LDRH     R0,[R4, #+12]
   \   000000C4   0x.... 0x....      BL       osal_mem_alloc
   \   000000C8   0x6130             STR      R0,[R6, #+16]
   \   000000CA   0x6930             LDR      R0,[R6, #+16]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD006             BEQ.N    ??HalUARTOpenIsr_5
   \   000000D0   0x8B20             LDRH     R0,[R4, #+24]
   \   000000D2   0x.... 0x....      BL       osal_mem_alloc
   \   000000D6   0x61F0             STR      R0,[R6, #+28]
   \   000000D8   0x69F0             LDR      R0,[R6, #+28]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD109             BNE.N    ??HalUARTOpenIsr_6
    183              if (uartRecord->rx.pBuffer != NULL) {
   \                     ??HalUARTOpenIsr_5: (+1)
   \   000000DE   0x6930             LDR      R0,[R6, #+16]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD004             BEQ.N    ??HalUARTOpenIsr_7
    184                osal_mem_free(uartRecord->rx.pBuffer);
   \   000000E4   0x6930             LDR      R0,[R6, #+16]
   \   000000E6   0x.... 0x....      BL       osal_mem_free
    185                uartRecord->rx.pBuffer = NULL;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x6130             STR      R0,[R6, #+16]
    186              }
    187          
    188              return HAL_UART_MEM_FAIL;
   \                     ??HalUARTOpenIsr_7: (+1)
   \   000000EE   0x2003             MOVS     R0,#+3
   \   000000F0   0xE042             B.N      ??HalUARTOpenIsr_4
    189            }
    190             
    191            IntEnable(interrupt_assignment);
   \                     ??HalUARTOpenIsr_6: (+1)
   \   000000F2   0x0038             MOVS     R0,R7
   \   000000F4   0x.... 0x....      BL       IntEnable
    192          
    193            uartRecord->configured = TRUE;
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0x7030             STRB     R0,[R6, #+0]
    194            uartRecord->baudRate = config->baudRate;
   \   000000FC   0x7860             LDRB     R0,[R4, #+1]
   \   000000FE   0x7070             STRB     R0,[R6, #+1]
    195            uartRecord->flowControl = config->flowControl;
   \   00000100   0x78A0             LDRB     R0,[R4, #+2]
   \   00000102   0x70B0             STRB     R0,[R6, #+2]
    196            uartRecord->flowControlThreshold = (config->flowControlThreshold > config->rx.maxBufSize) ? 0 :
    197                                               config->flowControlThreshold;
   \   00000104   0x89A0             LDRH     R0,[R4, #+12]
   \   00000106   0x88A1             LDRH     R1,[R4, #+4]
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xD201             BCS.N    ??HalUARTOpenIsr_8
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xE000             B.N      ??HalUARTOpenIsr_9
   \                     ??HalUARTOpenIsr_8: (+1)
   \   00000110   0x88A0             LDRH     R0,[R4, #+4]
   \                     ??HalUARTOpenIsr_9: (+1)
   \   00000112   0x80B0             STRH     R0,[R6, #+4]
    198            uartRecord->idleTimeout = config->idleTimeout;
   \   00000114   0x79A0             LDRB     R0,[R4, #+6]
   \   00000116   0x71B0             STRB     R0,[R6, #+6]
    199            uartRecord->rx.maxBufSize = config->rx.maxBufSize;
   \   00000118   0x89A0             LDRH     R0,[R4, #+12]
   \   0000011A   0x81B0             STRH     R0,[R6, #+12]
    200            uartRecord->tx.maxBufSize = config->tx.maxBufSize;
   \   0000011C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000011E   0x8330             STRH     R0,[R6, #+24]
    201            uartRecord->intEnable = config->intEnable;
   \   00000120   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000124   0xF886 0x0020      STRB     R0,[R6, #+32]
    202            uartRecord->callBackFunc = config->callBackFunc;
   \   00000128   0x6AA0             LDR      R0,[R4, #+40]
   \   0000012A   0x62B0             STR      R0,[R6, #+40]
    203          
    204            UARTConfigSetExpClk(HAL_UART_port, SysCtrlClockGet(), UBRRTable[uartRecord->baudRate],
    205                                   (UART_CONFIG_WLEN_8 | UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE));
   \   0000012C   0x.... 0x....      BL       SysCtrlClockGet
   \   00000130   0x2360             MOVS     R3,#+96
   \   00000132   0x....             LDR.N    R1,??DataTable10_9
   \   00000134   0x7872             LDRB     R2,[R6, #+1]
   \   00000136   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   \   0000013A   0x0001             MOVS     R1,R0
   \   0000013C   0x0028             MOVS     R0,R5
   \   0000013E   0x.... 0x....      BL       UARTConfigSetExpClk
    206          
    207            /* FIFO level set to 1/8th for both RX and TX which is 2 bytes */
    208            UARTFIFOLevelSet(HAL_UART_port, UART_FIFO_TX1_8, UART_FIFO_RX1_8);
   \   00000142   0x2200             MOVS     R2,#+0
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x0028             MOVS     R0,R5
   \   00000148   0x.... 0x....      BL       UARTFIFOLevelSet
    209            UARTFIFOEnable(HAL_UART_port);
   \   0000014C   0x0028             MOVS     R0,R5
   \   0000014E   0x.... 0x....      BL       UARTFIFOEnable
    210          
    211            /* Clear and enable UART TX, RX and Recieve Timeout interrupt. Not using CTS */
    212            UARTIntClear(HAL_UART_port,  (UART_INT_RX | UART_INT_TX | UART_INT_CTS | UART_INT_RT ));
   \   00000152   0x2172             MOVS     R1,#+114
   \   00000154   0x0028             MOVS     R0,R5
   \   00000156   0x.... 0x....      BL       UARTIntClear
    213            UARTIntEnable(HAL_UART_port, (UART_INT_RX | UART_INT_TX | UART_INT_CTS | UART_INT_RT ));
   \   0000015A   0x2172             MOVS     R1,#+114
   \   0000015C   0x0028             MOVS     R0,R5
   \   0000015E   0x.... 0x....      BL       UARTIntEnable
    214            
    215            if(config->flowControl) {
   \   00000162   0x78A0             LDRB     R0,[R4, #+2]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD003             BEQ.N    ??HalUARTOpenIsr_10
    216              /* Enable hardware flow control by enabling RTS */
    217              HWREG(HAL_UART_port + UART_O_CTL) |= (UART_CTL_RTSEN );
   \   00000168   0x6B28             LDR      R0,[R5, #+48]
   \   0000016A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000016E   0x6328             STR      R0,[R5, #+48]
    218            }
    219            UARTEnable(HAL_UART_port);
   \                     ??HalUARTOpenIsr_10: (+1)
   \   00000170   0x0028             MOVS     R0,R5
   \   00000172   0x.... 0x....      BL       UARTEnable
    220          
    221            return HAL_UART_SUCCESS;
   \   00000176   0x2000             MOVS     R0,#+0
   \                     ??HalUARTOpenIsr_4: (+1)
   \   00000178   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    222          }
    223          
    224          
    225          /*************************************************************************************************
    226           * @fn      HalUARTCloseIsr()
    227           *
    228           * @brief   Close the UART
    229           *
    230           * @param   port - UART port.
    231           *
    232           * @return  none
    233           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          void HalUARTCloseIsr(uint8 port)
    235          {
   \                     HalUARTCloseIsr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    236            halUARTCfg_t* uartRecord;
    237          
    238            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??HalUARTCloseIsr_0
   \   00000008   0x....             LDR.N    R4,??DataTable10_2
   \   0000000A   0xE000             B.N      ??HalUARTCloseIsr_1
   \                     ??HalUARTCloseIsr_0: (+1)
   \   0000000C   0x....             LDR.N    R4,??DataTable10_6
    239          
    240            UARTDisable(port);
   \                     ??HalUARTCloseIsr_1: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       UARTDisable
    241          
    242            if (uartRecord->configured) {
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD008             BEQ.N    ??HalUARTCloseIsr_2
    243              (void)osal_mem_free(uartRecord->rx.pBuffer);
   \   0000001A   0x6920             LDR      R0,[R4, #+16]
   \   0000001C   0x.... 0x....      BL       osal_mem_free
    244              (void)osal_mem_free(uartRecord->tx.pBuffer);
   \   00000020   0x69E0             LDR      R0,[R4, #+28]
   \   00000022   0x.... 0x....      BL       osal_mem_free
    245              recRst(uartRecord);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       recRst
    246            }
    247          }
   \                     ??HalUARTCloseIsr_2: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    248          
    249          /*************************************************************************************************
    250           * @fn      HalUARTReadIsr()
    251           *
    252           * @brief   Read a buffer from the UART
    253           *
    254           * @param   port - UART port.
    255           *          ppBuffer - pointer to a pointer that points to the data that will be read
    256           *          length - length of the requested buffer
    257           *
    258           * @return  length of buffer that was read
    259           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          uint16 HalUARTReadIsr ( uint8 port, uint8* pBuffer, uint16 length )
    261          {
   \                     HalUARTReadIsr: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    262            uint16        cnt, idx;
    263            halUARTCfg_t* uartRecord;
    264          
    265           
    266            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??HalUARTReadIsr_0
   \   00000008   0x....             LDR.N    R4,??DataTable10_2
   \   0000000A   0xE000             B.N      ??HalUARTReadIsr_1
   \                     ??HalUARTReadIsr_0: (+1)
   \   0000000C   0x....             LDR.N    R4,??DataTable10_6
    267          
    268            /* If port is not configured, no point to read it. */
    269            if (!uartRecord->configured) {
   \                     ??HalUARTReadIsr_1: (+1)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??HalUARTReadIsr_2
    270              return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE015             B.N      ??HalUARTReadIsr_3
    271            }
    272          
    273            idx = uartRecord->rx.bufferHead;
   \                     ??HalUARTReadIsr_2: (+1)
   \   00000018   0x8923             LDRH     R3,[R4, #+8]
    274            for (cnt = 0; cnt < length; cnt++) {
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE00B             B.N      ??HalUARTReadIsr_4
    275              pBuffer[cnt] = uartRecord->rx.pBuffer[idx++];
   \                     ??HalUARTReadIsr_5: (+1)
   \   0000001E   0x6925             LDR      R5,[R4, #+16]
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x5D5D             LDRB     R5,[R3, R5]
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x5445             STRB     R5,[R0, R1]
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
    276          
    277              if (idx >= uartRecord->rx.maxBufSize) {
   \   0000002A   0x89A5             LDRH     R5,[R4, #+12]
   \   0000002C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002E   0x42AB             CMP      R3,R5
   \   00000030   0xD300             BCC.N    ??HalUARTReadIsr_6
    278                idx = 0;
   \   00000032   0x2300             MOVS     R3,#+0
    279              }
    280            }
   \                     ??HalUARTReadIsr_6: (+1)
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??HalUARTReadIsr_4: (+1)
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003A   0x4290             CMP      R0,R2
   \   0000003C   0xD3EF             BCC.N    ??HalUARTReadIsr_5
    281            uartRecord->rx.bufferHead = idx;
   \   0000003E   0x8123             STRH     R3,[R4, #+8]
    282          
    283            /* Return number of bytes read. */
    284            return length;  
   \   00000040   0x0010             MOVS     R0,R2
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??HalUARTReadIsr_3: (+1)
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return
    285          }
    286          
    287          /*************************************************************************************************
    288           * @fn      HalUARTWriteIsr()
    289           *
    290           * @brief   Write a buffer to the UART
    291           *
    292           * @param   port    - UART port.
    293           *          pBuffer - pointer to the buffer that will be written
    294           *          length  - length of
    295           *
    296           * @return  length of the message that was sent
    297           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    298          uint16 HalUARTWriteIsr(uint8 port, uint8 *pBuffer, uint16 length)
    299          {
   \                     HalUARTWriteIsr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
    300            halUARTCfg_t* uartRecord;
    301          
    302            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD101             BNE.N    ??HalUARTWriteIsr_0
   \   0000000E   0x....             LDR.N    R6,??DataTable10_2
   \   00000010   0xE000             B.N      ??HalUARTWriteIsr_1
   \                     ??HalUARTWriteIsr_0: (+1)
   \   00000012   0x....             LDR.N    R6,??DataTable10_6
    303          
    304            if (!uartRecord->configured) {
   \                     ??HalUARTWriteIsr_1: (+1)
   \   00000014   0x7830             LDRB     R0,[R6, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??HalUARTWriteIsr_2
    305              return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE03D             B.N      ??HalUARTWriteIsr_3
    306            }
    307          
    308            uint16 idx = uartRecord->tx.bufferHead;
   \                     ??HalUARTWriteIsr_2: (+1)
   \   0000001E   0x8AB7             LDRH     R7,[R6, #+20]
    309            uint16 cnt = uartRecord->tx.bufferTail;
   \   00000020   0x8AF0             LDRH     R0,[R6, #+22]
    310          
    311            if (cnt == idx) {
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000026   0x42B8             CMP      R0,R7
   \   00000028   0xD101             BNE.N    ??HalUARTWriteIsr_4
    312              cnt = uartRecord->tx.maxBufSize;
   \   0000002A   0x8B30             LDRH     R0,[R6, #+24]
   \   0000002C   0xE008             B.N      ??HalUARTWriteIsr_5
    313            }
    314            else if (cnt > idx) {
   \                     ??HalUARTWriteIsr_4: (+1)
   \   0000002E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x4287             CMP      R7,R0
   \   00000034   0xD203             BCS.N    ??HalUARTWriteIsr_6
    315              cnt = uartRecord->tx.maxBufSize - cnt + idx;
   \   00000036   0x8B32             LDRH     R2,[R6, #+24]
   \   00000038   0x1A10             SUBS     R0,R2,R0
   \   0000003A   0x1838             ADDS     R0,R7,R0
   \   0000003C   0xE000             B.N      ??HalUARTWriteIsr_5
    316            }else{ /* (cnt < idx) */
    317              cnt = idx - cnt;
   \                     ??HalUARTWriteIsr_6: (+1)
   \   0000003E   0x1A38             SUBS     R0,R7,R0
    318            }
    319          
    320            /* Accept "all-or-none" on write request. */
    321            if (cnt < length) {
   \                     ??HalUARTWriteIsr_5: (+1)
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x42A8             CMP      R0,R5
   \   00000046   0xD201             BCS.N    ??HalUARTWriteIsr_7
    322              return 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE026             B.N      ??HalUARTWriteIsr_3
    323            }
    324          
    325             idx = uartRecord->tx.bufferTail;
   \                     ??HalUARTWriteIsr_7: (+1)
   \   0000004C   0x8AF7             LDRH     R7,[R6, #+22]
    326          
    327            for (cnt = 0; cnt < length; cnt++) {
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00B             B.N      ??HalUARTWriteIsr_8
    328              uartRecord->tx.pBuffer[idx++] = pBuffer[cnt];
   \                     ??HalUARTWriteIsr_9: (+1)
   \   00000052   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000054   0x5C42             LDRB     R2,[R0, R1]
   \   00000056   0x69F3             LDR      R3,[R6, #+28]
   \   00000058   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005A   0x54FA             STRB     R2,[R7, R3]
   \   0000005C   0x1C7F             ADDS     R7,R7,#+1
    329          
    330              if (idx >= uartRecord->tx.maxBufSize) {
   \   0000005E   0x8B32             LDRH     R2,[R6, #+24]
   \   00000060   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000062   0x4297             CMP      R7,R2
   \   00000064   0xD300             BCC.N    ??HalUARTWriteIsr_10
    331                idx = 0;
   \   00000066   0x2700             MOVS     R7,#+0
    332              }
    333            }
   \                     ??HalUARTWriteIsr_10: (+1)
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \                     ??HalUARTWriteIsr_8: (+1)
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006E   0x42A8             CMP      R0,R5
   \   00000070   0xD3EF             BCC.N    ??HalUARTWriteIsr_9
    334          
    335            halIntState_t intState;
    336            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000072   0x.... 0x....      BL       IntMasterDisable
   \   00000076   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007A   0xF090 0x0801      EORS     R8,R0,#0x1
    337            uartRecord->tx.bufferTail = idx;
   \   0000007E   0x82F7             STRH     R7,[R6, #+22]
    338            procTx(port);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x.... 0x....      BL       procTx
    339            HAL_EXIT_CRITICAL_SECTION(intState);
   \   00000088   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000090   0xD001             BEQ.N    ??HalUARTWriteIsr_11
   \   00000092   0x.... 0x....      BL       IntMasterEnable
    340          
    341            /* Return the number of bytes actually put into the buffer. */
    342            return length;  
   \                     ??HalUARTWriteIsr_11: (+1)
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??HalUARTWriteIsr_3: (+1)
   \   0000009A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    343          }
    344          
    345          /*************************************************************************************************
    346           * @fn      Hal_UART_RxBufLenIsr()
    347           *
    348           * @brief   Calculate Rx message length of a port
    349           *
    350           * @param   port - UART port.
    351           *
    352           * @return  length of current Rx Buffer
    353           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          uint16 Hal_UART_RxBufLenIsr(uint8 port)
    355          {
    356            int16 length;
    357            halUARTCfg_t* uartRecord;
    358          
    359            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \                     Hal_UART_RxBufLenIsr: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD101             BNE.N    ??Hal_UART_RxBufLenIsr_0
   \   00000006   0x....             LDR.N    R1,??DataTable10_2
   \   00000008   0xE000             B.N      ??Hal_UART_RxBufLenIsr_1
   \                     ??Hal_UART_RxBufLenIsr_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable10_6
    360            length = uartRecord->rx.bufferTail;
   \                     ??Hal_UART_RxBufLenIsr_1: (+1)
   \   0000000C   0xF9B1 0x000A      LDRSH    R0,[R1, #+10]
    361            length -= uartRecord->rx.bufferHead;
   \   00000010   0xF9B1 0x2008      LDRSH    R2,[R1, #+8]
   \   00000014   0x1A80             SUBS     R0,R0,R2
    362            if  (length < 0){
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD502             BPL.N    ??Hal_UART_RxBufLenIsr_2
    363                length += uartRecord->rx.maxBufSize;
   \   0000001C   0xF9B1 0x100C      LDRSH    R1,[R1, #+12]
   \   00000020   0x1808             ADDS     R0,R1,R0
    364            }
    365            return (uint16)length;
   \                     ??Hal_UART_RxBufLenIsr_2: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x4770             BX       LR               ;; return
    366          }
    367          
    368          /*************************************************************************************************
    369           * @fn      Hal_UART_TxBufLen()
    370           *
    371           * @brief   Calculate Tx Buffer length of a port
    372           *
    373           * @param   port - UART port.
    374           *
    375           * @return  length of current Tx buffer
    376           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    377          uint16 Hal_UART_TxBufLen( uint8 port )
    378          {
    379            int16 length;
    380            halUARTCfg_t* uartRecord;
    381          
    382            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \                     Hal_UART_TxBufLen: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD101             BNE.N    ??Hal_UART_TxBufLen_0
   \   00000006   0x....             LDR.N    R1,??DataTable10_2
   \   00000008   0xE000             B.N      ??Hal_UART_TxBufLen_1
   \                     ??Hal_UART_TxBufLen_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable10_6
    383            length = uartRecord->tx.bufferTail;
   \                     ??Hal_UART_TxBufLen_1: (+1)
   \   0000000C   0xF9B1 0x0016      LDRSH    R0,[R1, #+22]
    384            length -= uartRecord->tx.bufferHead;
   \   00000010   0xF9B1 0x2014      LDRSH    R2,[R1, #+20]
   \   00000014   0x1A80             SUBS     R0,R0,R2
    385            if  (length < 0) {
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD502             BPL.N    ??Hal_UART_TxBufLen_2
    386              length += uartRecord->tx.maxBufSize;
   \   0000001C   0xF9B1 0x1018      LDRSH    R1,[R1, #+24]
   \   00000020   0x1808             ADDS     R0,R1,R0
    387            }
    388            return (uint16)length;
   \                     ??Hal_UART_TxBufLen_2: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /*************************************************************************************************
    392           * @fn      recRst()
    393           *
    394           * @brief   Reset the UART record.
    395           *
    396           * @param   uartRecord to reset
    397           *
    398           * @return  none
    399           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    400          static void recRst( halUARTCfg_t* uartRecord )
    401          {
    402            uartRecord->configured        = FALSE;
   \                     recRst: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    403            uartRecord->rx.bufferHead     = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8101             STRH     R1,[R0, #+8]
    404            uartRecord->rx.bufferTail     = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8141             STRH     R1,[R0, #+10]
    405            uartRecord->rx.pBuffer        = (uint8 *)NULL;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    406            uartRecord->tx.bufferHead     = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8281             STRH     R1,[R0, #+20]
    407            uartRecord->tx.bufferTail     = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x82C1             STRH     R1,[R0, #+22]
    408            uartRecord->tx.pBuffer        = (uint8 *)NULL;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
    409            uartRecord->rxChRvdTime       = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6241             STR      R1,[R0, #+36]
    410            uartRecord->intEnable         = FALSE;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF880 0x1020      STRB     R1,[R0, #+32]
    411          }
   \   00000026   0x4770             BX       LR               ;; return
    412          
    413          /*************************************************************************************************
    414           * @fn      procRx
    415           *
    416           * @brief   Process Tx bytes.
    417           *
    418           * @param   void
    419           *
    420           * @return  void
    421           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    422          static void procRx( uint8 port )
    423          {
   \                     procRx: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    424            halUARTCfg_t* uartRecord;
    425            uint16 tail;
    426            
    427            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD101             BNE.N    ??procRx_0
   \   0000000A   0x....             LDR.N    R5,??DataTable10_2
   \   0000000C   0xE000             B.N      ??procRx_1
   \                     ??procRx_0: (+1)
   \   0000000E   0x....             LDR.N    R5,??DataTable10_6
    428          
    429            tail = uartRecord->rx.bufferTail;
   \                     ??procRx_1: (+1)
   \   00000010   0x896E             LDRH     R6,[R5, #+10]
   \   00000012   0xE00C             B.N      ??procRx_2
    430          
    431            while (UARTCharsAvail(port)) {
    432              uartRecord->rx.pBuffer[tail++] = UARTCharGetNonBlocking(port);
   \                     ??procRx_3: (+1)
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       UARTCharGetNonBlocking
   \   0000001C   0x6929             LDR      R1,[R5, #+16]
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x5470             STRB     R0,[R6, R1]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
    433          
    434              if (tail >= uartRecord->rx.maxBufSize) {
   \   00000024   0x89A8             LDRH     R0,[R5, #+12]
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD300             BCC.N    ??procRx_2
    435                tail = 0;
   \   0000002C   0x2600             MOVS     R6,#+0
    436              }
    437            }
   \                     ??procRx_2: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       UARTCharsAvail
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1EC             BNE.N    ??procRx_3
    438          
    439            if (uartRecord->rx.bufferTail != tail) {
   \   0000003A   0x8968             LDRH     R0,[R5, #+10]
   \   0000003C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003E   0x42B0             CMP      R0,R6
   \   00000040   0xD003             BEQ.N    ??procRx_4
    440              uartRecord->rx.bufferTail = tail;
   \   00000042   0x816E             STRH     R6,[R5, #+10]
    441              uartRecord->rxChRvdTime = osal_GetSystemClock();
   \   00000044   0x.... 0x....      BL       osal_GetSystemClock
   \   00000048   0x6268             STR      R0,[R5, #+36]
    442            }
    443          }
   \                     ??procRx_4: (+1)
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    444          
    445          /*************************************************************************************************
    446           * @fn      procTx
    447           *
    448           * @brief   Process Tx bytes.
    449           *
    450           * @param   void
    451           *
    452           * @return  void
    453           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    454          static void procTx( uint8 port )
    455          {
   \                     procTx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    456            uint16 head;
    457            uint16 tail;
    458            halUARTCfg_t* uartRecord;
    459            
    460            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD101             BNE.N    ??procTx_0
   \   0000000A   0x....             LDR.N    R7,??DataTable10_2
   \   0000000C   0xE000             B.N      ??procTx_1
   \                     ??procTx_0: (+1)
   \   0000000E   0x....             LDR.N    R7,??DataTable10_6
    461            head = uartRecord->tx.bufferHead;
   \                     ??procTx_1: (+1)
   \   00000010   0x8ABD             LDRH     R5,[R7, #+20]
    462            tail = uartRecord->tx.bufferTail;
   \   00000012   0x8AFE             LDRH     R6,[R7, #+22]
   \   00000014   0xE005             B.N      ??procTx_2
    463          
    464            while ((head != tail) && (UARTCharPutNonBlocking(port, uartRecord->tx.pBuffer[head]))) {
    465              if (++head >= uartRecord->tx.maxBufSize) {
   \                     ??procTx_3: (+1)
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0x8B38             LDRH     R0,[R7, #+24]
   \   0000001A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xD300             BCC.N    ??procTx_2
    466                head = 0;
   \   00000020   0x2500             MOVS     R5,#+0
    467              }
    468            }
   \                     ??procTx_2: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x42B5             CMP      R5,R6
   \   00000028   0xD008             BEQ.N    ??procTx_4
   \   0000002A   0x69F8             LDR      R0,[R7, #+28]
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x5C29             LDRB     R1,[R5, R0]
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UARTCharPutNonBlocking
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1EC             BNE.N    ??procTx_3
    469          
    470            uartRecord->tx.bufferHead = head;
   \                     ??procTx_4: (+1)
   \   0000003C   0x82BD             STRH     R5,[R7, #+20]
    471          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    472          
    473          /*************************************************************************************************
    474           * @fn      UART0 Rx/Tx ISR
    475           *
    476           * @brief   Called when a serial byte is ready to read and/or write.
    477           * NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    478           *
    479           * @param   void
    480           *
    481           * @return  void
    482          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    483          void interrupt_uart0(void)
    484          {
   \                     interrupt_uart0: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    485            UARTIntClear(UART0_BASE, (UART_INT_RX |  UART_INT_RT));
   \   00000002   0x2150             MOVS     R1,#+80
   \   00000004   0x....             LDR.N    R0,??DataTable10_5  ;; 0x4000c000
   \   00000006   0x.... 0x....      BL       UARTIntClear
    486            procRx(UART0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       procRx
    487          
    488            UARTIntClear(UART0_BASE, (UART_INT_TX | UART_INT_CTS));
   \   00000010   0x2122             MOVS     R1,#+34
   \   00000012   0x....             LDR.N    R0,??DataTable10_5  ;; 0x4000c000
   \   00000014   0x.... 0x....      BL       UARTIntClear
    489            procTx(UART0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       procTx
    490          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    491          
    492          /*************************************************************************************************
    493           * @fn      UART1 Rx/Tx ISR
    494           *
    495           * @brief   Called when a serial byte is ready to read and/or write.
    496           * NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    497           *
    498           * @param   void
    499           *
    500           * @return  void
    501          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    502          void interrupt_uart1(void)
    503          {
   \                     interrupt_uart1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    504            UARTIntClear(UART1_BASE, (UART_INT_RX |  UART_INT_RT));
   \   00000002   0x2150             MOVS     R1,#+80
   \   00000004   0x....             LDR.N    R0,??DataTable10_8  ;; 0x4000d000
   \   00000006   0x.... 0x....      BL       UARTIntClear
    505            procRx(UART1);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       procRx
    506          
    507            UARTIntClear(UART1_BASE, (UART_INT_TX | UART_INT_CTS));
   \   00000010   0x2122             MOVS     R1,#+34
   \   00000012   0x....             LDR.N    R0,??DataTable10_8  ;; 0x4000d000
   \   00000014   0x.... 0x....      BL       UARTIntClear
    508            procTx(UART1);
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      BL       procTx
    509          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     CP2102_Message_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     MSP_Message_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     CP2102_Record

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x400D9000         DC32     0x400d9000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400D4108         DC32     0x400d4108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     MSP_Record

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x400D4100         DC32     0x400d4100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x4000D000         DC32     0x4000d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     UBRRTable
    510          
    511          /**************************************************************************************************
    512          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HalUARTCloseIsr
         8   -> UARTDisable
         8   -> osal_mem_free
         8   -> recRst
      48   HalUARTInitIsr
        48   -> HalUARTOpen
      24   HalUARTOpenIsr
        24   -> GPIOPinTypeUARTInput
        24   -> GPIOPinTypeUARTOutput
        24   -> HalUARTClose
        24   -> IOCPinConfigPeriphInput
        24   -> IOCPinConfigPeriphOutput
        24   -> IntEnable
        24   -> SysCtrlClockGet
        24   -> SysCtrlPeripheralEnable
        24   -> UARTConfigSetExpClk
        24   -> UARTEnable
        24   -> UARTFIFOEnable
        24   -> UARTFIFOLevelSet
        24   -> UARTIntClear
        24   -> UARTIntEnable
        24   -> osal_mem_alloc
        24   -> osal_mem_free
        24   -> recRst
       8   HalUARTReadIsr
      24   HalUARTWriteIsr
        24   -> IntMasterDisable
        24   -> IntMasterEnable
        24   -> procTx
       0   Hal_UART_RxBufLenIsr
       0   Hal_UART_TxBufLen
       8   interrupt_uart0
         8   -> UARTIntClear
         8   -> procRx
         8   -> procTx
       8   interrupt_uart1
         8   -> UARTIntClear
         8   -> procRx
         8   -> procTx
      16   procRx
        16   -> UARTCharGetNonBlocking
        16   -> UARTCharsAvail
        16   -> osal_GetSystemClock
      24   procTx
        24   -> UARTCharPutNonBlocking
       0   recRst


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      44  CP2102_Record
      46  HalUARTCloseIsr
      84  HalUARTInitIsr
     380  HalUARTOpenIsr
      72  HalUARTReadIsr
     158  HalUARTWriteIsr
      38  Hal_UART_RxBufLenIsr
      38  Hal_UART_TxBufLen
      44  MSP_Record
      20  UBRRTable
      32  interrupt_uart0
      32  interrupt_uart1
      76  procRx
      64  procTx
      40  recRst

 
    88 bytes in section .bss
    20 bytes in section .rodata
 1 100 bytes in section .text
 
 1 100 bytes of CODE  memory
    20 bytes of CONST memory
    88 bytes of DATA  memory

Errors: none
Warnings: none
