###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        06/Aug/2015  22:29:13
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\hal_adc.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\hal_adc.c" -D EVERWRIST -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Projects\zstack\ZMain\TI2538DB\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\" -I "C:\Texas Instruments\Z-Stack
#        Mesh 1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -I
#        "C:\Texas
#        Instruments\cc2538_foundation_firmware_1_0_1_0\driverlib\cc2538\source\"
#        -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\hal_adc.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\hal_adc.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2013-05-20 10:14:45 -0700 (Mon, 20 May 2013) $
      4            Revision:       $Revision: 34373 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          
     44          #include  "hal_adc.h"
     45          #include  "hal_defs.h"
     46          #include  "hal_mcu.h"
     47          #include  "hal_types.h"
     48          
     49          /**************************************************************************************************
     50           *                                            CONSTANTS
     51           **************************************************************************************************/
     52          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     53          #define HAL_ADC_START       0x40    /* Starts Conversion */
     54          
     55          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     56          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     57          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     58          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     59          
     60          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     61          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     62          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     63          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     64          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     65          
     66          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     67          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     68          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     69          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     70          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     71          
     72          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     73          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     74          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     75          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     76          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
     77          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
     78          
     79          #define HAL_BITS_CHN_A0A1   0x03    /* Bit mask for AIN0,AIN1 */
     80          #define HAL_BITS_CHN_A2A3   0x0c    /* Bit mask for AIN2,AIN3 */
     81          #define HAL_BITS_CHN_A4A5   0x30    /* Bit mask for AIN4,AIN5 */
     82          #define HAL_BITS_CHN_A6A7   0xc0    /* Bit mask for AIN6,AIN7 */
     83          
     84          /* ------------------------------------------------------------------------------------------------
     85           *                                       Local Variables
     86           * ------------------------------------------------------------------------------------------------
     87           */
     88          
     89          #if (HAL_ADC == TRUE)

   \                                 In section .bss, align 1
     90          static uint8 adcRef;
   \                     adcRef:
   \   00000000                      DS8 1
     91          #endif
     92          
     93          /**************************************************************************************************
     94           * @fn      HalAdcInit
     95           *
     96           * @brief   Initialize ADC Service
     97           *
     98           * @param   None
     99           *
    100           * @return  None
    101           **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    102          void HalAdcInit (void)
    103          {
    104          #if (HAL_ADC == TRUE)
    105            adcRef = HAL_ADC_REF_VOLT;
   \                     HalAdcInit: (+1)
   \   00000000   0x2080             MOVS     R0,#+128
   \   00000002   0x....             LDR.N    R1,??DataTable3
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    106          #endif
    107          }
   \   00000006   0x4770             BX       LR               ;; return
    108          
    109          /**************************************************************************************************
    110           * @fn      HalAdcRead
    111           *
    112           * @brief   Read the ADC based on given channel and resolution
    113           *
    114           * @param   channel - channel where ADC will be read
    115           * @param   resolution - the resolution of the value
    116           *
    117           * @return  16 bit value of the ADC in offset binary format.
    118           *
    119           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    120           *          Note2: This function assumes that ADCCON3 contains the voltage reference.
    121           **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    122          uint16 HalAdcRead (uint8 channel, uint8 resolution)
    123          {
   \                     HalAdcRead: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    124            int16  reading = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    125          
    126          #if (HAL_ADC == TRUE)
    127            uint8   i, resbits;
                           ^
Warning[Pe177]: variable "i" was declared but never referenced
    128            uint8   adcChannel = 1;
   \   0000000A   0x2601             MOVS     R6,#+1
    129            uint32  padConfig, dirConfig;
    130            halIntState_t s;
    131            
    132            /*
    133             * If Analog input channel is AIN0..AIN7, make sure corresponing PA pin is 
    134             * setup. Only port A can be used as input to the ADC. If any pin on port A 
    135             * is to be used as an ADC input, the appropriate register, IOC_PAx_OVER, 
    136             * must be set to analog (that is, bit 0 must be set to 1). 
    137             */
    138            
    139            /* Hold off interrupts */
    140            HAL_ENTER_CRITICAL_SECTION(s);
   \   0000000C   0x.... 0x....      BL       IntMasterDisable
   \   00000010   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000014   0xF090 0x0701      EORS     R7,R0,#0x1
    141                
    142            switch (channel)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0x2807             CMP      R0,#+7
   \   00000020   0xD908             BLS.N    ??HalAdcRead_0
   \   00000022   0x3808             SUBS     R0,R0,#+8
   \   00000024   0xD008             BEQ.N    ??HalAdcRead_1
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0xD008             BEQ.N    ??HalAdcRead_2
   \   0000002A   0x1E40             SUBS     R0,R0,#+1
   \   0000002C   0xD008             BEQ.N    ??HalAdcRead_3
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0xD008             BEQ.N    ??HalAdcRead_4
   \   00000032   0xE009             B.N      ??HalAdcRead_5
    143            {
    144            case HAL_ADC_CHN_AIN0:
    145            case HAL_ADC_CHN_AIN1:
    146            case HAL_ADC_CHN_AIN2:
    147            case HAL_ADC_CHN_AIN3:
    148            case HAL_ADC_CHN_AIN4:
    149            case HAL_ADC_CHN_AIN5:
    150            case HAL_ADC_CHN_AIN6:
    151            case HAL_ADC_CHN_AIN7:
    152              adcChannel <<= channel;
   \                     ??HalAdcRead_0: (+1)
   \   00000034   0x40A6             LSLS     R6,R6,R4
    153            break;
   \   00000036   0xE008             B.N      ??HalAdcRead_6
    154            case HAL_ADC_CHN_A0A1:
    155              adcChannel = HAL_BITS_CHN_A0A1;
   \                     ??HalAdcRead_1: (+1)
   \   00000038   0x2603             MOVS     R6,#+3
    156              break;
   \   0000003A   0xE006             B.N      ??HalAdcRead_6
    157            
    158            case HAL_ADC_CHN_A2A3:
    159              adcChannel = HAL_BITS_CHN_A2A3;
   \                     ??HalAdcRead_2: (+1)
   \   0000003C   0x260C             MOVS     R6,#+12
    160              break;
   \   0000003E   0xE004             B.N      ??HalAdcRead_6
    161            case HAL_ADC_CHN_A4A5:
    162              adcChannel = HAL_BITS_CHN_A4A5;
   \                     ??HalAdcRead_3: (+1)
   \   00000040   0x2630             MOVS     R6,#+48
    163              break;
   \   00000042   0xE002             B.N      ??HalAdcRead_6
    164            case HAL_ADC_CHN_A6A7:
    165              adcChannel = HAL_BITS_CHN_A6A7;
   \                     ??HalAdcRead_4: (+1)
   \   00000044   0x26C0             MOVS     R6,#+192
    166              break; 
   \   00000046   0xE000             B.N      ??HalAdcRead_6
    167            default:
    168              adcChannel = 0;
   \                     ??HalAdcRead_5: (+1)
   \   00000048   0x2600             MOVS     R6,#+0
    169              break;
    170            } 
    171            
    172            /* save the current pad setting of the PortA pin */
    173            padConfig = IOCPadConfigGet(GPIO_A_BASE, adcChannel);
   \                     ??HalAdcRead_6: (+1)
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x....             LDR.N    R0,??DataTable3_1  ;; 0x400d9000
   \   00000050   0x.... 0x....      BL       IOCPadConfigGet
   \   00000054   0x4680             MOV      R8,R0
    174            
    175            /* save the current gpio setting of the PortA pin */
    176            dirConfig = GPIODirModeGet(GPIO_A_BASE, adcChannel);
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x....             LDR.N    R0,??DataTable3_1  ;; 0x400d9000
   \   0000005C   0x.... 0x....      BL       GPIODirModeGet
   \   00000060   0x4681             MOV      R9,R0
    177            
    178            /* set the PortA pin to Analog */
    179            IOCPadConfigSet(GPIO_A_BASE, adcChannel, IOC_OVERRIDE_ANA);
   \   00000062   0x2201             MOVS     R2,#+1
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   0x....             LDR.N    R0,??DataTable3_1  ;; 0x400d9000
   \   0000006A   0x.... 0x....      BL       IOCPadConfigSet
    180            
    181            /* set the PortA pin direction to input */
    182            GPIODirModeSet(GPIO_A_BASE, adcChannel, GPIO_DIR_MODE_IN);
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x0031             MOVS     R1,R6
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x....             LDR.N    R0,??DataTable3_1  ;; 0x400d9000
   \   00000076   0x.... 0x....      BL       GPIODirModeSet
    183          
    184            /* Convert resolution to decimation rate */
    185            switch (resolution)
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D01             CMP      R5,#+1
   \   0000007E   0xD004             BEQ.N    ??HalAdcRead_7
   \   00000080   0xD309             BCC.N    ??HalAdcRead_8
   \   00000082   0x2D03             CMP      R5,#+3
   \   00000084   0xD005             BEQ.N    ??HalAdcRead_9
   \   00000086   0xD302             BCC.N    ??HalAdcRead_10
   \   00000088   0xE005             B.N      ??HalAdcRead_8
    186            {
    187              case HAL_ADC_RESOLUTION_8:
    188                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_7: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
    189                break;
   \   0000008C   0xE004             B.N      ??HalAdcRead_11
    190              case HAL_ADC_RESOLUTION_10:
    191                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_10: (+1)
   \   0000008E   0x2010             MOVS     R0,#+16
    192                break;
   \   00000090   0xE002             B.N      ??HalAdcRead_11
    193              case HAL_ADC_RESOLUTION_12:
    194                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_9: (+1)
   \   00000092   0x2020             MOVS     R0,#+32
    195                break;
   \   00000094   0xE000             B.N      ??HalAdcRead_11
    196              case HAL_ADC_RESOLUTION_14:
    197              default:
    198                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_8: (+1)
   \   00000096   0x2030             MOVS     R0,#+48
    199                break;
    200            }
    201          
    202            /* writing to this register starts the extra conversion */
    203            ADCCON3 = channel | resbits | adcRef;
   \                     ??HalAdcRead_11: (+1)
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x4320             ORRS     R0,R0,R4
   \   0000009E   0x....             LDR.N    R1,??DataTable3
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x4308             ORRS     R0,R1,R0
   \   000000A4   0x....             LDR.N    R1,??DataTable3_2  ;; 0x400d7008
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    204          
    205            /* Wait for the conversion to be done */
    206            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_12: (+1)
   \   000000A8   0x....             LDR.N    R0,??DataTable3_3  ;; 0x400d7000
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x0600             LSLS     R0,R0,#+24
   \   000000AE   0xD5FB             BPL.N    ??HalAdcRead_12
    207            
    208            /* Set the pad configuration to previous value*/
    209            IOCPadConfigSet(GPIO_A_BASE, adcChannel, padConfig);
   \   000000B0   0x4642             MOV      R2,R8
   \   000000B2   0x0031             MOVS     R1,R6
   \   000000B4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B6   0x....             LDR.N    R0,??DataTable3_1  ;; 0x400d9000
   \   000000B8   0x.... 0x....      BL       IOCPadConfigSet
    210           
    211            /* Set the GPIO direction to previous value*/
    212            GPIODirModeSet(GPIO_A_BASE, adcChannel, dirConfig);
   \   000000BC   0x464A             MOV      R2,R9
   \   000000BE   0x0031             MOVS     R1,R6
   \   000000C0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C2   0x....             LDR.N    R0,??DataTable3_1  ;; 0x400d9000
   \   000000C4   0x.... 0x....      BL       GPIODirModeSet
    213            
    214            /* Read the result */
    215            reading = (int16) (ADCL);
   \   000000C8   0x....             LDR.N    R0,??DataTable3_4  ;; 0x400d700c
   \   000000CA   0x6806             LDR      R6,[R0, #+0]
    216            reading |= (int16) (ADCH << 8);
   \   000000CC   0x....             LDR.N    R0,??DataTable3_5  ;; 0x400d7010
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
    217            
    218            /* Enable interrupts */
    219            HAL_EXIT_CRITICAL_SECTION(s);
   \   000000D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D6   0x2F00             CMP      R7,#+0
   \   000000D8   0xD001             BEQ.N    ??HalAdcRead_13
   \   000000DA   0x.... 0x....      BL       IntMasterEnable
    220          
    221            /* Treat small negative as 0 */
    222            if (reading < 0)
   \                     ??HalAdcRead_13: (+1)
   \   000000DE   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   000000E0   0x2E00             CMP      R6,#+0
   \   000000E2   0xD500             BPL.N    ??HalAdcRead_14
    223              reading = 0;
   \   000000E4   0x2600             MOVS     R6,#+0
    224          
    225            switch (resolution)
   \                     ??HalAdcRead_14: (+1)
   \   000000E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E8   0x2D01             CMP      R5,#+1
   \   000000EA   0xD004             BEQ.N    ??HalAdcRead_15
   \   000000EC   0xD30C             BCC.N    ??HalAdcRead_16
   \   000000EE   0x2D03             CMP      R5,#+3
   \   000000F0   0xD007             BEQ.N    ??HalAdcRead_17
   \   000000F2   0xD303             BCC.N    ??HalAdcRead_18
   \   000000F4   0xE008             B.N      ??HalAdcRead_16
    226            {
    227              case HAL_ADC_RESOLUTION_8:
    228                reading >>= 8;
   \                     ??HalAdcRead_15: (+1)
   \   000000F6   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   000000F8   0x1236             ASRS     R6,R6,#+8
    229                break;
   \   000000FA   0xE007             B.N      ??HalAdcRead_19
    230              case HAL_ADC_RESOLUTION_10:
    231                reading >>= 6;
   \                     ??HalAdcRead_18: (+1)
   \   000000FC   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   000000FE   0x11B6             ASRS     R6,R6,#+6
    232                break;
   \   00000100   0xE004             B.N      ??HalAdcRead_19
    233              case HAL_ADC_RESOLUTION_12:
    234                reading >>= 4;
   \                     ??HalAdcRead_17: (+1)
   \   00000102   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000104   0x1136             ASRS     R6,R6,#+4
    235                break;
   \   00000106   0xE001             B.N      ??HalAdcRead_19
    236              case HAL_ADC_RESOLUTION_14:
    237              default:
    238                reading >>= 2;
   \                     ??HalAdcRead_16: (+1)
   \   00000108   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   0000010A   0x10B6             ASRS     R6,R6,#+2
    239              break;
    240            }
    241          #else
    242            /* unused arguments */
    243            (void) channel;
    244            (void) resolution;
    245          #endif
    246          
    247            return ((uint16)reading);
   \                     ??HalAdcRead_19: (+1)
   \   0000010C   0x0030             MOVS     R0,R6
   \   0000010E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000110   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    248          }
    249          
    250          /**************************************************************************************************
    251           * @fn      HalAdcSetReference
    252           *
    253           * @brief   Sets the reference voltage for the ADC and initializes the service
    254           *
    255           * @param   reference - the reference voltage to be used by the ADC
    256           *
    257           * @return  none
    258           *
    259           **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          void HalAdcSetReference ( uint8 reference )
    261          {
    262          #if (HAL_ADC == TRUE)
    263            adcRef = reference;
   \                     HalAdcSetReference: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable3
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    264          #endif
    265          }
   \   00000004   0x4770             BX       LR               ;; return
    266          
    267          /*********************************************************************
    268           * @fn      HalAdcCheckVdd
    269           *
    270           * @brief   Check for minimum Vdd specified.
    271           *
    272           * @param   vdd - The board-specific Vdd reading to check for.
    273           *
    274           * @return  TRUE if the Vdd measured is greater than the 'vdd' minimum parameter;
    275           *          FALSE if not.
    276           *
    277           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          bool HalAdcCheckVdd(uint8 vdd)
    279          {
    280            ADCCON3 = 0x0F;
   \                     HalAdcCheckVdd: (+1)
   \   00000000   0x210F             MOVS     R1,#+15
   \   00000002   0x....             LDR.N    R2,??DataTable3_2  ;; 0x400d7008
   \   00000004   0x6011             STR      R1,[R2, #+0]
    281            while (!(ADCCON1 & 0x80));
   \                     ??HalAdcCheckVdd_0: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable3_3  ;; 0x400d7000
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x0609             LSLS     R1,R1,#+24
   \   0000000C   0xD5FB             BPL.N    ??HalAdcCheckVdd_0
    282            return (ADCH > vdd);
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x....             LDR.N    R1,??DataTable3_5  ;; 0x400d7010
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD201             BCS.N    ??HalAdcCheckVdd_1
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??HalAdcCheckVdd_2
   \                     ??HalAdcCheckVdd_1: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??HalAdcCheckVdd_2: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x4770             BX       LR               ;; return
    283          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     adcRef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x400D9000         DC32     0x400d9000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x400D7008         DC32     0x400d7008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x400D7000         DC32     0x400d7000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x400D700C         DC32     0x400d700c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x400D7010         DC32     0x400d7010
    284          
    285          /**************************************************************************************************
    286          **************************************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HalAdcCheckVdd
       0   HalAdcInit
      32   HalAdcRead
        32   -> GPIODirModeGet
        32   -> GPIODirModeSet
        32   -> IOCPadConfigGet
        32   -> IOCPadConfigSet
        32   -> IntMasterDisable
        32   -> IntMasterEnable
       0   HalAdcSetReference


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
      34  HalAdcCheckVdd
       8  HalAdcInit
     276  HalAdcRead
       6  HalAdcSetReference
       1  adcRef

 
   1 byte  in section .bss
 348 bytes in section .text
 
 348 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: 1
