###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        06/Aug/2015  22:29:21
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ZGlobals.c
#    Command line =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ZGlobals.c -D
#        EVERWRIST -D FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D
#        xPOWER_SAVING -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC
#        -D LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Projects\zstack\ZMain\TI2538DB\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\hal\target\CC2538\" -I "C:\Texas Instruments\Z-Stack
#        Mesh 1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -I
#        "C:\Texas
#        Instruments\cc2538_foundation_firmware_1_0_1_0\driverlib\cc2538\source\"
#        -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\List\ZGlobals.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WATCH_HW\Obj\ZGlobals.o
#
###############################################################################

C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\ZGlobals.c
      1          /********************************************************************
      2           *     program:  WatchHW.c
      3           *      Project: Zigbee Watch
      4           *     Version:  0.0.1 -- phase 1
      5           *   Copyright:  2014, Barron Associates
      6           *     Written:  Wednesday, March 18, 2015
      7           *      Author:  Tim Trudeau - Timware
      8           *   Processor:  TI CC2538
      9           *        Tool:  IAR Embedded Workbench
     10           *
     11           *-------------------------------------------------------------------
     12           *  Description:    This file contains settings and other functions
     13                              that should be adapted to the user application.
     14                              Also see files OSAL_WatchApp.c and nwk_globals.c
     15           *******************************************************************/
     16          
     17          /*********************************************************************
     18           * INCLUDES
     19           */
     20          
     21          #include "ZComDef.h"
     22          #include "OSAL_Nv.h"
     23          #include "ZDObject.h"
     24          #include "ZGlobals.h"
     25          #include "ZDNwkMgr.h"
     26          #include "OnBoard.h"
     27          #include "ZDSecMgr.h"
     28          
     29          /*********************************************************************
     30           * MACROS
     31           */
     32          
     33          /*********************************************************************
     34           * CONSTANTS
     35           */
     36          
     37          /*********************************************************************
     38           * TYPEDEFS
     39           */
     40          
     41          typedef struct zgItem
     42          {
     43            uint16 id;
     44            uint16 len;
     45            void *buf;
     46          } zgItem_t;
     47          
     48          /*********************************************************************
     49           * NWK GLOBAL VARIABLES
     50           */
     51          
     52          // Polling values

   \                                 In section .data, align 2
     53          uint16 zgPollRate = POLL_RATE;
   \                     zgPollRate:
   \   00000000   0x1388             DC16 5000

   \                                 In section .data, align 2
     54          uint16 zgQueuedPollRate = QUEUED_POLL_RATE;
   \                     zgQueuedPollRate:
   \   00000000   0x0064             DC16 100

   \                                 In section .data, align 2
     55          uint16 zgResponsePollRate = RESPONSE_POLL_RATE;
   \                     zgResponsePollRate:
   \   00000000   0x0064             DC16 100

   \                                 In section .data, align 2
     56          uint16 zgRejoinPollRate = REJOIN_POLL_RATE;
   \                     zgRejoinPollRate:
   \   00000000   0x01B8             DC16 440
     57          
     58          // Transmission retries numbers

   \                                 In section .data, align 1
     59          uint8 zgMaxDataRetries = NWK_MAX_DATA_RETRIES;
   \                     zgMaxDataRetries:
   \   00000000   0x02               DC8 2

   \                                 In section .data, align 1
     60          uint8 zgMaxPollFailureRetries = MAX_POLL_FAILURE_RETRIES;
   \                     zgMaxPollFailureRetries:
   \   00000000   0x02               DC8 2
     61          
     62          // Default channel list

   \                                 In section .data, align 4
     63          uint32 zgDefaultChannelList = DEFAULT_CHANLIST;
   \                     zgDefaultChannelList:
   \   00000000   0x07FFF800         DC32 134215680
     64          
     65          // Default starting scan duration

   \                                 In section .data, align 1
     66          uint8 zgDefaultStartingScanDuration = STARTING_SCAN_DURATION;
   \                     zgDefaultStartingScanDuration:
   \   00000000   0x05               DC8 5
     67          
     68          // Stack profile Id

   \                                 In section .data, align 1
     69          uint8 zgStackProfile = STACK_PROFILE_ID;
   \                     zgStackProfile:
   \   00000000   0x02               DC8 2
     70          
     71          // Default indirect message holding timeout

   \                                 In section .data, align 1
     72          uint8 zgIndirectMsgTimeout = NWK_INDIRECT_MSG_TIMEOUT;
   \                     zgIndirectMsgTimeout:
   \   00000000   0x07               DC8 7
     73          
     74          // Security mode

   \                                 In section .bss, align 1
     75          uint8 zgSecurityMode = ZG_SECURITY_MODE;
   \                     zgSecurityMode:
   \   00000000                      DS8 1
     76          
     77          // Secure permit join

   \                                 In section .data, align 1
     78          uint8 zgSecurePermitJoin = TRUE;
   \                     zgSecurePermitJoin:
   \   00000000   0x01               DC8 1
     79          
     80          // Trust center address

   \                                 In section .bss, align 4
     81          uint8 zgApsTrustCenterAddr[Z_EXTADDR_LEN] = { 0 };
   \                     zgApsTrustCenterAddr:
   \   00000000                      DS8 8
     82          
     83          // Route Discovery Time - amount of time that a route request lasts

   \                                 In section .data, align 1
     84          uint8 zgRouteDiscoveryTime = ROUTE_DISCOVERY_TIME;
   \                     zgRouteDiscoveryTime:
   \   00000000   0x05               DC8 5
     85          
     86          // Route expiry

   \                                 In section .data, align 1
     87          uint8 zgRouteExpiryTime = ROUTE_EXPIRY_TIME;
   \                     zgRouteExpiryTime:
   \   00000000   0x1E               DC8 30
     88          
     89          // Extended PAN Id

   \                                 In section .bss, align 4
     90          uint8 zgExtendedPANID[Z_EXTADDR_LEN];
   \                     zgExtendedPANID:
   \   00000000                      DS8 8
     91          
     92          // Broadcast parameters

   \                                 In section .data, align 1
     93          uint8 zgMaxBcastRetires   = MAX_BCAST_RETRIES;
   \                     zgMaxBcastRetires:
   \   00000000   0x02               DC8 2

   \                                 In section .data, align 1
     94          uint8 zgPassiveAckTimeout = PASSIVE_ACK_TIMEOUT;
   \                     zgPassiveAckTimeout:
   \   00000000   0x05               DC8 5

   \                                 In section .data, align 1
     95          uint8 zgBcastDeliveryTime = BCAST_DELIVERY_TIME;
   \                     zgBcastDeliveryTime:
   \   00000000   0x1E               DC8 30
     96          
     97          // Network mode

   \                                 In section .data, align 1
     98          uint8 zgNwkMode = NWK_MODE;
   \                     zgNwkMode:
   \   00000000   0x02               DC8 2
     99          
    100          // Many-to-one values

   \                                 In section .bss, align 1
    101          uint8 zgConcentratorEnable = CONCENTRATOR_ENABLE;
   \                     zgConcentratorEnable:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    102          uint8 zgConcentratorDiscoveryTime = CONCENTRATOR_DISCOVERY_TIME;
   \                     zgConcentratorDiscoveryTime:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    103          uint8 zgConcentratorRadius = CONCENTRATOR_RADIUS;
   \                     zgConcentratorRadius:
   \   00000000   0x0A               DC8 10

   \                                 In section .bss, align 1
    104          uint8 zgConcentratorRC = CONCENTRATOR_ROUTE_CACHE;   // concentrator with route cache (no memory constraints)
   \                     zgConcentratorRC:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    105          uint8 zgNwkSrcRtgExpiryTime = SRC_RTG_EXPIRY_TIME;
   \                     zgNwkSrcRtgExpiryTime:
   \   00000000   0x0A               DC8 10
    106          
    107          // Cleanup Child Table according to routing traffic

   \                                 In section .bss, align 1
    108          uint8 zgRouterOffAssocCleanup = FALSE;
   \                     zgRouterOffAssocCleanup:
   \   00000000                      DS8 1
    109          
    110          // Determines whether or not a remote NWK leave request command frame received
    111          // by the local device is accepted .

   \                                 In section .data, align 1
    112          uint8 zgNwkLeaveRequestAllowed = TRUE;
   \                     zgNwkLeaveRequestAllowed:
   \   00000000   0x01               DC8 1
    113          
    114          // Determines if the Child Aging Table Management process is active or not.
    115          // This feature is optional and it is disabled by default.

   \                                 In section .bss, align 1
    116          uint8 zgChildAgingEnable = FALSE;
   \                     zgChildAgingEnable:
   \   00000000                      DS8 1
    117          
    118          /*********************************************************************
    119           * APS GLOBAL VARIABLES
    120           */
    121          
    122          // The maximum number of retries allowed after a transmission failure

   \                                 In section .data, align 1
    123          uint8 zgApscMaxFrameRetries = APSC_MAX_FRAME_RETRIES;
   \                     zgApscMaxFrameRetries:
   \   00000000   0x03               DC8 3
    124          
    125          // The maximum number of seconds (milliseconds) to wait for an
    126          // acknowledgement to a transmitted frame.
    127          
    128          // This number is used by polled devices.

   \                                 In section .data, align 2
    129          uint16 zgApscAckWaitDurationPolled = APSC_ACK_WAIT_DURATION_POLLED;
   \                     zgApscAckWaitDurationPolled:
   \   00000000   0x0BB8             DC16 3000
    130          
    131          // This number is used by non-polled devices in the following formula:
    132          //   (100 mSec) * (_NIB.MaxDepth * zgApsAckWaitMultiplier)

   \                                 In section .data, align 1
    133          uint8 zgApsAckWaitMultiplier = 2;
   \                     zgApsAckWaitMultiplier:
   \   00000000   0x02               DC8 2
    134          
    135          // The maximum number of milliseconds for the end device binding

   \                                 In section .data, align 2
    136          uint16 zgApsDefaultMaxBindingTime = APS_DEFAULT_MAXBINDING_TIME;
   \                     zgApsDefaultMaxBindingTime:
   \   00000000   0x3E80             DC16 16000
    137          
    138          // The 64-big identifier of the network to join or form.
    139          // Default set to all zeros

   \                                 In section .bss, align 4
    140          uint8 zgApsUseExtendedPANID[Z_EXTADDR_LEN] = {00,00,00,00,00,00,00,00};
   \                     zgApsUseExtendedPANID:
   \   00000000                      DS8 8
    141          
    142          // A boolean flag that indicates whether it is OK to use insecure join
    143          // on startup. Default set to TRUE

   \                                 In section .data, align 1
    144          uint8 zgApsUseInsecureJoin = TRUE;
   \                     zgApsUseInsecureJoin:
   \   00000000   0x01               DC8 1
    145          
    146          // The radius of broadcast multicast transmissions

   \                                 In section .data, align 1
    147          uint8 zgApsNonMemberRadius = APS_DEFAULT_NONMEMBER_RADIUS;
   \                     zgApsNonMemberRadius:
   \   00000000   0x02               DC8 2
    148          
    149          // Commissioned Network Address

   \                                 In section .data, align 2
    150          uint16 zgNwkCommissionedNwkAddr = INVALID_NODE_ADDR;
   \                     zgNwkCommissionedNwkAddr:
   \   00000000   0xFFFE             DC16 65534
    151          
    152          // APS Duplication Rejection table variables

   \                                 In section .data, align 2
    153          uint16 zgApscDupRejTimeoutInc = DEFAULT_APS_DUP_REJ_TIMEOUT_INCREMENT;
   \                     zgApscDupRejTimeoutInc:
   \   00000000   0x03E8             DC16 1000

   \                                 In section .data, align 1
    154          uint8  zgApscDupRejTimeoutCount = DEFAULT_APS_DUP_REJ_TIMEOUT;
   \                     zgApscDupRejTimeoutCount:
   \   00000000   0x0A               DC8 10

   \                                 In section .data, align 2
    155          uint16 zgApsMinDupRejTableSize = APS_DUP_REJ_ENTRIES;
   \                     zgApsMinDupRejTableSize:
   \   00000000   0x0005             DC16 5
    156          
    157          
    158          
    159          /*********************************************************************
    160           * SECURITY GLOBAL VARIABLES
    161           */
    162          
    163          // If TRUE, preConfigKey should be configured on all devices on the network
    164          // If false, it is configured only on the coordinator and sent to other
    165          // devices upon joining.

   \                                 In section .bss, align 1
    166          uint8 zgPreConfigKeys = FALSE;
   \                     zgPreConfigKeys:
   \   00000000                      DS8 1
    167          
    168          // The type of link key in use.  This will determine the security
    169          // policies associated with sending and receiving APS messages.
    170          // If ZG_GLOBAL_LINK_KEY APS TCLK security may be used for specific APS commands
    171          // If ZG_UNIQUE_LINK_KEY APS TCLK security is required for specific APS commands

   \                                 In section .data, align 1
    172          uint8 zgApsLinkKeyType = ZG_GLOBAL_LINK_KEY;
   \                     zgApsLinkKeyType:
   \   00000000   0x01               DC8 1
    173          
    174          // With changes introduced in R20 of the ZigBee specification,
    175          // boolean value of zgUseDefaultTCLK is set depending on zgApsLinkKeyType value.
    176          //
    177          // For zgApsLinkKeyType = ZG_GLOBAL_LINK_KEY, zgUseDefaultTCLK = TRUE
    178          // For zgApsLinkKeyType = ZG_UNIQUE_LINK_KEY, different devices have
    179          // different value:
    180          //      ZC should have             zgUseDefaultTCLK = FALSE
    181          //      Other devices should have  zgUseDefaultTCLK = TRUE
    182          // This is initialized in zgInitItems()
    183          // If ZG_UNIQUE_LINK_KEY, individual trust center link key between each device
    184          // and the trust center should be manually configured via MT_SYS_OSAL_NV_WRITE

   \                                 In section .bss, align 1
    185          uint8 zgUseDefaultTCLK;
   \                     zgUseDefaultTCLK:
   \   00000000                      DS8 1
    186          
    187          #if defined ( APP_TP2_TEST_MODE )
    188          uint8 guTxApsSecON = FALSE;
    189          uint8 guEnforceRxApsSec = TP_GU_ALL;
    190          #endif
    191          

   \                                 In section .bss, align 1
    192          uint8 zgApsAllowR19Sec = FALSE;
   \                     zgApsAllowR19Sec:
   \   00000000                      DS8 1
    193          
    194          /*********************************************************************
    195           * ZDO GLOBAL VARIABLES
    196           */
    197          
    198          // Configured PAN ID
    199          //uint16 zgConfigPANID = ZDAPP_CONFIG_PAN_ID;  //Should be 0xFFFF

   \                                 In section .data, align 2
    200          uint16 zgConfigPANID = 0xFFFF;  //Non-commissioned
   \                     zgConfigPANID:
   \   00000000   0xFFFF             DC16 65535
    201          
    202          // Device Logical Type

   \                                 In section .data, align 1
    203          uint8 zgDeviceLogicalType = DEVICE_LOGICAL_TYPE;
   \                     zgDeviceLogicalType:
   \   00000000   0x02               DC8 2
    204          
    205          // Startup Delay

   \                                 In section .data, align 1
    206          uint8 zgStartDelay = START_DELAY;
   \                     zgStartDelay:
   \   00000000   0x0A               DC8 10
    207          
    208          #if !defined MT_TASK
    209          // Flag to use verbose (i.e. "cc2480-style") direct MT callbacks in ZDProfile.c, ZDP_IncomingData().

   \                                 In section .bss, align 1
    210          uint8 zgZdoDirectCB = FALSE;
   \                     zgZdoDirectCB:
   \   00000000                      DS8 1
    211          #endif
    212          
    213          // Min number of attempted transmissions for Channel Interference detection

   \                                 In section .data, align 1
    214          uint8 zgNwkMgrMinTransmissions = ZDNWKMGR_MIN_TRANSMISSIONS;
   \                     zgNwkMgrMinTransmissions:
   \   00000000   0x14               DC8 20
    215          
    216          /*********************************************************************
    217           * APPLICATION GLOBAL VARIABLES
    218           */
    219          
    220          // Network Manager Mode

   \                                 In section .data, align 1
    221          uint8 zgNwkMgrMode = ZDNWKMGR_ENABLE;
   \                     zgNwkMgrMode:
   \   00000000   0x01               DC8 1
    222          
    223          /*********************************************************************
    224           * NON-STANDARD GLOBAL VARIABLES
    225           */
    226          
    227          // Simple API Endpoint

   \                                 In section .data, align 1
    228          uint8 zgSapiEndpoint = SAPI_ENDPOINT;
   \                     zgSapiEndpoint:
   \   00000000   0xE8               DC8 232
    229          
    230          /*********************************************************************
    231           * LOCAL VARIABLES
    232           */
    233          
    234          /*********************************************************************
    235           * ZGlobal Item Table
    236           */

   \                                 In section .rodata, align 4
    237          static CONST zgItem_t zgItemTable[] =
   \                     zgItemTable:
   \   00000000   0x0000 0x0000      DC16 0, 0
   \   00000004   0x00000000         DC32 0H
    238          {
    239          #if defined ( NV_INIT )
    240          #if !defined MT_TASK
    241            {
    242              ZCD_NV_ZDO_DIRECT_CB, sizeof(zgZdoDirectCB), &zgZdoDirectCB
    243            },
    244          #endif
    245            {
    246              ZCD_NV_LOGICAL_TYPE, sizeof(zgDeviceLogicalType), &zgDeviceLogicalType
    247            },
    248            {
    249              ZCD_NV_POLL_RATE, sizeof(zgPollRate), &zgPollRate
    250            },
    251            {
    252              ZCD_NV_QUEUED_POLL_RATE, sizeof(zgQueuedPollRate), &zgQueuedPollRate
    253            },
    254            {
    255              ZCD_NV_RESPONSE_POLL_RATE, sizeof(zgResponsePollRate), &zgResponsePollRate
    256            },
    257            {
    258              ZCD_NV_REJOIN_POLL_RATE, sizeof(zgRejoinPollRate), &zgRejoinPollRate
    259            },
    260            {
    261              ZCD_NV_DATA_RETRIES, sizeof(zgMaxDataRetries), &zgMaxDataRetries
    262            },
    263            {
    264              ZCD_NV_POLL_FAILURE_RETRIES, sizeof(zgMaxPollFailureRetries), &zgMaxPollFailureRetries
    265            },
    266            {
    267              ZCD_NV_CHANLIST, sizeof(zgDefaultChannelList), &zgDefaultChannelList
    268            },
    269            {
    270              ZCD_NV_SCAN_DURATION, sizeof(zgDefaultStartingScanDuration), &zgDefaultStartingScanDuration
    271            },
    272            {
    273              ZCD_NV_STACK_PROFILE, sizeof(zgStackProfile), &zgStackProfile
    274            },
    275            {
    276              ZCD_NV_INDIRECT_MSG_TIMEOUT, sizeof(zgIndirectMsgTimeout), &zgIndirectMsgTimeout
    277            },
    278            {
    279              ZCD_NV_ROUTE_EXPIRY_TIME, sizeof(zgRouteExpiryTime), &zgRouteExpiryTime
    280            },
    281            {
    282              ZCD_NV_EXTENDED_PAN_ID, Z_EXTADDR_LEN, zgExtendedPANID
    283            },
    284            {
    285              ZCD_NV_BCAST_RETRIES, sizeof(zgMaxBcastRetires), &zgMaxBcastRetires
    286            },
    287            {
    288              ZCD_NV_PASSIVE_ACK_TIMEOUT, sizeof(zgPassiveAckTimeout), &zgPassiveAckTimeout
    289            },
    290            {
    291              ZCD_NV_BCAST_DELIVERY_TIME, sizeof(zgBcastDeliveryTime), &zgBcastDeliveryTime
    292            },
    293            {
    294              ZCD_NV_NWK_MODE, sizeof(zgNwkMode), &zgNwkMode
    295            },
    296            {
    297              ZCD_NV_CONCENTRATOR_ENABLE, sizeof(zgConcentratorEnable), &zgConcentratorEnable
    298            },
    299            {
    300              ZCD_NV_CONCENTRATOR_DISCOVERY, sizeof(zgConcentratorDiscoveryTime), &zgConcentratorDiscoveryTime
    301            },
    302            {
    303              ZCD_NV_CONCENTRATOR_RADIUS, sizeof(zgConcentratorRadius), &zgConcentratorRadius
    304            },
    305            {
    306              ZCD_NV_CONCENTRATOR_RC, sizeof(zgConcentratorRC), &zgConcentratorRC
    307            },
    308            {
    309              ZCD_NV_SRC_RTG_EXPIRY_TIME, sizeof(zgNwkSrcRtgExpiryTime), &zgNwkSrcRtgExpiryTime
    310            },
    311            {
    312              ZCD_NV_ROUTE_DISCOVERY_TIME, sizeof(zgRouteDiscoveryTime), &zgRouteDiscoveryTime
    313            },
    314          #ifndef NONWK
    315            {
    316              ZCD_NV_PANID, sizeof(zgConfigPANID), &zgConfigPANID
    317            },
    318            {
    319              ZCD_NV_PRECFGKEYS_ENABLE, sizeof(zgPreConfigKeys), &zgPreConfigKeys
    320            },
    321            {
    322              ZCD_NV_SECURITY_MODE, sizeof(zgSecurityMode), &zgSecurityMode
    323            },
    324            {
    325              ZCD_NV_SECURE_PERMIT_JOIN, sizeof(zgSecurePermitJoin), &zgSecurePermitJoin
    326            },
    327            {
    328              ZCD_NV_USE_DEFAULT_TCLK, sizeof(zgUseDefaultTCLK), &zgUseDefaultTCLK
    329            },
    330            {
    331              ZCD_NV_TRUSTCENTER_ADDR, Z_EXTADDR_LEN, zgApsTrustCenterAddr
    332            },
    333            {
    334              ZCD_NV_APS_LINK_KEY_TYPE, sizeof(zgApsLinkKeyType), &zgApsLinkKeyType
    335            },
    336          #endif // NONWK
    337            {
    338              ZCD_NV_APS_FRAME_RETRIES, sizeof(zgApscMaxFrameRetries), &zgApscMaxFrameRetries
    339            },
    340            {
    341              ZCD_NV_APS_ACK_WAIT_DURATION, sizeof(zgApscAckWaitDurationPolled), &zgApscAckWaitDurationPolled
    342            },
    343            {
    344              ZCD_NV_APS_ACK_WAIT_MULTIPLIER, sizeof(zgApsAckWaitMultiplier), &zgApsAckWaitMultiplier
    345            },
    346            {
    347              ZCD_NV_BINDING_TIME, sizeof(zgApsDefaultMaxBindingTime), &zgApsDefaultMaxBindingTime
    348            },
    349            {
    350              ZCD_NV_APS_USE_EXT_PANID, Z_EXTADDR_LEN, zgApsUseExtendedPANID
    351            },
    352            {
    353              ZCD_NV_APS_USE_INSECURE_JOIN, sizeof(zgApsUseInsecureJoin), &zgApsUseInsecureJoin
    354            },
    355            {
    356              ZCD_NV_APS_NONMEMBER_RADIUS, sizeof(zgApsNonMemberRadius), &zgApsNonMemberRadius
    357            },
    358            {
    359              ZCD_NV_START_DELAY, sizeof(zgStartDelay), &zgStartDelay
    360            },
    361            {
    362              ZCD_NV_SAPI_ENDPOINT, sizeof(zgSapiEndpoint), &zgSapiEndpoint
    363            },
    364            {
    365              ZCD_NV_NWK_MGR_MODE, sizeof(zgNwkMgrMode), &zgNwkMgrMode
    366            },
    367            {
    368              ZCD_NV_NWKMGR_MIN_TX, sizeof(zgNwkMgrMinTransmissions), &zgNwkMgrMinTransmissions
    369            },
    370            {
    371              ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP, sizeof(zgRouterOffAssocCleanup), &zgRouterOffAssocCleanup
    372            },
    373            {
    374              ZCD_NV_NWK_LEAVE_REQ_ALLOWED, sizeof(zgNwkLeaveRequestAllowed), &zgNwkLeaveRequestAllowed
    375            },
    376            {
    377              ZCD_NV_COMMISSIONED_NWK_ADDR, sizeof(zgNwkCommissionedNwkAddr), &zgNwkCommissionedNwkAddr
    378            },
    379            {
    380              ZCD_NV_APS_ALLOW_R19_SECURITY, sizeof(zgApsAllowR19Sec), &zgApsAllowR19Sec
    381            },
    382            {
    383              ZCD_NV_APS_DUPREJ_TIMEOUT_INC, sizeof(zgApscDupRejTimeoutInc), &zgApscDupRejTimeoutInc
    384            },
    385            {
    386              ZCD_NV_APS_DUPREJ_TIMEOUT_COUNT, sizeof(zgApscDupRejTimeoutCount), &zgApscDupRejTimeoutCount
    387            },
    388            {
    389              ZCD_NV_APS_DUPREJ_TABLE_SIZE, sizeof(zgApsMinDupRejTableSize), &zgApsMinDupRejTableSize
    390            },
    391          #if defined ( ZIGBEE_CHILD_AGING )
    392            {
    393              ZCD_NV_NWK_CHILD_AGE_ENABLE, sizeof(zgChildAgingEnable), &zgChildAgingEnable
    394            },
    395          #endif // ZIGBEE_CHILD_AGING
    396          #endif // NV_INIT
    397            // Last item -- DO NOT MOVE IT!
    398            {
    399              0x00, 0, NULL
    400            }
    401          };
    402          
    403          /*********************************************************************
    404           * LOCAL FUNCTIONS
    405           */
    406          
    407          static uint8 zgItemInit( uint16 id, uint16 len, void *buf, uint8 setDefault );
    408          
    409          #ifndef NONWK
    410          static uint8 zgPreconfigKeyInit( uint8 setDefault );
    411          #endif
    412          
    413          /*********************************************************************
    414           * @fn       zgItemInit()
    415           *
    416           * @brief
    417           *
    418           *   Initialize a global item. If the item doesn't exist in NV memory,
    419           *   write the system default (value passed in) into NV memory. But if
    420           *   it exists, set the item to the value stored in NV memory.
    421           *
    422           *   Also, if setDefault is TRUE and the item exists, we will write
    423           *   the default value to NV space.
    424           *
    425           * @param   id - item id
    426           * @param   len - item len
    427           * @param   buf - pointer to the item
    428           * @param   setDefault - TRUE to set default, not read
    429           *
    430           * @return  ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
    431           *          exist in NV, NV_OPER_FAILED if failure.
    432           */

   \                                 In section .text, align 2, keep-with-next
    433          static uint8 zgItemInit( uint16 id, uint16 len, void *buf, uint8 setDefault )
    434          {
   \                     zgItemInit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    435            uint8 status;
    436          
    437            // If the item doesn't exist in NV memory, create and initialize
    438            // it with the value passed in.
    439            status = osal_nv_item_init( id, len, buf );
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x.... 0x....      BL       osal_nv_item_init
    440            if ( status == ZSUCCESS )
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD113             BNE.N    ??zgItemInit_0
    441            {
    442              if ( setDefault )
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD008             BEQ.N    ??zgItemInit_1
    443              {
    444                // Write the default value back to NV
    445                status = osal_nv_write( id, 0, len, buf );
   \   00000024   0x0033             MOVS     R3,R6
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0x.... 0x....      BL       osal_nv_write
   \   00000034   0xE007             B.N      ??zgItemInit_0
    446              }
    447              else
    448              {
    449                // The item exists in NV memory, read it from NV memory
    450                status = osal_nv_read( id, 0, len, buf );
   \                     ??zgItemInit_1: (+1)
   \   00000036   0x0033             MOVS     R3,R6
   \   00000038   0x002A             MOVS     R2,R5
   \   0000003A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x.... 0x....      BL       osal_nv_read
    451              }
    452            }
    453          
    454            return (status);
   \                     ??zgItemInit_0: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    455          }
    456          
    457          /*********************************************************************
    458           * API FUNCTIONS
    459           */
    460          
    461          /*********************************************************************
    462           * @fn          zgInit
    463           *
    464           * @brief
    465           *
    466           *   Initialize the Z-Stack Globals. If an item doesn't exist in
    467           *   NV memory, write the system default into NV memory. But if
    468           *   it exists, set the item to the value stored in NV memory.
    469           *
    470           * NOTE: The Startup Options (ZCD_NV_STARTUP_OPTION) indicate
    471           *       that the Config state items (zgItemTable) need to be
    472           *       set to defaults (ZCD_STARTOPT_DEFAULT_CONFIG_STATE). The
    473           *
    474           * @param       none
    475           *
    476           * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
    477           *              exist in NV, NV_OPER_FAILED if failure.
    478           */

   \                                 In section .text, align 2, keep-with-next
    479          uint8 zgInit( void )
    480          {
   \                     zgInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    481            uint8  setDefault = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    482          
    483            // Do we want to default the Config state values
    484            if ( zgReadStartupOptions() & ZCD_STARTOPT_DEFAULT_CONFIG_STATE )
   \   00000004   0x.... 0x....      BL       zgReadStartupOptions
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD500             BPL.N    ??zgInit_0
    485            {
    486              setDefault = TRUE;
   \   0000000C   0x2401             MOVS     R4,#+1
    487            }
    488          
    489          #if defined ( FEATURE_SYSTEM_STATS )
    490            // This sections tracks the number of resets
    491            uint16 bootCnt = 0;
    492          
    493            // Update the Boot Counter
    494            if ( osal_nv_item_init( ZCD_NV_BOOTCOUNTER, sizeof(bootCnt), &bootCnt ) == ZSUCCESS )
    495            {
    496              // Get the old value from NV memory
    497              osal_nv_read( ZCD_NV_BOOTCOUNTER, 0, sizeof(bootCnt), &bootCnt );
    498            }
    499          
    500            // Increment the Boot Counter and store it into NV memory
    501            if ( setDefault )
    502            {
    503              bootCnt = 0;
    504            }
    505            else
    506            {
    507              bootCnt++;
    508            }
    509          
    510            osal_nv_write( ZCD_NV_BOOTCOUNTER, 0, sizeof(bootCnt), &bootCnt );
    511          #endif  // FEATURE_SYSTEM_STATS
    512          
    513            // Initialize the Extended PAN ID as my own extended address
    514            ZMacGetReq( ZMacExtAddr, zgExtendedPANID );
   \                     ??zgInit_0: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable2
   \   00000010   0x20E2             MOVS     R0,#+226
   \   00000012   0x.... 0x....      BL       ZMacGetReq
    515          
    516            // Initialize the items table
    517            zgInitItems( setDefault );
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       zgInitItems
    518          
    519          #ifndef NONWK
    520            if ( ZG_SECURE_ENABLED )
    521            {
    522              // Initialize the Pre-Configured Key to the default key
    523              zgPreconfigKeyInit( setDefault );
    524          
    525              // Initialize NV items for all Keys: NWK, APS, TCLK and Master
    526              ZDSecMgrInitNVKeyTables( setDefault );
    527            }
    528          #endif // NONWK
    529          
    530            // Clear the Config State default
    531            if ( setDefault )
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD003             BEQ.N    ??zgInit_1
    532            {
    533              zgWriteStartupOptions( ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_CONFIG_STATE );
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       zgWriteStartupOptions
    534            }
    535          
    536            return ( ZSUCCESS );
   \                     ??zgInit_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    537          }
    538          
    539          /*********************************************************************
    540           * @fn          zgInitItems
    541           *
    542           * @brief       Initializes RAM variables from NV.  If NV items don't
    543           *              exist, then the NV is initialize with what is in RAM
    544           *              variables.
    545           *
    546           * @param       none
    547           *
    548           * @return      none
    549           */

   \                                 In section .text, align 2, keep-with-next
    550          void zgInitItems( uint8 setDefault )
    551          {
   \                     zgInitItems: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    552            uint8  i = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    553          
    554            if ( ZG_BUILD_COORDINATOR_TYPE && ( zgApsLinkKeyType == ZG_UNIQUE_LINK_KEY ) )
    555            {
    556              zgUseDefaultTCLK = FALSE;
    557            }
    558            else
    559            {
    560              // Most of the time default TCLK will be used
    561              zgUseDefaultTCLK = TRUE;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable2_1
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
   \   0000000C   0xE012             B.N      ??zgInitItems_0
    562            }
    563          
    564            while ( zgItemTable[i].id != 0x00 )
    565            {
    566              // Initialize the item
    567              zgItemInit( zgItemTable[i].id, zgItemTable[i].len, zgItemTable[i].buf, setDefault  );
   \                     ??zgInitItems_1: (+1)
   \   0000000E   0x0023             MOVS     R3,R4
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x....             LDR.N    R0,??DataTable2_2
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000001A   0x6842             LDR      R2,[R0, #+4]
   \   0000001C   0x....             LDR.N    R0,??DataTable2_2
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000024   0x8841             LDRH     R1,[R0, #+2]
   \   00000026   0x....             LDR.N    R0,??DataTable2_2
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0xF830 0x0035      LDRH     R0,[R0, R5, LSL #+3]
   \   0000002E   0x.... 0x....      BL       zgItemInit
    568          
    569              // Move on to the next item
    570              i++;
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
    571            }
   \                     ??zgInitItems_0: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable2_2
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0xF830 0x0035      LDRH     R0,[R0, R5, LSL #+3]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1E6             BNE.N    ??zgInitItems_1
    572          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    573          
    574          /*********************************************************************
    575           * @fn          zgReadStartupOptions
    576           *
    577           * @brief       Reads the ZCD_NV_STARTUP_OPTION NV Item.
    578           *
    579           * @param       none
    580           *
    581           * @return      the ZCD_NV_STARTUP_OPTION NV item
    582           */

   \                                 In section .text, align 2, keep-with-next
    583          uint8 zgReadStartupOptions( void )
    584          {
   \                     zgReadStartupOptions: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    585            // Default to Use Config State and Use Network State
    586            uint8 startupOption = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    587          
    588            // This should have been done in ZMain.c, but just in case.
    589            if ( osal_nv_item_init( ZCD_NV_STARTUP_OPTION,
    590                                        sizeof(startupOption),
    591                                        &startupOption ) == ZSUCCESS )
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x.... 0x....      BL       osal_nv_item_init
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??zgReadStartupOptions_0
    592            {
    593              // Read saved startup control
    594              osal_nv_read( ZCD_NV_STARTUP_OPTION,
    595                            0,
    596                            sizeof( startupOption ),
    597                            &startupOption);
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x.... 0x....      BL       osal_nv_read
    598            }
    599            return ( startupOption );
   \                     ??zgReadStartupOptions_0: (+1)
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    600          }
    601          
    602          /*********************************************************************
    603           * @fn          zgWriteStartupOptions
    604           *
    605           * @brief       Writes bits into the ZCD_NV_STARTUP_OPTION NV Item.
    606           *
    607           * @param       action - ZG_STARTUP_SET set bit, ZG_STARTUP_CLEAR to
    608           *               clear bit. The set bit is an OR operation, and the
    609           *               clear bit is an AND ~(bitOptions) operation.
    610           *
    611           * @param       bitOptions - which bits to perform action on:
    612           *                      ZCD_STARTOPT_DEFAULT_CONFIG_STATE
    613           *                      ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    614           *
    615           * @return      ZSUCCESS if successful
    616           */

   \                                 In section .text, align 2, keep-with-next
    617          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions )
    618          {
   \                     zgWriteStartupOptions: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    619            uint8 status;
    620            uint8 startupOptions = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    621          
    622            status = osal_nv_read( ZCD_NV_STARTUP_OPTION,
    623                          0,
    624                          sizeof( startupOptions ),
    625                          &startupOptions );
   \   0000000C   0xAB00             ADD      R3,SP,#+0
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0x.... 0x....      BL       osal_nv_read
    626          
    627            if ( status == ZSUCCESS )
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD115             BNE.N    ??zgWriteStartupOptions_0
    628            {
    629              if ( action == ZG_STARTUP_SET )
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2CFF             CMP      R4,#+255
   \   00000022   0xD105             BNE.N    ??zgWriteStartupOptions_1
    630              {
    631                // Set bits
    632                startupOptions |= bitOptions;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x4328             ORRS     R0,R5,R0
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000002E   0xE006             B.N      ??zgWriteStartupOptions_2
    633              }
    634              else
    635              {
    636                // Clear bits
    637                startupOptions &= (bitOptions ^ 0xFF);
   \                     ??zgWriteStartupOptions_1: (+1)
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF095 0x01FF      EORS     R1,R5,#0xFF
   \   00000038   0x4008             ANDS     R0,R1,R0
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    638              }
    639          
    640              // Changed?
    641              status = osal_nv_write( ZCD_NV_STARTUP_OPTION,
    642                           0,
    643                           sizeof( startupOptions ),
    644                           &startupOptions );
   \                     ??zgWriteStartupOptions_2: (+1)
   \   0000003E   0xAB00             ADD      R3,SP,#+0
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0x.... 0x....      BL       osal_nv_write
    645            }
    646          
    647            return ( status );
   \                     ??zgWriteStartupOptions_0: (+1)
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    648          }
    649          
    650          /*********************************************************************
    651           * @fn          zgSetItem
    652           *
    653           * @brief       Set RAM variables from set-NV, if it exist in the zgItemTable
    654           *
    655           * @param       id - NV ID
    656           *              len - NV item length
    657           *              buf - pointer to the input buffer
    658           *
    659           * @return      none
    660           */

   \                                 In section .text, align 2, keep-with-next
    661          void zgSetItem( uint16 id, uint16 len, void *buf )
    662          {
   \                     zgSetItem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0013             MOVS     R3,R2
    663          
    664            uint8  i = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE000             B.N      ??zgSetItem_0
    665          
    666            // Look up the NV item table
    667            while ( zgItemTable[i].id != 0x00 )
    668            {
    669              if( zgItemTable[i].id == id )
    670              {
    671                if ( zgItemTable[i].len == len )
    672                {
    673                  osal_memcpy( zgItemTable[i].buf, buf, len );
    674                }
    675                break;
    676              }
    677              // Move on to the next item
    678              i++;
   \                     ??zgSetItem_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??zgSetItem_0: (+1)
   \   0000000A   0x....             LDR.N    R2,??DataTable2_2
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xF832 0x2034      LDRH     R2,[R2, R4, LSL #+3]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD018             BEQ.N    ??zgSetItem_2
   \   00000016   0x....             LDR.N    R2,??DataTable2_2
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xF832 0x2034      LDRH     R2,[R2, R4, LSL #+3]
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x4282             CMP      R2,R0
   \   00000022   0xD1F1             BNE.N    ??zgSetItem_1
   \   00000024   0x....             LDR.N    R0,??DataTable2_2
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   0000002C   0x8840             LDRH     R0,[R0, #+2]
   \   0000002E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD109             BNE.N    ??zgSetItem_3
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0x000A             MOVS     R2,R1
   \   00000038   0x0019             MOVS     R1,R3
   \   0000003A   0x....             LDR.N    R0,??DataTable2_2
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0xEB10 0x00C4      ADDS     R0,R0,R4, LSL #+3
   \   00000042   0x6840             LDR      R0,[R0, #+4]
   \   00000044   0x.... 0x....      BL       osal_memcpy
    679            }
    680          }
   \                     ??zgSetItem_3: (+1)
   \                     ??zgSetItem_2: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     zgExtendedPANID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     zgUseDefaultTCLK

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     zgItemTable
    681          
    682          #ifndef NONWK
    683          /*********************************************************************
    684           * @fn       zgPreconfigKeyInit()
    685           *
    686           * @brief
    687           *
    688           *   Initialize ZCD_NV_PRECFGKEY NV item. If the item doesn't exist in NV memory,
    689           *   write the system default (value passed in) into NV memory. But if
    690           *   it exists do not overwrite it.
    691           *
    692           *   Also, if setDefault is TRUE and the item exists, we will write
    693           *   the default value to NV space.
    694           *
    695           * @param   setDefault - TRUE to set default
    696           *
    697           * @return  ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
    698           *          exist in NV, NV_OPER_FAILED if failure.
    699           */
    700          static uint8 zgPreconfigKeyInit( uint8 setDefault )
    701          {
    702            uint8 zgPreConfigKey[SEC_KEY_LEN];
    703            uint8 status;
    704          
    705            // Initialize the Pre-Configured Key to the default key
    706            osal_memcpy( zgPreConfigKey, defaultKey, SEC_KEY_LEN );
    707          
    708            // If the item doesn't exist in NV memory, create and initialize it
    709            status = osal_nv_item_init( ZCD_NV_PRECFGKEY, SEC_KEY_LEN, zgPreConfigKey );
    710            if ( status == ZSUCCESS )
    711            {
    712              if ( setDefault )
    713              {
    714                // Write the default value back to NV
    715                status =  osal_nv_write( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, zgPreConfigKey );
    716              }
    717            }
    718          
    719            // clear local copy of default key
    720            osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
    721          
    722            return (status);
    723          }
    724          #endif
    725          
    726          /*********************************************************************
    727          *********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   zgInit
         8   -> ZMacGetReq
         8   -> zgInitItems
         8   -> zgReadStartupOptions
         8   -> zgWriteStartupOptions
      16   zgInitItems
        16   -> zgItemInit
      24   zgItemInit
        24   -> osal_nv_item_init
        24   -> osal_nv_read
        24   -> osal_nv_write
       8   zgReadStartupOptions
         8   -> osal_nv_item_init
         8   -> osal_nv_read
       8   zgSetItem
         8   -> osal_memcpy
      16   zgWriteStartupOptions
        16   -> osal_nv_read
        16   -> osal_nv_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       1  zgApsAckWaitMultiplier
       1  zgApsAllowR19Sec
       2  zgApsDefaultMaxBindingTime
       1  zgApsLinkKeyType
       2  zgApsMinDupRejTableSize
       1  zgApsNonMemberRadius
       8  zgApsTrustCenterAddr
       8  zgApsUseExtendedPANID
       1  zgApsUseInsecureJoin
       2  zgApscAckWaitDurationPolled
       1  zgApscDupRejTimeoutCount
       2  zgApscDupRejTimeoutInc
       1  zgApscMaxFrameRetries
       1  zgBcastDeliveryTime
       1  zgChildAgingEnable
       1  zgConcentratorDiscoveryTime
       1  zgConcentratorEnable
       1  zgConcentratorRC
       1  zgConcentratorRadius
       2  zgConfigPANID
       4  zgDefaultChannelList
       1  zgDefaultStartingScanDuration
       1  zgDeviceLogicalType
       8  zgExtendedPANID
       1  zgIndirectMsgTimeout
      48  zgInit
      66  zgInitItems
      74  zgItemInit
       8  zgItemTable
       1  zgMaxBcastRetires
       1  zgMaxDataRetries
       1  zgMaxPollFailureRetries
       2  zgNwkCommissionedNwkAddr
       1  zgNwkLeaveRequestAllowed
       1  zgNwkMgrMinTransmissions
       1  zgNwkMgrMode
       1  zgNwkMode
       1  zgNwkSrcRtgExpiryTime
       1  zgPassiveAckTimeout
       2  zgPollRate
       1  zgPreConfigKeys
       2  zgQueuedPollRate
      40  zgReadStartupOptions
       2  zgRejoinPollRate
       2  zgResponsePollRate
       1  zgRouteDiscoveryTime
       1  zgRouteExpiryTime
       1  zgRouterOffAssocCleanup
       1  zgSapiEndpoint
       1  zgSecurePermitJoin
       1  zgSecurityMode
      74  zgSetItem
       1  zgStackProfile
       1  zgStartDelay
       1  zgUseDefaultTCLK
      78  zgWriteStartupOptions
       1  zgZdoDirectCB

 
  34 bytes in section .bss
  50 bytes in section .data
   8 bytes in section .rodata
 392 bytes in section .text
 
 392 bytes of CODE  memory
   8 bytes of CONST memory
  84 bytes of DATA  memory

Errors: none
Warnings: none
