###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        26/Apr/2015  14:16:18
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\AF.c
#    Command line =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\AF.c -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\AF.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\Obj\AF.o
#
###############################################################################

C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\AF.c
      1            /*****************************************************************************
      2            *     program:  AF.c
      3            *      Project: Zigbee Watch
      4            *     Version:  0.0.1 -- phase 1
      5            *   Copyright:  2014, Barron Associates
      6            *     Written:  Sunday, March 15, 2015
      7            *          By:  Tim Trudeau - Timware
      8            *   Processor:  TI CC2538
      9            *        Tool:  IAR Embedded Workbench
     10            *
     11            *---------------------------------------------------------------------------
     12          Description:
     13            This Files contain the Application Frame work functions.
     14            All function that deal with Zigbee PAN at the application level are found here.
     15            *****************************************************************************/
     16           /* ------------------------------------------------------------------------------------------------
     17            *                                          Includes
     18            * ------------------------------------------------------------------------------------------------
     19            */
     20          
     21          #include "OSAL.h"
     22          #include "AF.h"
     23          #include "nwk_globals.h"
     24          #include "nwk_util.h"
     25          #include "aps_groups.h"
     26          #include "ZDProfile.h"
     27          #include "aps_frag.h"
     28          #include "rtg.h"
     29          
     30          #if defined ( MT_AF_CB_FUNC )
     31            #include "MT_AF.h"
     32          #endif
     33          
     34          #if defined ( INTER_PAN )
     35            #include "stub_aps.h"
     36          #endif
     37          
     38          /*********************************************************************
     39           * @MACRO      afSend
     40           *
     41           * @brief   Helper macro for V1 API to invoke V2 API.
     42           *
     43           * input parameters
     44           *
     45           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
     46           * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
     47           * @param   cID - A valid cluster ID as specified by the Profile.
     48           * @param   len - Number of bytes of data pointed to by next param.
     49           * @param  *buf - A pointer to the data bytes to send.
     50           * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
     51           * @param  *transID - A pointer to a byte which can be modified and which will
     52           *                    be used as the transaction sequence number of the msg.
     53           *
     54           * output parameters
     55           *
     56           * @param  *transID - Incremented by one if the return value is success.
     57           *
     58           * @return  afStatus_t - See previous definition of afStatus_... types.
     59           */
     60          #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \
     61                  AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \
     62                                    (cID), (len), (buf), (transID), (options), (radius) )
     63          
     64          /*********************************************************************
     65           * GLOBAL VARIABLES
     66           */
     67          

   \                                 In section .bss, align 4
     68          epList_t *epList;
   \                     epList:
   \   00000000                      DS8 4
     69          
     70          /*********************************************************************
     71           * LOCAL FUNCTIONS
     72           */
     73          
     74          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
     75                          zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
     76                          uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp, uint8 radius );
     77          
     78          static epList_t *afFindEndPointDescList( uint8 EndPoint );
     79          
     80          static pDescCB afGetDescCB( endPointDesc_t *epDesc );
     81          
     82          /*********************************************************************
     83            PUBLIC FUNCTIONS
     84          */
     85          /*********************************************************************
     86           * @fn      afInit
     87           *
     88           * @brief   Initialization function for the AF.
     89           *
     90           * @param   none
     91           *
     92           * @return  none
     93          *********************************************************************
     94          void afInit( void )
     95          {
     96          }
     97          */
     98          /*********************************************************************
     99           * @fn      afRegisterExtended
    100           *
    101           * @brief   Register an Application's EndPoint description.
    102           *
    103           * @param   epDesc - pointer to the Application's endpoint descriptor.
    104           * @param   descFn - pointer to descriptor callback function
    105           * @param   applFn - pointer to the Application callback function
    106           *
    107           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    108           *
    109           * @return  Pointer to epList_t on success, NULL otherwise.
    110          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    111          epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn, pApplCB applFn )
    112          {
   \                     afRegisterExtended: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    113            epList_t *ep = osal_mem_alloc(sizeof(epList_t));
   \   00000008   0x2014             MOVS     R0,#+20
   \   0000000A   0x.... 0x....      BL       osal_mem_alloc
    114          
    115            if (ep != NULL)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00F             BEQ.N    ??afRegisterExtended_0
    116            {
    117              ep->nextDesc = epList;
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x6001             STR      R1,[R0, #+0]
    118              epList = ep;
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable7
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    119              ep->epDesc = epDesc;
   \   00000020   0x6045             STR      R5,[R0, #+4]
    120              ep->pfnDescCB = descFn;
   \   00000022   0x6086             STR      R6,[R0, #+8]
    121              ep->apsfCfg.frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
   \   00000024   0x2132             MOVS     R1,#+50
   \   00000026   0x7301             STRB     R1,[R0, #+12]
    122              ep->apsfCfg.windowSize = APSF_DEFAULT_WINDOW_SIZE;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x7341             STRB     R1,[R0, #+13]
    123              ep->flags = eEP_AllowMatch;  // Default to allow Match Descriptor.
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x7381             STRB     R1,[R0, #+14]
    124              ep->pfnApplCB = applFn;
   \   00000030   0x6104             STR      R4,[R0, #+16]
    125            }
    126          
    127            return ep;
   \                     ??afRegisterExtended_0: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    128          }
    129          
    130          /*********************************************************************
    131           * @fn      afRegister
    132           *
    133           * @brief   Register an Application's EndPoint description.
    134           *
    135           * @param   epDesc - pointer to the Application's endpoint descriptor.
    136           *
    137           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    138           *
    139           * @return  afStatus_SUCCESS - Registered
    140           *          afStatus_MEM_FAIL - not enough memory to add descriptor
    141           *          afStatus_INVALID_PARAMETER - duplicate endpoint
    142           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    143          afStatus_t afRegister( endPointDesc_t *epDesc )
    144          {
   \                     afRegister: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    145            if (afFindEndPointDescList(epDesc->endPoint))  // Look for duplicate endpoint.
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??afRegister_0
    146            {
    147              return afStatus_INVALID_PARAMETER;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE00A             B.N      ??afRegister_1
    148            }
    149          
    150            return ((NULL == afRegisterExtended(epDesc, NULL, NULL)) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
   \                     ??afRegister_0: (+1)
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       afRegisterExtended
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE.N    ??afRegister_2
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0xE000             B.N      ??afRegister_3
   \                     ??afRegister_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??afRegister_3: (+1)
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??afRegister_1: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    151          }
    152          
    153          /*********************************************************************
    154           * @fn      afDelete
    155           *
    156           * @brief   Delete an Application's EndPoint descriptor and frees the memory
    157           *
    158           * @param   EndPoint - Application Endpoint to delete
    159           *
    160           * @return  afStatus_SUCCESS - endpoint deleted
    161           *          afStatus_INVALID_PARAMETER - endpoint not found
    162           *          afStatus_FAILED - endpoint list empty
    163           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    164          afStatus_t afDelete( uint8 EndPoint )
    165          {
   \                     afDelete: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    166            epList_t *epCurrent;
    167            epList_t *epPrevious;
    168          
    169            if ( epList != NULL )
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD025             BEQ.N    ??afDelete_0
    170            {
    171              epPrevious = epCurrent = epList;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x000A             MOVS     R2,R1
    172          
    173              // first element of the list matches
    174              if ( epCurrent->epDesc->endPoint == EndPoint )
   \   00000014   0x684B             LDR      R3,[R1, #+4]
   \   00000016   0x781B             LDRB     R3,[R3, #+0]
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4283             CMP      R3,R0
   \   0000001C   0xD108             BNE.N    ??afDelete_1
    175              {
    176                epList = epCurrent->nextDesc;
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000024   0x6010             STR      R0,[R2, #+0]
    177                osal_mem_free( epCurrent );
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0x.... 0x....      BL       osal_mem_free
    178          
    179                return ( afStatus_SUCCESS );
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE014             B.N      ??afDelete_2
    180              }
    181              else
    182              {
    183                // search the list
    184                for ( epCurrent = epPrevious->nextDesc;
   \                     ??afDelete_1: (+1)
   \   00000030   0x6811             LDR      R1,[R2, #+0]
   \   00000032   0xE001             B.N      ??afDelete_3
    185                      epCurrent != NULL;
    186                      epCurrent = epCurrent->nextDesc )
    187                {
    188                  if ( epCurrent->epDesc->endPoint == EndPoint )
    189                  {
    190                    epPrevious->nextDesc = epCurrent->nextDesc;
    191                    osal_mem_free( epCurrent );
    192          
    193                    // delete the entry and free the memory
    194                    return ( afStatus_SUCCESS );
    195                  }
    196                  epPrevious = epCurrent;
   \                     ??afDelete_4: (+1)
   \   00000034   0x000A             MOVS     R2,R1
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \                     ??afDelete_3: (+1)
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD00B             BEQ.N    ??afDelete_5
   \   0000003C   0x684B             LDR      R3,[R1, #+4]
   \   0000003E   0x781B             LDRB     R3,[R3, #+0]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4283             CMP      R3,R0
   \   00000044   0xD1F6             BNE.N    ??afDelete_4
   \   00000046   0x6808             LDR      R0,[R1, #+0]
   \   00000048   0x6010             STR      R0,[R2, #+0]
   \   0000004A   0x0008             MOVS     R0,R1
   \   0000004C   0x.... 0x....      BL       osal_mem_free
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE002             B.N      ??afDelete_2
    197                }
    198              }
    199          
    200              // no endpoint found
    201              return ( afStatus_INVALID_PARAMETER );
   \                     ??afDelete_5: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0xE000             B.N      ??afDelete_2
    202            }
    203            else
    204            {
    205              // epList is empty
    206              return ( afStatus_FAILED );
   \                     ??afDelete_0: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??afDelete_2: (+1)
   \   0000005A   0xBD02             POP      {R1,PC}          ;; return
    207            }
    208          }
    209          
    210          /*********************************************************************
    211           * @fn          afDataConfirm
    212           *
    213           * @brief       This function will generate the Data Confirm back to
    214           *              the application.
    215           *
    216           * @param       endPoint - confirm end point
    217           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    218           * @param       status - status of APSDE_DATA_REQUEST
    219           *
    220           * @return      none
    221          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    222          void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
    223          {
   \                     afDataConfirm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    224            endPointDesc_t *epDesc;
    225            afDataConfirm_t *msgPtr;
    226          
    227            // Find the endpoint description
    228            epDesc = afFindEndPointDesc( endPoint );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       afFindEndPointDesc
   \   00000010   0x0007             MOVS     R7,R0
    229            if ( epDesc == NULL )
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD00E             BEQ.N    ??afDataConfirm_0
    230              return;
    231          
    232            // Determine the incoming command type
    233            msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
   \                     ??afDataConfirm_1: (+1)
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       osal_msg_allocate
    234            if ( msgPtr )
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD009             BEQ.N    ??afDataConfirm_2
    235            {
    236              // Build the Data Confirm message
    237              msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
   \   00000020   0x21FD             MOVS     R1,#+253
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    238              msgPtr->hdr.status = status;
   \   00000024   0x7046             STRB     R6,[R0, #+1]
    239              msgPtr->endpoint = endPoint;
   \   00000026   0x7084             STRB     R4,[R0, #+2]
    240              msgPtr->transID = transID;
   \   00000028   0x70C5             STRB     R5,[R0, #+3]
    241          
    242          #if defined ( MT_AF_CB_FUNC )
    243              /* If MT has subscribed for this callback, don't send as a message. */
    244              if ( AFCB_CHECK(CB_ID_AF_DATA_CNF,*(epDesc->task_id)) )
    245              {
    246                /* Send callback if it's subscribed */
    247                MT_AfDataConfirm ((void *)msgPtr);
    248                /* Release the memory. */
    249                osal_msg_deallocate( (void *)msgPtr );
    250              }
    251              else
    252          #endif
    253              {
    254                /* send message through task message */
    255                osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0x6878             LDR      R0,[R7, #+4]
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x.... 0x....      BL       osal_msg_send
    256              }
    257            }
    258          }
   \                     ??afDataConfirm_2: (+1)
   \                     ??afDataConfirm_0: (+1)
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    259          
    260          /*********************************************************************
    261           * @fn          afReflectError
    262           *
    263           * @brief       This function will generate the Reflect Error message to
    264           *              the application.
    265           *
    266           * @param       dstAddrMode - mode of dstAdd - 0 - normal short addr, 1 - group Address
    267           * @param       dstAddr - intended destination
    268           * @param       endPoint - confirm end point
    269           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    270           * @param       status - status of APSDE_DATA_REQUEST
    271           *
    272           * @return      none
    273          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    274          void afReflectError( uint8 dstAddrMode, uint16 dstAddr, uint8 endPoint, uint8 transID, ZStatus_t status )
    275          {
   \                     afReflectError: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    276            endPointDesc_t *epDesc;
    277            afReflectError_t *msgPtr;
    278          
    279            // Find the endpoint description
    280            epDesc = afFindEndPointDesc( endPoint );
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       afFindEndPointDesc
   \   00000014   0x4680             MOV      R8,R0
    281            if ( epDesc == NULL )
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xD012             BEQ.N    ??afReflectError_0
    282              return;
    283          
    284            // Determine the incoming command type
    285            msgPtr = (afReflectError_t *)osal_msg_allocate( sizeof(afReflectError_t) );
   \                     ??afReflectError_1: (+1)
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0x.... 0x....      BL       osal_msg_allocate
    286            if ( msgPtr )
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD00D             BEQ.N    ??afReflectError_2
    287            {
    288              // Build the Data Confirm message
    289              msgPtr->hdr.event = AF_REFLECT_ERROR_CMD;
   \   00000026   0x21FE             MOVS     R1,#+254
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    290              msgPtr->hdr.status = status;
   \   0000002A   0x9906             LDR      R1,[SP, #+24]
   \   0000002C   0x7041             STRB     R1,[R0, #+1]
    291              msgPtr->endpoint = endPoint;
   \   0000002E   0x7086             STRB     R6,[R0, #+2]
    292              msgPtr->transID = transID;
   \   00000030   0x70C7             STRB     R7,[R0, #+3]
    293              msgPtr->dstAddrMode = dstAddrMode;
   \   00000032   0x7104             STRB     R4,[R0, #+4]
    294              msgPtr->dstAddr = dstAddr;
   \   00000034   0x80C5             STRH     R5,[R0, #+6]
    295          
    296          #if defined ( MT_AF_CB_FUNC )
    297              /* If MT has subscribed for this callback, don't send as a message. */
    298              if ( AFCB_CHECK( CB_ID_AF_REFLECT_ERROR, *(epDesc->task_id) ) )
    299              {
    300                /* Send callback if it's subscribed */
    301                MT_AfReflectError( (void *)msgPtr );
    302                /* Release the memory. */
    303                osal_msg_deallocate( (void *)msgPtr );
    304              }
    305              else
    306          #endif
    307              {
    308                /* send message through task message */
    309                osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       osal_msg_send
    310              }
    311            }
    312          }
   \                     ??afReflectError_2: (+1)
   \                     ??afReflectError_0: (+1)
   \   00000042   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    313          
    314          /*********************************************************************
    315           * @fn          afIncomingData
    316           *
    317           * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
    318           *
    319           * @param       aff  - pointer to APS frame format
    320           * @param       SrcAddress  - Source address
    321           * @param       SrcPanId  - Source PAN ID
    322           * @param       sig - incoming message's link quality
    323           * @param       nwkSeqNum - incoming network sequence number (from nwk header frame)
    324           * @param       SecurityUse - Security enable/disable
    325           * @param       timestamp - the MAC Timer2 timestamp at Rx.
    326           * @param       radius - incoming messages received radius
    327           *
    328           * @return      none
    329          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    330          void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress, uint16 SrcPanId,
    331                               NLDE_Signal_t *sig, uint8 nwkSeqNum, uint8 SecurityUse,
    332                               uint32 timestamp, uint8 radius )
    333          {
   \                     afIncomingData: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0007             MOVS     R7,R0
    334            endPointDesc_t *epDesc = NULL;
   \   00000008   0x2400             MOVS     R4,#+0
    335            epList_t *pList = epList;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7
   \   0000000E   0xF8D0 0x9000      LDR      R9,[R0, #+0]
    336          #if !defined ( APS_NO_GROUPS )
    337            uint8 grpEp = APS_GROUPS_EP_NOT_FOUND;
   \   00000012   0xF05F 0x08FE      MOVS     R8,#+254
    338          #endif
    339          
    340            if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
   \   00000016   0x7838             LDRB     R0,[R7, #+0]
   \   00000018   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000001C   0x280C             CMP      R0,#+12
   \   0000001E   0xD11B             BNE.N    ??afIncomingData_0
    341            {
    342          #if !defined ( APS_NO_GROUPS )
    343              // Find the first endpoint for this group
    344              grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
   \   00000020   0x21FE             MOVS     R1,#+254
   \   00000022   0x88B8             LDRH     R0,[R7, #+4]
   \   00000024   0x.... 0x....      BL       aps_FindGroupForEndpoint
   \   00000028   0x4680             MOV      R8,R0
    345              if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
   \   0000002A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002E   0xF1B8 0x0FFE      CMP      R8,#+254
   \   00000032   0xF000 0x8097      BEQ.W    ??afIncomingData_1
    346                return;   // No endpoint found
    347          
    348              epDesc = afFindEndPointDesc( grpEp );
   \                     ??afIncomingData_2: (+1)
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       afFindEndPointDesc
   \   0000003E   0x0004             MOVS     R4,R0
    349              if ( epDesc == NULL )
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xF000 0x808F      BEQ.W    ??afIncomingData_1
    350                return;   // Endpoint descriptor not found
    351          
    352              pList = afFindEndPointDescList( epDesc->endPoint );
   \                     ??afIncomingData_3: (+1)
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       afFindEndPointDescList
   \   0000004C   0x4681             MOV      R9,R0
   \                     ??afIncomingData_4: (+1)
   \   0000004E   0x9D13             LDR      R5,[SP, #+76]
   \   00000050   0xF8DD 0xA050      LDR      R10,[SP, #+80]
   \   00000054   0x9E15             LDR      R6,[SP, #+84]
   \   00000056   0xE017             B.N      ??afIncomingData_5
    353          #else
    354              return; // Not supported
    355          #endif
    356            }
    357            else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_0: (+1)
   \   00000058   0x78B8             LDRB     R0,[R7, #+2]
   \   0000005A   0x28FF             CMP      R0,#+255
   \   0000005C   0xD105             BNE.N    ??afIncomingData_6
    358            {
    359              // Set the list
    360              if ( pList != NULL )
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD0F4             BEQ.N    ??afIncomingData_4
    361              {
    362                epDesc = pList->epDesc;
   \   00000064   0xF8D9 0x4004      LDR      R4,[R9, #+4]
   \   00000068   0xE7F1             B.N      ??afIncomingData_4
    363              }
    364            }
    365            else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
   \                     ??afIncomingData_6: (+1)
   \   0000006A   0x78B8             LDRB     R0,[R7, #+2]
   \   0000006C   0x.... 0x....      BL       afFindEndPointDesc
   \   00000070   0x0004             MOVS     R4,R0
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0EB             BEQ.N    ??afIncomingData_4
    366            {
    367              pList = afFindEndPointDescList( epDesc->endPoint );
   \   00000076   0x7820             LDRB     R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       afFindEndPointDescList
   \   0000007C   0x4681             MOV      R9,R0
   \   0000007E   0xE7E6             B.N      ??afIncomingData_4
    368            }
    369          
    370            while ( epDesc )
    371            {
    372              uint16 epProfileID = 0xFFFE;  // Invalid Profile ID
    373          
    374              if ( pList->pfnDescCB )
    375              {
    376                uint16 *pID = (uint16 *)(pList->pfnDescCB(
    377                                           AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
    378                if ( pID )
    379                {
    380                  epProfileID = *pID;
    381                  osal_mem_free( pID );
    382                }
    383              }
    384              else if ( epDesc->simpleDesc )
    385              {
    386                epProfileID = epDesc->simpleDesc->AppProfId;
    387              }
    388          
    389              // First part of verification is to make sure that:
    390              // the local Endpoint ProfileID matches the received ProfileID OR
    391              // the message is specifically send to ZDO (this excludes the broadcast endpoint) OR
    392              // if the Wildcard ProfileID is received the message should not be sent to ZDO endpoint
    393              if ( (aff->ProfileID == epProfileID) ||
    394                   ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) ||
    395                   ((epDesc->endPoint != ZDO_EP) && ( aff->ProfileID == ZDO_WILDCARD_PROFILE_ID )) )
    396              {
    397                // Save original endpoint
    398                uint8 endpoint = aff->DstEndPoint;
    399          
    400                // overwrite with descriptor's endpoint
    401                aff->DstEndPoint = epDesc->endPoint;
    402          
    403                afBuildMSGIncoming( aff, epDesc, SrcAddress, SrcPanId, sig,
    404                                   nwkSeqNum, SecurityUse, timestamp, radius );
    405          
    406                // Restore with original endpoint
    407                aff->DstEndPoint = endpoint;
    408              }
    409          
    410              if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
    411              {
    412          #if !defined ( APS_NO_GROUPS )
    413                // Find the next endpoint for this group
    414                grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
    415                if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
    416                  return;   // No endpoint found
    417          
    418                epDesc = afFindEndPointDesc( grpEp );
    419                if ( epDesc == NULL )
    420                  return;   // Endpoint descriptor not found
    421          
    422                pList = afFindEndPointDescList( epDesc->endPoint );
   \                     ??afIncomingData_7: (+1)
   \   00000080   0x7820             LDRB     R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       afFindEndPointDescList
   \   00000086   0x4681             MOV      R9,R0
   \                     ??afIncomingData_5: (+1)
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD06B             BEQ.N    ??afIncomingData_8
   \   0000008C   0xF64F 0x7BFE      MOVW     R11,#+65534
   \   00000090   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00B             BEQ.N    ??afIncomingData_9
   \   00000098   0x7821             LDRB     R1,[R4, #+0]
   \   0000009A   0x2002             MOVS     R0,#+2
   \   0000009C   0xF8D9 0x2008      LDR      R2,[R9, #+8]
   \   000000A0   0x4790             BLX      R2
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD00A             BEQ.N    ??afIncomingData_10
   \   000000A6   0xF8B0 0xB000      LDRH     R11,[R0, #+0]
   \   000000AA   0x.... 0x....      BL       osal_mem_free
   \   000000AE   0xE005             B.N      ??afIncomingData_10
   \                     ??afIncomingData_9: (+1)
   \   000000B0   0x68A0             LDR      R0,[R4, #+8]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD002             BEQ.N    ??afIncomingData_10
   \   000000B6   0x68A0             LDR      R0,[R4, #+8]
   \   000000B8   0xF8B0 0xB002      LDRH     R11,[R0, #+2]
   \                     ??afIncomingData_10: (+1)
   \   000000BC   0x8938             LDRH     R0,[R7, #+8]
   \   000000BE   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000C2   0x4558             CMP      R0,R11
   \   000000C4   0xD00D             BEQ.N    ??afIncomingData_11
   \   000000C6   0x7820             LDRB     R0,[R4, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD102             BNE.N    ??afIncomingData_12
   \   000000CC   0x8938             LDRH     R0,[R7, #+8]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD007             BEQ.N    ??afIncomingData_11
   \                     ??afIncomingData_12: (+1)
   \   000000D2   0x7820             LDRB     R0,[R4, #+0]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD01E             BEQ.N    ??afIncomingData_13
   \   000000D8   0x8938             LDRH     R0,[R7, #+8]
   \   000000DA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD119             BNE.N    ??afIncomingData_13
   \                     ??afIncomingData_11: (+1)
   \   000000E2   0xF897 0xB002      LDRB     R11,[R7, #+2]
   \   000000E6   0x7820             LDRB     R0,[R4, #+0]
   \   000000E8   0x70B8             STRB     R0,[R7, #+2]
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EE   0x9004             STR      R0,[SP, #+16]
   \   000000F0   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   000000F4   0x0028             MOVS     R0,R5
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0x9002             STR      R0,[SP, #+8]
   \   000000FA   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000000FE   0x9001             STR      R0,[SP, #+4]
   \   00000100   0x9808             LDR      R0,[SP, #+32]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0xF8BD 0x301C      LDRH     R3,[SP, #+28]
   \   00000108   0x9A06             LDR      R2,[SP, #+24]
   \   0000010A   0x0021             MOVS     R1,R4
   \   0000010C   0x0038             MOVS     R0,R7
   \   0000010E   0x.... 0x....      BL       afBuildMSGIncoming
   \   00000112   0xF887 0xB002      STRB     R11,[R7, #+2]
   \                     ??afIncomingData_13: (+1)
   \   00000116   0x7838             LDRB     R0,[R7, #+0]
   \   00000118   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000011C   0x280C             CMP      R0,#+12
   \   0000011E   0xD112             BNE.N    ??afIncomingData_14
   \   00000120   0x4641             MOV      R1,R8
   \   00000122   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000124   0x88B8             LDRH     R0,[R7, #+4]
   \   00000126   0x.... 0x....      BL       aps_FindGroupForEndpoint
   \   0000012A   0x4680             MOV      R8,R0
   \   0000012C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000130   0xF1B8 0x0FFE      CMP      R8,#+254
   \   00000134   0xD016             BEQ.N    ??afIncomingData_1
   \                     ??afIncomingData_15: (+1)
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013A   0x.... 0x....      BL       afFindEndPointDesc
   \   0000013E   0x0004             MOVS     R4,R0
   \   00000140   0x2C00             CMP      R4,#+0
   \   00000142   0xD19D             BNE.N    ??afIncomingData_7
   \   00000144   0xE00E             B.N      ??afIncomingData_1
    423          #else
    424                return;
    425          #endif
    426              }
    427              else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_14: (+1)
   \   00000146   0x78B8             LDRB     R0,[R7, #+2]
   \   00000148   0x28FF             CMP      R0,#+255
   \   0000014A   0xD109             BNE.N    ??afIncomingData_16
    428              {
    429                pList = pList->nextDesc;
   \   0000014C   0xF8D9 0x9000      LDR      R9,[R9, #+0]
    430                if ( pList )
   \   00000150   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000154   0xD002             BEQ.N    ??afIncomingData_17
    431                  epDesc = pList->epDesc;
   \   00000156   0xF8D9 0x4004      LDR      R4,[R9, #+4]
   \   0000015A   0xE795             B.N      ??afIncomingData_5
    432                else
    433                  epDesc = NULL;
   \                     ??afIncomingData_17: (+1)
   \   0000015C   0x2400             MOVS     R4,#+0
   \   0000015E   0xE793             B.N      ??afIncomingData_5
    434              }
    435              else
    436                epDesc = NULL;
   \                     ??afIncomingData_16: (+1)
   \   00000160   0x2400             MOVS     R4,#+0
   \   00000162   0xE791             B.N      ??afIncomingData_5
    437            }
    438          }
   \                     ??afIncomingData_8: (+1)
   \                     ??afIncomingData_1: (+1)
   \   00000164   0xB009             ADD      SP,SP,#+36
   \   00000166   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    439          
    440          /*********************************************************************
    441           * @fn          afBuildMSGIncoming
    442           *
    443           * @brief       Build the message for the app
    444           *
    445           * @param
    446           *
    447           * @return      pointer to next in data buffer
    448          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    449          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    450                           zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
    451                           uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp, uint8 radius )
    452          {
   \                     afBuildMSGIncoming: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x4698             MOV      R8,R3
    453            afIncomingMSGPacket_t *MSGpkt;
    454            const uint8 len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
   \   0000000C   0x7D38             LDRB     R0,[R7, #+20]
   \   0000000E   0x3030             ADDS     R0,R0,#+48
    455            uint8 *asdu = aff->asdu;
   \   00000010   0x693D             LDR      R5,[R7, #+16]
    456            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x.... 0x....      BL       osal_msg_allocate
   \   0000001A   0x0006             MOVS     R6,R0
    457          
    458            if ( MSGpkt == NULL )
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD03E             BEQ.N    ??afBuildMSGIncoming_0
    459            {
    460              return;
    461            }
    462          
    463            MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
   \                     ??afBuildMSGIncoming_1: (+1)
   \   00000020   0x201A             MOVS     R0,#+26
   \   00000022   0x7030             STRB     R0,[R6, #+0]
    464            MSGpkt->groupId = aff->GroupID;
   \   00000024   0x88B8             LDRH     R0,[R7, #+4]
   \   00000026   0x8070             STRH     R0,[R6, #+2]
    465            MSGpkt->clusterId = aff->ClusterID;
   \   00000028   0x88F8             LDRH     R0,[R7, #+6]
   \   0000002A   0x80B0             STRH     R0,[R6, #+4]
    466            afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
   \   0000002C   0x4649             MOV      R1,R9
   \   0000002E   0x1DB0             ADDS     R0,R6,#+6
   \   00000030   0x.... 0x....      BL       afCopyAddress
    467            MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
   \   00000034   0x78F8             LDRB     R0,[R7, #+3]
   \   00000036   0x73F0             STRB     R0,[R6, #+15]
    468            MSGpkt->endPoint = epDesc->endPoint;
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x7530             STRB     R0,[R6, #+20]
    469            MSGpkt->wasBroadcast = aff->wasBroadcast;
   \   0000003C   0x7B38             LDRB     R0,[R7, #+12]
   \   0000003E   0x7570             STRB     R0,[R6, #+21]
   \   00000040   0x9808             LDR      R0,[SP, #+32]
    470            MSGpkt->LinkQuality = sig->LinkQuality;
   \   00000042   0x7801             LDRB     R1,[R0, #+0]
   \   00000044   0x75B1             STRB     R1,[R6, #+22]
    471            MSGpkt->correlation = sig->correlation;
   \   00000046   0x7841             LDRB     R1,[R0, #+1]
   \   00000048   0x75F1             STRB     R1,[R6, #+23]
    472            MSGpkt->rssi = sig->rssi;
   \   0000004A   0x7880             LDRB     R0,[R0, #+2]
   \   0000004C   0x7630             STRB     R0,[R6, #+24]
    473            MSGpkt->SecurityUse = SecurityUse;
   \   0000004E   0x980A             LDR      R0,[SP, #+40]
   \   00000050   0x7670             STRB     R0,[R6, #+25]
    474            MSGpkt->timestamp = timestamp;
   \   00000052   0x980B             LDR      R0,[SP, #+44]
   \   00000054   0x61F0             STR      R0,[R6, #+28]
    475            MSGpkt->nwkSeqNum = nwkSeqNum;
   \   00000056   0x9809             LDR      R0,[SP, #+36]
   \   00000058   0xF886 0x0020      STRB     R0,[R6, #+32]
    476            MSGpkt->macSrcAddr = aff->macSrcAddr;
   \   0000005C   0x8B78             LDRH     R0,[R7, #+26]
   \   0000005E   0x85B0             STRH     R0,[R6, #+44]
    477            MSGpkt->macDestAddr = aff->macDestAddr;
   \   00000060   0x8978             LDRH     R0,[R7, #+10]
   \   00000062   0x8270             STRH     R0,[R6, #+18]
    478            MSGpkt->srcAddr.panId = SrcPanId;
   \   00000064   0xF8A6 0x8010      STRH     R8,[R6, #+16]
    479            MSGpkt->cmd.TransSeqNumber = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF886 0x0024      STRB     R0,[R6, #+36]
    480            MSGpkt->cmd.DataLength = aff->asduLength;
   \   0000006E   0x7D38             LDRB     R0,[R7, #+20]
   \   00000070   0x84F0             STRH     R0,[R6, #+38]
    481            MSGpkt->radius = radius;
   \   00000072   0x980C             LDR      R0,[SP, #+48]
   \   00000074   0xF886 0x002E      STRB     R0,[R6, #+46]
    482          
    483            if ( MSGpkt->cmd.DataLength )
   \   00000078   0x8CF0             LDRH     R0,[R6, #+38]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD008             BEQ.N    ??afBuildMSGIncoming_2
    484            {
    485              MSGpkt->cmd.Data = (uint8 *)(MSGpkt + 1);
   \   0000007E   0xF116 0x0030      ADDS     R0,R6,#+48
   \   00000082   0x62B0             STR      R0,[R6, #+40]
    486              osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
   \   00000084   0x8CF2             LDRH     R2,[R6, #+38]
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0x6AB0             LDR      R0,[R6, #+40]
   \   0000008A   0x.... 0x....      BL       osal_memcpy
   \   0000008E   0xE001             B.N      ??afBuildMSGIncoming_3
    487            }
    488            else
    489            {
    490              MSGpkt->cmd.Data = NULL;
   \                     ??afBuildMSGIncoming_2: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x62B0             STR      R0,[R6, #+40]
    491            }
    492          
    493          #if defined ( MT_AF_CB_FUNC )
    494            // If ZDO or SAPI have registered for this endpoint, dont intercept it here
    495            if (AFCB_CHECK(CB_ID_AF_DATA_IND, *(epDesc->task_id)))
    496            {
    497              MT_AfIncomingMsg( (void *)MSGpkt );
    498              // Release the memory.
    499              osal_msg_deallocate( (void *)MSGpkt );
    500            }
    501            else
    502          #endif
    503            {
    504              // Send message through task message.
    505              osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
   \                     ??afBuildMSGIncoming_3: (+1)
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0x6860             LDR      R0,[R4, #+4]
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x.... 0x....      BL       osal_msg_send
    506            }
    507          }
   \                     ??afBuildMSGIncoming_0: (+1)
   \   0000009E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    508          
    509          /*********************************************************************
    510           * @fn      AF_DataRequest
    511           *
    512           * @brief   Common functionality for invoking APSDE_DataReq() for both
    513           *          SendMulti and MSG-Send.
    514           *
    515           * input parameters
    516           *
    517           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    518           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    519           * @param   cID - A valid cluster ID as specified by the Profile.
    520           * @param   len - Number of bytes of data pointed to by next param.
    521           * @param  *buf - A pointer to the data bytes to send.
    522           * @param  *transID - A pointer to a byte which can be modified and which will
    523           *                    be used as the transaction sequence number of the msg.
    524           * @param   options - Valid bit mask of Tx options.
    525           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    526           *
    527           * output parameters
    528           *
    529           * @param  *transID - Incremented by one if the return value is success.
    530           *
    531           * @return  afStatus_t - See previous definition of afStatus_... types.
    532          *********************************************************************/

   \                                 In section .data, align 1
    533          uint8 AF_DataRequestDiscoverRoute = DISC_ROUTE_NETWORK;
   \                     AF_DataRequestDiscoverRoute:
   \   00000000   0x01               DC8 1

   \                                 In section .text, align 2, keep-with-next
    534          afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    535                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    536                                     uint8 options, uint8 radius )
    537          {
   \                     AF_DataRequest: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
    538            pDescCB pfnDescCB;
    539            ZStatus_t stat;
    540            APSDE_DataReq_t req;
    541            afDataReqMTU_t mtu;
    542            epList_t *pList;
    543          
    544            // Verify source end point
    545            if ( srcEP == NULL )
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??AF_DataRequest_0
    546            {
    547              return afStatus_INVALID_PARAMETER;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE0F3             B.N      ??AF_DataRequest_1
    548            }
   \                     ??AF_DataRequest_0: (+1)
   \   00000016   0x9C12             LDR      R4,[SP, #+72]
    549          
    550          #if !defined( REFLECTOR )
    551            if ( dstAddr->addrMode == afAddrNotPresent )
    552            {
    553              return afStatus_INVALID_PARAMETER;
    554            }
    555          #endif
    556          
    557            // Check if route is available before sending data
    558            if ( options & AF_LIMIT_CONCENTRATOR  )
   \   00000018   0x0720             LSLS     R0,R4,#+28
   \   0000001A   0xD513             BPL.N    ??AF_DataRequest_2
    559            {
    560              if ( dstAddr->addrMode != afAddr16Bit )
   \   0000001C   0x7A28             LDRB     R0,[R5, #+8]
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD001             BEQ.N    ??AF_DataRequest_3
    561              {
    562                return ( afStatus_INVALID_PARAMETER );
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE0EB             B.N      ??AF_DataRequest_1
    563              }
    564          
    565              // First, make sure the destination is not its self, then check for an existing route.
    566              if ( (dstAddr->addr.shortAddr != NLME_GetShortAddr())
    567                  && (RTG_CheckRtStatus( dstAddr->addr.shortAddr, RT_ACTIVE, (MTO_ROUTE | NO_ROUTE_CACHE) ) != RTG_SUCCESS) )
   \                     ??AF_DataRequest_3: (+1)
   \   00000026   0x.... 0x....      BL       NLME_GetShortAddr
   \   0000002A   0x8829             LDRH     R1,[R5, #+0]
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x4281             CMP      R1,R0
   \   00000030   0xD008             BEQ.N    ??AF_DataRequest_2
   \   00000032   0x2203             MOVS     R2,#+3
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x8828             LDRH     R0,[R5, #+0]
   \   00000038   0x.... 0x....      BL       RTG_CheckRtStatus
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??AF_DataRequest_2
    568              {
    569                // A valid route to a concentrator wasn't found
    570                return ( afStatus_NO_ROUTE );
   \   00000040   0x20CD             MOVS     R0,#+205
   \   00000042   0xE0DC             B.N      ??AF_DataRequest_1
    571              }
    572            }
    573          
    574            // Validate broadcasting
    575            if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
    576                 ( dstAddr->addrMode == afAddrBroadcast )    )
   \                     ??AF_DataRequest_2: (+1)
   \   00000044   0x7A28             LDRB     R0,[R5, #+8]
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD002             BEQ.N    ??AF_DataRequest_4
   \   0000004A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000004C   0x280F             CMP      R0,#+15
   \   0000004E   0xD116             BNE.N    ??AF_DataRequest_5
    577            {
    578              // Check for valid broadcast values
    579              if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
   \                     ??AF_DataRequest_4: (+1)
   \   00000050   0x8828             LDRH     R0,[R5, #+0]
   \   00000052   0x.... 0x....      BL       NLME_IsAddressBroadcast
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00C             BEQ.N    ??AF_DataRequest_6
    580              {
    581                // Force mode to broadcast
    582                dstAddr->addrMode = afAddrBroadcast;
   \   0000005A   0x200F             MOVS     R0,#+15
   \   0000005C   0x7228             STRB     R0,[R5, #+8]
    583              }
    584              else
    585              {
    586                // Address is not a valid broadcast type
    587                if ( dstAddr->addrMode == afAddrBroadcast )
    588                {
    589                  return afStatus_INVALID_PARAMETER;
    590                }
    591              }
    592            }
    593            else if ( dstAddr->addrMode != afAddr64Bit &&
    594                      dstAddr->addrMode != afAddrGroup &&
    595                      dstAddr->addrMode != afAddrNotPresent )
    596            {
    597              return afStatus_INVALID_PARAMETER;
    598            }
    599          
    600            // Set destination address
    601            req.dstAddr.addrMode = dstAddr->addrMode;
   \                     ??AF_DataRequest_7: (+1)
   \   0000005E   0x7A28             LDRB     R0,[R5, #+8]
   \   00000060   0xF88D 0x000C      STRB     R0,[SP, #+12]
    602            if ( dstAddr->addrMode == afAddr64Bit )
   \   00000064   0x7A28             LDRB     R0,[R5, #+8]
   \   00000066   0x2803             CMP      R0,#+3
   \   00000068   0xD114             BNE.N    ??AF_DataRequest_8
    603            {
    604              osal_cpyExtAddr( req.dstAddr.addr.extAddr, dstAddr->addr.extAddr );
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0xA801             ADD      R0,SP,#+4
   \   0000006E   0x.... 0x....      BL       sAddrExtCpy
   \   00000072   0xE012             B.N      ??AF_DataRequest_9
    605            }
   \                     ??AF_DataRequest_6: (+1)
   \   00000074   0x7A28             LDRB     R0,[R5, #+8]
   \   00000076   0x280F             CMP      R0,#+15
   \   00000078   0xD1F1             BNE.N    ??AF_DataRequest_7
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xE0BF             B.N      ??AF_DataRequest_1
   \                     ??AF_DataRequest_5: (+1)
   \   0000007E   0x7A28             LDRB     R0,[R5, #+8]
   \   00000080   0x2803             CMP      R0,#+3
   \   00000082   0xD0EC             BEQ.N    ??AF_DataRequest_7
   \   00000084   0x7A28             LDRB     R0,[R5, #+8]
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD0E9             BEQ.N    ??AF_DataRequest_7
   \   0000008A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD0E6             BEQ.N    ??AF_DataRequest_7
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xE0B4             B.N      ??AF_DataRequest_1
    606            else
    607            {
    608              req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
   \                     ??AF_DataRequest_8: (+1)
   \   00000094   0x8828             LDRH     R0,[R5, #+0]
   \   00000096   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    609            }
    610          
    611            // This option is to use Wildcard ProfileID in outgoing packets
    612            if ( options & AF_WILDCARD_PROFILEID )
   \                     ??AF_DataRequest_9: (+1)
   \   0000009A   0x07A0             LSLS     R0,R4,#+30
   \   0000009C   0xD504             BPL.N    ??AF_DataRequest_10
    613            {
    614              req.profileID = ZDO_WILDCARD_PROFILE_ID;
   \   0000009E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000A2   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   \   000000A6   0xE01B             B.N      ??AF_DataRequest_11
    615            }
    616            else
    617            {
    618              req.profileID = ZDO_PROFILE_ID;
   \                     ??AF_DataRequest_10: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    619          
    620              if ( (pfnDescCB = afGetDescCB( srcEP )) )
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0x.... 0x....      BL       afGetDescCB
   \   000000B4   0x0002             MOVS     R2,R0
   \   000000B6   0x0010             MOVS     R0,R2
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD00A             BEQ.N    ??AF_DataRequest_12
    621              {
    622                uint16 *pID = (uint16 *)(pfnDescCB(
    623                                             AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
   \   000000BC   0x7831             LDRB     R1,[R6, #+0]
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x4790             BLX      R2
    624                if ( pID )
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00C             BEQ.N    ??AF_DataRequest_11
    625                {
    626                  req.profileID = *pID;
   \   000000C6   0x8801             LDRH     R1,[R0, #+0]
   \   000000C8   0xF8AD 0x1014      STRH     R1,[SP, #+20]
    627                  osal_mem_free( pID );
   \   000000CC   0x.... 0x....      BL       osal_mem_free
   \   000000D0   0xE006             B.N      ??AF_DataRequest_11
    628                }
    629              }
    630              else if ( srcEP->simpleDesc )
   \                     ??AF_DataRequest_12: (+1)
   \   000000D2   0x68B0             LDR      R0,[R6, #+8]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD003             BEQ.N    ??AF_DataRequest_11
    631              {
    632                req.profileID = srcEP->simpleDesc->AppProfId;
   \   000000D8   0x68B0             LDR      R0,[R6, #+8]
   \   000000DA   0x8840             LDRH     R0,[R0, #+2]
   \   000000DC   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    633              }
    634            }
    635          
    636            req.txOptions = 0;
   \                     ??AF_DataRequest_11: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    637          
    638            if ( ( options & AF_ACK_REQUEST              ) &&
    639                 ( req.dstAddr.addrMode != AddrBroadcast ) &&
    640                 ( req.dstAddr.addrMode != AddrGroup     )    )
   \   000000E6   0x06E0             LSLS     R0,R4,#+27
   \   000000E8   0xD50D             BPL.N    ??AF_DataRequest_13
   \   000000EA   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000EE   0x280F             CMP      R0,#+15
   \   000000F0   0xD009             BEQ.N    ??AF_DataRequest_13
   \   000000F2   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xD005             BEQ.N    ??AF_DataRequest_13
    641            {
    642              req.txOptions |=  APS_TX_OPTIONS_ACK;
   \   000000FA   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   000000FE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000102   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    643            }
    644          
    645            if ( options & AF_SKIP_ROUTING )
   \                     ??AF_DataRequest_13: (+1)
   \   00000106   0x0620             LSLS     R0,R4,#+24
   \   00000108   0xD505             BPL.N    ??AF_DataRequest_14
    646            {
    647              req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
   \   0000010A   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   0000010E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000112   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    648            }
    649          
    650            if ( options & AF_EN_SECURITY )
   \                     ??AF_DataRequest_14: (+1)
   \   00000116   0x0660             LSLS     R0,R4,#+25
   \   00000118   0xD509             BPL.N    ??AF_DataRequest_15
    651            {
    652              req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
   \   0000011A   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   0000011E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000122   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    653              mtu.aps.secure = TRUE;
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000012C   0xE002             B.N      ??AF_DataRequest_16
    654            }
    655            else
    656            {
    657              mtu.aps.secure = FALSE;
   \                     ??AF_DataRequest_15: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF88D 0x0001      STRB     R0,[SP, #+1]
    658            }
    659          
    660            if ( options & AF_PREPROCESS )
   \                     ??AF_DataRequest_16: (+1)
   \   00000134   0x0760             LSLS     R0,R4,#+29
   \   00000136   0xD505             BPL.N    ??AF_DataRequest_17
    661            {
    662              req.txOptions |=  APS_TX_OPTIONS_PREPROCESS;
   \   00000138   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   0000013C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000140   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    663            }
    664          
    665            mtu.kvp = FALSE;
   \                     ??AF_DataRequest_17: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xF88D 0x0000      STRB     R0,[SP, #+0]
    666          
    667            if ( options & AF_SUPRESS_ROUTE_DISC_NETWORK )
   \   0000014A   0x06A0             LSLS     R0,R4,#+26
   \   0000014C   0xD503             BPL.N    ??AF_DataRequest_18
    668            {
    669              req.discoverRoute = DISC_ROUTE_INITIATE;
   \   0000014E   0x2004             MOVS     R0,#+4
   \   00000150   0xF88D 0x001F      STRB     R0,[SP, #+31]
   \   00000154   0xE003             B.N      ??AF_DataRequest_19
    670            }
    671            else
    672            {
    673              req.discoverRoute = AF_DataRequestDiscoverRoute;
   \                     ??AF_DataRequest_18: (+1)
   \   00000156   0x....             LDR.N    R0,??DataTable7_1
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0xF88D 0x001F      STRB     R0,[SP, #+31]
   \                     ??AF_DataRequest_19: (+1)
   \   0000015E   0x9C11             LDR      R4,[SP, #+68]
    674            }
    675          
    676            req.transID       = *transID;
   \   00000160   0x7820             LDRB     R0,[R4, #+0]
   \   00000162   0xF88D 0x001E      STRB     R0,[SP, #+30]
    677            req.srcEP         = srcEP->endPoint;
   \   00000166   0x7830             LDRB     R0,[R6, #+0]
   \   00000168   0xF88D 0x000E      STRB     R0,[SP, #+14]
    678            req.dstEP         = dstAddr->endPoint;
   \   0000016C   0x7A68             LDRB     R0,[R5, #+9]
   \   0000016E   0xF88D 0x000F      STRB     R0,[SP, #+15]
    679            req.clusterID     = cID;
   \   00000172   0xF8AD 0x7012      STRH     R7,[SP, #+18]
    680            req.asduLen       = len;
   \   00000176   0xF8AD 0x8016      STRH     R8,[SP, #+22]
    681            req.asdu          = buf;
   \   0000017A   0x9810             LDR      R0,[SP, #+64]
   \   0000017C   0x9006             STR      R0,[SP, #+24]
    682            req.radiusCounter = radius;
   \   0000017E   0x9813             LDR      R0,[SP, #+76]
   \   00000180   0xF88D 0x0020      STRB     R0,[SP, #+32]
    683          #if defined ( INTER_PAN )
    684            req.dstPanId      = dstAddr->panId;
    685          #endif // INTER_PAN
    686          
    687            // Look if there is a Callback function registered for this endpoint
    688            // The callback is used to control the AF Transaction ID used when sending messages
    689            pList = afFindEndPointDescList( srcEP->endPoint );
   \   00000184   0x7830             LDRB     R0,[R6, #+0]
   \   00000186   0x.... 0x....      BL       afFindEndPointDescList
   \   0000018A   0x0001             MOVS     R1,R0
    690          
    691            if ( ( pList != NULL ) && ( pList->pfnApplCB != NULL ) )
   \   0000018C   0x2900             CMP      R1,#+0
   \   0000018E   0xD005             BEQ.N    ??AF_DataRequest_20
   \   00000190   0x6908             LDR      R0,[R1, #+16]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD002             BEQ.N    ??AF_DataRequest_20
    692            {
    693              pList->pfnApplCB( &req );
   \   00000196   0xA801             ADD      R0,SP,#+4
   \   00000198   0x6909             LDR      R1,[R1, #+16]
   \   0000019A   0x4788             BLX      R1
    694            }
    695          
    696          #if defined ( INTER_PAN )
    697            if ( StubAPS_InterPan( dstAddr->panId, dstAddr->endPoint ) )
    698            {
    699              if ( len > INTERP_DataReqMTU() )
    700              {
    701                stat = afStatus_INVALID_PARAMETER;
    702              }
    703              else
    704              {
    705                stat = INTERP_DataReq( &req );
    706              }
    707            }
    708            else
    709          #endif // INTER_PAN
    710            {
    711              if (len > afDataReqMTU( &mtu ) )
   \                     ??AF_DataRequest_20: (+1)
   \   0000019C   0xA800             ADD      R0,SP,#+0
   \   0000019E   0x.... 0x....      BL       afDataReqMTU
   \   000001A2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001A4   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001A8   0x4540             CMP      R0,R8
   \   000001AA   0xD20B             BCS.N    ??AF_DataRequest_21
    712              {
    713                if (apsfSendFragmented)
   \   000001AC   0x....             LDR.N    R0,??DataTable7_2
   \   000001AE   0x6800             LDR      R0,[R0, #+0]
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD005             BEQ.N    ??AF_DataRequest_22
    714                {
    715                  stat = (*apsfSendFragmented)( &req );
   \   000001B4   0xA801             ADD      R0,SP,#+4
   \   000001B6   0x....             LDR.N    R1,??DataTable7_2
   \   000001B8   0x6809             LDR      R1,[R1, #+0]
   \   000001BA   0x4788             BLX      R1
   \   000001BC   0x0005             MOVS     R5,R0
   \   000001BE   0xE005             B.N      ??AF_DataRequest_23
    716                }
    717                else
    718                {
    719                  stat = afStatus_INVALID_PARAMETER;
   \                     ??AF_DataRequest_22: (+1)
   \   000001C0   0x2502             MOVS     R5,#+2
   \   000001C2   0xE003             B.N      ??AF_DataRequest_23
    720                }
    721              }
    722              else
    723              {
    724                stat = APSDE_DataReq( &req );
   \                     ??AF_DataRequest_21: (+1)
   \   000001C4   0xA801             ADD      R0,SP,#+4
   \   000001C6   0x.... 0x....      BL       APSDE_DataReq
   \   000001CA   0x0005             MOVS     R5,R0
    725              }
    726            }
    727          
    728            /*
    729             * If this is an EndPoint-to-EndPoint message on the same device, it will not
    730             * get added to the NWK databufs. So it will not go OTA and it will not get
    731             * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
    732             * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
    733             * message with the first in line TransSeqNumber, even on a multi message.
    734             * Also note that a reflected msg will not have its confirmation generated
    735             * here.
    736             */
    737            if ( (req.dstAddr.addrMode == Addr16Bit) &&
    738                 (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
   \                     ??AF_DataRequest_23: (+1)
   \   000001CC   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000001D0   0x2802             CMP      R0,#+2
   \   000001D2   0xD10C             BNE.N    ??AF_DataRequest_24
   \   000001D4   0x.... 0x....      BL       NLME_GetShortAddr
   \   000001D8   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000001DC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001DE   0x4281             CMP      R1,R0
   \   000001E0   0xD105             BNE.N    ??AF_DataRequest_24
    739            {
    740              afDataConfirm( srcEP->endPoint, *transID, stat );
   \   000001E2   0x002A             MOVS     R2,R5
   \   000001E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001E6   0x7821             LDRB     R1,[R4, #+0]
   \   000001E8   0x7830             LDRB     R0,[R6, #+0]
   \   000001EA   0x.... 0x....      BL       afDataConfirm
    741            }
    742          
    743            if ( stat == afStatus_SUCCESS )
   \                     ??AF_DataRequest_24: (+1)
   \   000001EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001F0   0x2D00             CMP      R5,#+0
   \   000001F2   0xD102             BNE.N    ??AF_DataRequest_25
    744            {
    745              (*transID)++;
   \   000001F4   0x7820             LDRB     R0,[R4, #+0]
   \   000001F6   0x1C40             ADDS     R0,R0,#+1
   \   000001F8   0x7020             STRB     R0,[R4, #+0]
    746            }
    747          
    748            return (afStatus_t)stat;
   \                     ??AF_DataRequest_25: (+1)
   \   000001FA   0x0028             MOVS     R0,R5
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??AF_DataRequest_1: (+1)
   \   000001FE   0xB00A             ADD      SP,SP,#+40
   \   00000200   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    749          }
    750          
    751          #if defined ( ZIGBEE_SOURCE_ROUTING )
    752          /*********************************************************************
    753           * @fn      AF_DataRequestSrcRtg
    754           *
    755           * @brief   Common functionality for invoking APSDE_DataReq() for both
    756           *          SendMulti and MSG-Send.
    757           *
    758           * input parameters
    759           *
    760           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    761           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    762           * @param   cID - A valid cluster ID as specified by the Profile.
    763           * @param   len - Number of bytes of data pointed to by next param.
    764           * @param  *buf - A pointer to the data bytes to send.
    765           * @param  *transID - A pointer to a byte which can be modified and which will
    766           *                    be used as the transaction sequence number of the msg.
    767           * @param   options - Valid bit mask of Tx options.
    768           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    769           * @param   relayCnt - Number of devices in the relay list
    770           * @param   pRelayList - Pointer to the relay list
    771           *
    772           * output parameters
    773           *
    774           * @param  *transID - Incremented by one if the return value is success.
    775           *
    776           * @return  afStatus_t - See previous definition of afStatus_... types.
    777          *********************************************************************/
    778          

   \                                 In section .text, align 2, keep-with-next
    779          afStatus_t AF_DataRequestSrcRtg( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    780                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    781                                     uint8 options, uint8 radius, uint8 relayCnt, uint16* pRelayList )
    782          {
   \                     AF_DataRequestSrcRtg: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    783            uint8 status;
    784          
    785            /* Add the source route to the source routing table */
    786            status = RTG_AddSrcRtgEntry_Guaranteed( dstAddr->addr.shortAddr, relayCnt,
    787                                                   pRelayList );
   \   0000000C   0x9A0F             LDR      R2,[SP, #+60]
   \   0000000E   0x990E             LDR      R1,[SP, #+56]
   \   00000010   0x8820             LDRH     R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       RTG_AddSrcRtgEntry_Guaranteed
    788          
    789            if( status == RTG_SUCCESS)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD110             BNE.N    ??AF_DataRequestSrcRtg_0
    790            {
    791              /* Call AF_DataRequest to send the data */
    792              status = AF_DataRequest( dstAddr, srcEP, cID, len, buf, transID, options, radius );
   \   0000001C   0x980D             LDR      R0,[SP, #+52]
   \   0000001E   0x9003             STR      R0,[SP, #+12]
   \   00000020   0x980C             LDR      R0,[SP, #+48]
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0x980B             LDR      R0,[SP, #+44]
   \   00000026   0x9001             STR      R0,[SP, #+4]
   \   00000028   0x980A             LDR      R0,[SP, #+40]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x003B             MOVS     R3,R7
   \   0000002E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       AF_DataRequest
   \   0000003C   0xE005             B.N      ??AF_DataRequestSrcRtg_1
    793            }
    794            else if( status == RTG_INVALID_PATH )
   \                     ??AF_DataRequestSrcRtg_0: (+1)
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x2805             CMP      R0,#+5
   \   00000042   0xD101             BNE.N    ??AF_DataRequestSrcRtg_2
    795            {
    796              /* The source route relay count is exceeding the network limit */
    797              status = afStatus_INVALID_PARAMETER;
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xE000             B.N      ??AF_DataRequestSrcRtg_1
    798            }
    799            else
    800            {
    801              /* The guaranteed adding entry fails due to memory failure */
    802              status = afStatus_MEM_FAIL;
   \                     ??AF_DataRequestSrcRtg_2: (+1)
   \   00000048   0x2010             MOVS     R0,#+16
    803            }
    804            return status;
   \                     ??AF_DataRequestSrcRtg_1: (+1)
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xB005             ADD      SP,SP,#+20
   \   0000004E   0xBDF0             POP      {R4-R7,PC}       ;; return
    805          }
    806          
    807          #endif
    808          
    809          /*********************************************************************
    810           * @fn      afFindEndPointDescList
    811           *
    812           * @brief   Find the endpoint description entry from the endpoint
    813           *          number.
    814           *
    815           * @param   EndPoint - Application Endpoint to look for
    816           *
    817           * @return  the address to the endpoint/interface description entry
    818          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    819          static epList_t *afFindEndPointDescList( uint8 EndPoint )
    820          {
    821            epList_t *epSearch;
    822          
    823            for (epSearch = epList; epSearch != NULL; epSearch = epSearch->nextDesc)
   \                     afFindEndPointDescList: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xE000             B.N      ??afFindEndPointDescList_0
   \                     ??afFindEndPointDescList_1: (+1)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \                     ??afFindEndPointDescList_0: (+1)
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??afFindEndPointDescList_2
    824            {
    825              if (epSearch->epDesc->endPoint == EndPoint)
   \   0000000C   0x684A             LDR      R2,[R1, #+4]
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4282             CMP      R2,R0
   \   00000014   0xD1F7             BNE.N    ??afFindEndPointDescList_1
    826              {
    827                break;
    828              }
    829            }
    830          
    831            return epSearch;
   \                     ??afFindEndPointDescList_2: (+1)
   \   00000016   0x0008             MOVS     R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    832          }
    833          
    834          /*********************************************************************
    835           * @fn      afFindEndPointDesc
    836           *
    837           * @brief   Find the endpoint description entry from the endpoint
    838           *          number.
    839           *
    840           * @param   EndPoint - Application Endpoint to look for
    841           *
    842           * @return  the address to the endpoint/interface description entry
    843          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    844          endPointDesc_t *afFindEndPointDesc( uint8 EndPoint )
    845          {
   \                     afFindEndPointDesc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    846            epList_t *epSearch;
    847          
    848            // Look for the endpoint
    849            epSearch = afFindEndPointDescList( EndPoint );
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x.... 0x....      BL       afFindEndPointDescList
    850          
    851            if ( epSearch )
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??afFindEndPointDesc_0
    852              return ( epSearch->epDesc );
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0xE000             B.N      ??afFindEndPointDesc_1
    853            else
    854              return ( (endPointDesc_t *)NULL );
   \                     ??afFindEndPointDesc_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??afFindEndPointDesc_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    855          }
    856          
    857          /*********************************************************************
    858           * @fn      afFindSimpleDesc
    859           *
    860           * @brief   Find the Simple Descriptor from the endpoint number.
    861           *
    862           * @param   EP - Application Endpoint to look for.
    863           *
    864           * @return  Non-zero to indicate that the descriptor memory must be freed.
    865          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    866          uint8 afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, uint8 EP )
    867          {
   \                     afFindSimpleDesc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    868            epList_t *epItem = afFindEndPointDescList( EP );
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       afFindEndPointDescList
   \   0000000E   0x0002             MOVS     R2,R0
    869            uint8 rtrn = FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
    870          
    871            if ( epItem )
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD00E             BEQ.N    ??afFindSimpleDesc_0
    872            {
    873              if ( epItem->pfnDescCB )
   \   00000016   0x6891             LDR      R1,[R2, #+8]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD007             BEQ.N    ??afFindSimpleDesc_1
    874              {
    875                *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x6892             LDR      R2,[R2, #+8]
   \   00000024   0x4790             BLX      R2
   \   00000026   0x6020             STR      R0,[R4, #+0]
    876                rtrn = TRUE;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE005             B.N      ??afFindSimpleDesc_2
    877              }
    878              else
    879              {
    880                *ppDesc = epItem->epDesc->simpleDesc;
   \                     ??afFindSimpleDesc_1: (+1)
   \   0000002C   0x6851             LDR      R1,[R2, #+4]
   \   0000002E   0x6889             LDR      R1,[R1, #+8]
   \   00000030   0x6021             STR      R1,[R4, #+0]
   \   00000032   0xE001             B.N      ??afFindSimpleDesc_2
    881              }
    882            }
    883            else
    884            {
    885              *ppDesc = NULL;
   \                     ??afFindSimpleDesc_0: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6021             STR      R1,[R4, #+0]
    886            }
    887          
    888            return rtrn;
   \                     ??afFindSimpleDesc_2: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    889          }
    890          
    891          /*********************************************************************
    892           * @fn      afGetDescCB
    893           *
    894           * @brief   Get the Descriptor callback function.
    895           *
    896           * @param   epDesc - pointer to the endpoint descriptor
    897           *
    898           * @return  function pointer or NULL
    899          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    900          static pDescCB afGetDescCB( endPointDesc_t *epDesc )
    901          {
    902            epList_t *epSearch;
    903          
    904            // Start at the beginning
    905            epSearch = epList;
   \                     afGetDescCB: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xE000             B.N      ??afGetDescCB_0
    906          
    907            // Look through the list until the end
    908            while ( epSearch )
    909            {
    910              // Is there a match?
    911              if ( epSearch->epDesc == epDesc )
    912              {
    913                return ( epSearch->pfnDescCB );
    914              }
    915              else
    916                epSearch = epSearch->nextDesc;  // Next entry
   \                     ??afGetDescCB_1: (+1)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \                     ??afGetDescCB_0: (+1)
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??afGetDescCB_2
   \   0000000C   0x684A             LDR      R2,[R1, #+4]
   \   0000000E   0x4282             CMP      R2,R0
   \   00000010   0xD1F9             BNE.N    ??afGetDescCB_1
   \   00000012   0x6888             LDR      R0,[R1, #+8]
   \   00000014   0xE000             B.N      ??afGetDescCB_3
    917            }
    918          
    919            return ( (pDescCB)NULL );
   \                     ??afGetDescCB_2: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??afGetDescCB_3: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    920          }
    921          
    922          /*********************************************************************
    923           * @fn      afDataReqMTU
    924           *
    925           * @brief   Get the Data Request MTU(Max Transport Unit).
    926           *
    927           * @param   fields - afDataReqMTU_t
    928           *
    929           * @return  uint8(MTU)
    930          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    931          uint8 afDataReqMTU( afDataReqMTU_t* fields )
    932          {
   \                     afDataReqMTU: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    933            uint8 len;
    934            uint8 hdr;
    935          
    936            if ( fields->kvp == TRUE )
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??afDataReqMTU_0
    937            {
    938              hdr = AF_HDR_KVP_MAX_LEN;
   \   00000008   0x2408             MOVS     R4,#+8
   \   0000000A   0xE000             B.N      ??afDataReqMTU_1
    939            }
    940            else
    941            {
    942              hdr = AF_HDR_V1_1_MAX_LEN;
   \                     ??afDataReqMTU_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
    943            }
    944          
    945            len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
   \                     ??afDataReqMTU_1: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x.... 0x....      BL       APSDE_DataReqMTU
   \   00000014   0x1B00             SUBS     R0,R0,R4
    946          
    947            return len;
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    948          }
    949          
    950          /*********************************************************************
    951           * @fn      afGetMatch
    952           *
    953           * @brief   Set the allow response flag.
    954           *
    955           * @param   ep - Application Endpoint to look for
    956           * @param   action - true - allow response, false - no response
    957           *
    958           * @return  TRUE allow responses, FALSE no response
    959          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    960          uint8 afGetMatch( uint8 ep )
    961          {
   \                     afGetMatch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    962            epList_t *epSearch;
    963          
    964            // Look for the endpoint
    965            epSearch = afFindEndPointDescList( ep );
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x.... 0x....      BL       afFindEndPointDescList
    966          
    967            if ( epSearch )
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??afGetMatch_0
    968            {
    969              if ( epSearch->flags & eEP_AllowMatch )
   \   0000000C   0x7B80             LDRB     R0,[R0, #+14]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD501             BPL.N    ??afGetMatch_1
    970                return ( TRUE );
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE002             B.N      ??afGetMatch_2
    971              else
    972                return ( FALSE );
   \                     ??afGetMatch_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B.N      ??afGetMatch_2
    973            }
    974            else
    975              return ( FALSE );
   \                     ??afGetMatch_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??afGetMatch_2: (+1)
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    976          }
    977          
    978          /*********************************************************************
    979           * @fn      afSetMatch
    980           *
    981           * @brief   Set the allow response flag.
    982           *
    983           * @param   ep - Application Endpoint to look for
    984           * @param   action - true - allow response, false - no response
    985           *
    986           * @return  TRUE if success, FALSE if endpoint not found
    987          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    988          uint8 afSetMatch( uint8 ep, uint8 action )
    989          {
   \                     afSetMatch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    990            epList_t *epSearch;
    991          
    992            // Look for the endpoint
    993            epSearch = afFindEndPointDescList( ep );
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
    994          
    995            if ( epSearch )
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00D             BEQ.N    ??afSetMatch_0
    996            {
    997              if ( action )
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??afSetMatch_1
    998              {
    999                epSearch->flags |= eEP_AllowMatch;
   \   00000014   0x7B81             LDRB     R1,[R0, #+14]
   \   00000016   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000001A   0x7381             STRB     R1,[R0, #+14]
   \   0000001C   0xE003             B.N      ??afSetMatch_2
   1000              }
   1001              else
   1002              {
   1003                epSearch->flags &= (eEP_AllowMatch ^ 0xFFFF);
   \                     ??afSetMatch_1: (+1)
   \   0000001E   0x7B81             LDRB     R1,[R0, #+14]
   \   00000020   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \   00000024   0x7381             STRB     R1,[R0, #+14]
   1004              }
   1005              return ( TRUE );
   \                     ??afSetMatch_2: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE000             B.N      ??afSetMatch_3
   1006            }
   1007            else
   1008              return ( FALSE );
   \                     ??afSetMatch_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??afSetMatch_3: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1009          }
   1010          
   1011          /*********************************************************************
   1012           * @fn      afNumEndPoints
   1013           *
   1014           * @brief   Returns the number of endpoints defined (including 0)
   1015           *
   1016           * @param   none
   1017           *
   1018           * @return  number of endpoints
   1019          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1020          uint8 afNumEndPoints( void )
   1021          {
   1022            epList_t *epSearch;
   1023            uint8 endpoints;
   1024          
   1025            // Start at the beginning
   1026            epSearch = epList;
   \                     afNumEndPoints: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   1027            endpoints = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xE001             B.N      ??afNumEndPoints_0
   1028          
   1029            while ( epSearch )
   1030            {
   1031              endpoints++;
   \                     ??afNumEndPoints_1: (+1)
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   1032              epSearch = epSearch->nextDesc;
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   1033            }
   \                     ??afNumEndPoints_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD1FB             BNE.N    ??afNumEndPoints_1
   1034          
   1035            return ( endpoints );
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
   1036          }
   1037          
   1038          /*********************************************************************
   1039           * @fn      afEndPoints
   1040           *
   1041           * @brief   Fills in the passed in buffer with the endpoint (numbers).
   1042           *          Use afNumEndPoints to find out how big a buffer to supply.
   1043           *
   1044           * @param   epBuf - pointer to mem used
   1045           *
   1046           * @return  void
   1047          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1048          void afEndPoints( uint8 *epBuf, uint8 skipZDO )
   1049          {
   1050            epList_t *epSearch;
   1051            uint8 endPoint;
   1052          
   1053            // Start at the beginning
   1054            epSearch = epList;
   \                     afEndPoints: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xE00A             B.N      ??afEndPoints_0
   1055          
   1056            while ( epSearch )
   1057            {
   1058              endPoint = epSearch->epDesc->endPoint;
   \                     ??afEndPoints_1: (+1)
   \   00000006   0x6853             LDR      R3,[R2, #+4]
   \   00000008   0x781B             LDRB     R3,[R3, #+0]
   1059          
   1060              if ( !skipZDO || endPoint != 0 )
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??afEndPoints_2
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD001             BEQ.N    ??afEndPoints_3
   1061                *epBuf++ = endPoint;
   \                     ??afEndPoints_2: (+1)
   \   00000016   0x7003             STRB     R3,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   1062          
   1063              epSearch = epSearch->nextDesc;
   \                     ??afEndPoints_3: (+1)
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   1064            }
   \                     ??afEndPoints_0: (+1)
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD1F2             BNE.N    ??afEndPoints_1
   1065          }
   \   00000020   0x4770             BX       LR               ;; return
   1066          
   1067          /*********************************************************************
   1068           * @fn      afCopyAddress
   1069           *
   1070           * @brief   Fills in the passed in afAddrType_t parameter with the corresponding information
   1071           *          from the zAddrType_t parameter.
   1072           *
   1073           * @param   epBuf - pointer to mem used
   1074           *
   1075           * @return  void
   1076          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1077          void afCopyAddress( afAddrType_t *afAddr, zAddrType_t *zAddr )
   1078          {
   \                     afCopyAddress: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1079            afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
   \   00000004   0x7A08             LDRB     R0,[R1, #+8]
   \   00000006   0x7220             STRB     R0,[R4, #+8]
   1080            if ( zAddr->addrMode == Addr64Bit )
   \   00000008   0x7A08             LDRB     R0,[R1, #+8]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD103             BNE.N    ??afCopyAddress_0
   1081            {
   1082              (void)osal_cpyExtAddr( afAddr->addr.extAddr, zAddr->addr.extAddr );
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       sAddrExtCpy
   \   00000014   0xE001             B.N      ??afCopyAddress_1
   1083            }
   1084            else
   1085            {
   1086              afAddr->addr.shortAddr = zAddr->addr.shortAddr;
   \                     ??afCopyAddress_0: (+1)
   \   00000016   0x8808             LDRH     R0,[R1, #+0]
   \   00000018   0x8020             STRH     R0,[R4, #+0]
   1087            }
   1088          
   1089            // Since zAddrType_t has no INTER-PAN information, set the panId member to zero.
   1090            afAddr->panId = 0;
   \                     ??afCopyAddress_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x8160             STRH     R0,[R4, #+10]
   1091          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1092          
   1093          /*******************************************************************************
   1094           * @fn          afAPSF_ConfigGet
   1095           *
   1096           * @brief       This function ascertains the fragmentation configuration that corresponds to
   1097           *              the specified EndPoint.
   1098           *
   1099           * input parameters
   1100           *
   1101           * @param       endPoint - The source EP of a Tx or destination EP of a Rx fragmented message.
   1102           *
   1103           * output parameters
   1104           *
   1105           * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
   1106           *
   1107           * @return      None.
   1108          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1109          void afAPSF_ConfigGet(uint8 endPoint, afAPSF_Config_t *pCfg)
   1110          {
   \                     afAPSF_ConfigGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1111            epList_t *pList = afFindEndPointDescList(endPoint);
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   1112          
   1113            if (pList == NULL)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??afAPSF_ConfigGet_0
   1114            {
   1115              pCfg->frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
   \   0000000E   0x2032             MOVS     R0,#+50
   \   00000010   0x7020             STRB     R0,[R4, #+0]
   1116              pCfg->windowSize = APSF_DEFAULT_WINDOW_SIZE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7060             STRB     R0,[R4, #+1]
   \   00000016   0xE005             B.N      ??afAPSF_ConfigGet_1
   1117            }
   1118            else
   1119            {
   1120              (void)osal_memcpy(pCfg, &pList->apsfCfg, sizeof(afAPSF_Config_t));
   \                     ??afAPSF_ConfigGet_0: (+1)
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0xF110 0x010C      ADDS     R1,R0,#+12
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       osal_memcpy
   1121            }
   1122          }
   \                     ??afAPSF_ConfigGet_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1123          
   1124          /***************************************************************************
   1125           * @fn          afAPSF_ConfigSet
   1126           *
   1127           * @brief       This function attempts to set the fragmentation configuration that corresponds to
   1128           *              the specified EndPoint.
   1129           *
   1130           * input parameters
   1131           *
   1132           * @param       endPoint - The specific EndPoint for which to set the fragmentation configuration.
   1133           * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
   1134           *
   1135           * output parameters
   1136           *
   1137           * None.
   1138           *
   1139           * @return      afStatus_SUCCESS for success.
   1140           *              afStatus_INVALID_PARAMETER if the specified EndPoint is not registered.
   1141          *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1142          afStatus_t afAPSF_ConfigSet(uint8 endPoint, afAPSF_Config_t *pCfg)
   1143          {
   \                     afAPSF_ConfigSet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1144            epList_t *pList = afFindEndPointDescList(endPoint);
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   1145          
   1146            if (pList == NULL)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??afAPSF_ConfigSet_0
   1147            {
   1148              return afStatus_INVALID_PARAMETER;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE005             B.N      ??afAPSF_ConfigSet_1
   1149            }
   1150          
   1151            (void)osal_memcpy(&pList->apsfCfg, pCfg, sizeof(afAPSF_Config_t));
   \                     ??afAPSF_ConfigSet_0: (+1)
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x300C             ADDS     R0,R0,#+12
   \   00000018   0x.... 0x....      BL       osal_memcpy
   1152            return afStatus_SUCCESS;
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??afAPSF_ConfigSet_1: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1153          }
   1154          
   1155          /***************************************************************************
   1156           * @fn          afSetApplCB
   1157           *
   1158           * @brief       Sets the pointer to the Application Callback function for a
   1159           *              specific EndPoint.
   1160           *
   1161           * input parameters
   1162           *
   1163           * @param       endPoint - The specific EndPoint for which to set Application Callback.
   1164           * @param       pApplFn - A pointer to the Application Callback function.
   1165           *
   1166           * output parameters
   1167           *
   1168           * None.
   1169           *
   1170           * @return      TRUE if success, FALSE if endpoint not found
   1171          **************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1172          uint8 afSetApplCB( uint8 endPoint, pApplCB pApplFn )
   1173          {
   \                     afSetApplCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1174            if ( pApplFn != NULL )
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD007             BEQ.N    ??afSetApplCB_0
   1175            {
   1176              epList_t *epSearch;
   1177          
   1178              // Look for the endpoint
   1179              epSearch = afFindEndPointDescList( endPoint );
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       afFindEndPointDescList
   1180          
   1181              if ( epSearch )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??afSetApplCB_0
   1182              {
   1183                epSearch->pfnApplCB = pApplFn;
   \   00000014   0x6104             STR      R4,[R0, #+16]
   1184          
   1185                return ( TRUE );
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??afSetApplCB_1
   1186              }
   1187            }
   1188          
   1189            return ( FALSE );
   \                     ??afSetApplCB_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??afSetApplCB_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1190          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     epList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     AF_DataRequestDiscoverRoute

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     apsfSendFragmented
   1191          
   1192          /**************************************************************************************************
   1193          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   AF_DataRequest
        64   -- Indirect call
        64   -> APSDE_DataReq
        64   -> NLME_GetShortAddr
        64   -> NLME_IsAddressBroadcast
        64   -> RTG_CheckRtStatus
        64   -> afDataConfirm
        64   -> afDataReqMTU
        64   -> afFindEndPointDescList
        64   -> afGetDescCB
        64   -> osal_mem_free
        64   -> sAddrExtCpy
      40   AF_DataRequestSrcRtg
        40   -> AF_DataRequest
        40   -> RTG_AddSrcRtgEntry_Guaranteed
       8   afAPSF_ConfigGet
         8   -> afFindEndPointDescList
         8   -> osal_memcpy
       8   afAPSF_ConfigSet
         8   -> afFindEndPointDescList
         8   -> osal_memcpy
      32   afBuildMSGIncoming
        32   -> afCopyAddress
        32   -> osal_memcpy
        32   -> osal_msg_allocate
        32   -> osal_msg_send
       8   afCopyAddress
         8   -> sAddrExtCpy
      24   afDataConfirm
        24   -> afFindEndPointDesc
        24   -> osal_msg_allocate
        24   -> osal_msg_send
       8   afDataReqMTU
         8   -> APSDE_DataReqMTU
       8   afDelete
         8   -> osal_mem_free
       0   afEndPoints
       8   afFindEndPointDesc
         8   -> afFindEndPointDescList
       0   afFindEndPointDescList
      16   afFindSimpleDesc
        16   -- Indirect call
        16   -> afFindEndPointDescList
       0   afGetDescCB
       8   afGetMatch
         8   -> afFindEndPointDescList
      72   afIncomingData
        72   -- Indirect call
        72   -> afBuildMSGIncoming
        72   -> afFindEndPointDesc
        72   -> afFindEndPointDescList
        72   -> aps_FindGroupForEndpoint
        72   -> osal_mem_free
       0   afNumEndPoints
      24   afReflectError
        24   -> afFindEndPointDesc
        24   -> osal_msg_allocate
        24   -> osal_msg_send
       8   afRegister
         8   -> afFindEndPointDescList
         8   -> afRegisterExtended
      16   afRegisterExtended
        16   -> osal_mem_alloc
       8   afSetApplCB
         8   -> afFindEndPointDescList
       8   afSetMatch
         8   -> afFindEndPointDescList


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
     516  AF_DataRequest
       1  AF_DataRequestDiscoverRoute
      80  AF_DataRequestSrcRtg
      38  afAPSF_ConfigGet
      32  afAPSF_ConfigSet
     162  afBuildMSGIncoming
      32  afCopyAddress
      54  afDataConfirm
      26  afDataReqMTU
      92  afDelete
      34  afEndPoints
      20  afFindEndPointDesc
      26  afFindEndPointDescList
      60  afFindSimpleDesc
      26  afGetDescCB
      30  afGetMatch
     362  afIncomingData
      20  afNumEndPoints
      70  afReflectError
      42  afRegister
      52  afRegisterExtended
      30  afSetApplCB
      46  afSetMatch
       4  epList

 
     4 bytes in section .bss
     1 byte  in section .data
 1 862 bytes in section .text
 
 1 862 bytes of CODE memory
     5 bytes of DATA memory

Errors: none
Warnings: none
