###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        26/Apr/2015  14:16:18
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\osal\mcu\cc2538\armcm3flashutil.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\osal\mcu\cc2538\armcm3flashutil.c" -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\armcm3flashutil.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\Obj\armcm3flashutil.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\osal\mcu\cc2538\armcm3flashutil.c
      1          /*******************************************************************************
      2            Filename:       armcm3flashutil.c
      3            Revised:        $Date: 2013-05-09 21:41:33 -0700 (Thu, 09 May 2013) $
      4            Revision:       $Revision: 34219 $
      5          
      6            Description:    Utility functions to erase/write flash memory pages.
      7          
      8          
      9            Copyright 2010-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          *******************************************************************************/
     39          
     40          #include "hal_board_cfg.h"
     41          #include "hal_types.h"
     42          #include "hal_mcu.h"
     43          #include "armcm3FlashUtil.h"
     44          #include "rom.h"
     45          #include "flash.h"
     46          
     47          /*********************************************************************
     48           * MACROS
     49           */
     50          
     51          /* Remainder when divided by 4 */
     52          #define byte_offset(addr) ((uint32)addr & 3)
     53          
     54          /* Greatest-multiple-of-4 <= addr */
     55          #define aligned_address(addr) ((uint32)addr & ~3)
     56          
     57          /*********************************************************************
     58           * @fn      flash_write_word
     59           *
     60           * @brief   Writes 4bytes of data to address ulAddress
     61           *
     62           * @param   ulAddress - Address to which data has to be written
     63           *          address has to be 4byte-aligned.
     64           *
     65           * @param   data - 4byte data
     66           *
     67           * @return  none
     68           */

   \                                 In section .text, align 2, keep-with-next
     69          static void flash_write_word( uint32 *ulAddress, uint32 data )
     70          {
   \                     flash_write_word: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
     71            ROM_ProgramFlash((uint32_t *)&data, (uint32_t)ulAddress, 4);
   \   00000002   0x2204             MOVS     R2,#+4
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2358             MOVS     R3,#+88
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0x4798             BLX      R3
     72          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
     73          
     74          /*********************************************************************
     75           * @fn      initFlash
     76           *
     77           * @brief   Sets the clock parameter required by the flash-controller
     78           *
     79           * @param   none
     80           *
     81           * @return  none
     82           */

   \                                 In section .text, align 2, keep-with-next
     83          void initFlash( void )
     84          {
     85            //FlashUsecSet( HAL_CPU_CLOCK_MHZ - 1 );
     86          }
   \                     initFlash: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     87          
     88          /*********************************************************************
     89           * @fn      flashErasePage
     90           *
     91           * @brief   Erases the page pointed by addr
     92           *
     93           * @param   addr - Address of the page to be erased.
     94           *          addr has to be page aligned.
     95           *
     96           * @return  none
     97           */

   \                                 In section .text, align 2, keep-with-next
     98          void flashErasePage( uint8 *addr )
     99          {
   \                     flashErasePage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    100            halIntState_t IntState;
    101          
    102            /* Set the clock frequency */
    103            initFlash();
   \   00000004   0x.... 0x....      BL       initFlash
    104          
    105            HAL_ENTER_CRITICAL_SECTION( IntState );
   \   00000008   0x.... 0x....      BL       IntMasterDisable
   \   0000000C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000010   0xF090 0x0501      EORS     R5,R0,#0x1
    106          
    107            /* Erase flash */
    108            FlashMainPageErase( (unsigned long)addr );
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       FlashMainPageErase
    109          
    110            HAL_EXIT_CRITICAL_SECTION( IntState );
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD001             BEQ.N    ??flashErasePage_0
   \   00000020   0x.... 0x....      BL       IntMasterEnable
    111          }
   \                     ??flashErasePage_0: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    112          
    113          /*********************************************************************
    114           * @fn      flashWrite
    115           *
    116           * @brief   Copies the data from buf(pointer) to
    117           * addr(pointer to flash memory). addr need not be aligned.
    118           * One can write the flash only in multiples of 4. The below logic is
    119           * required to implement data transfer of any number of bytes at any address
    120           *
    121           * @param  addr - To-address of the data
    122           * @param  len - Number of bytes to be transfered
    123           * @param  buf - From-address of the data
    124           *
    125           * @return len - None
    126           */

   \                                 In section .text, align 2, keep-with-next
    127          void flashWrite( uint8 *addr, uint16 len, uint8 *buf )
    128          {
   \                     flashWrite: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4683             MOV      R11,R0
   \   00000008   0x000C             MOVS     R4,R1
   \   0000000A   0x0015             MOVS     R5,R2
    129            if ( len > 0 )
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xF000 0x80A4      BEQ.W    ??flashWrite_0
    130            {
    131              /* 4-byte aligned pointer */
    132            uint32 *uint32ptr;
    133              /* 4-byte temporary variable */
    134            uint32 temp_u32;
    135            uint16 i = 0, j;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
    136          
    137            /* start_bytes - unaligned byte count at the beggining
    138             * middle_bytes - aligned byte count at the middle
    139             * end_bytes - unaligned byte count at the end
    140             */
    141            uint16 start_bytes = 0, middle_bytes = 0, end_bytes = 0;
   \   00000018   0x2600             MOVS     R6,#+0
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   00000020   0x2700             MOVS     R7,#+0
    142            halIntState_t IntState;
    143          
    144            /* Set the clock frequency */
    145            initFlash();
   \   00000022   0x.... 0x....      BL       initFlash
    146          
    147            /* Extract 4-byte aligned address */
    148            uint32ptr = (uint32 *)aligned_address(addr);
   \   00000026   0xEA5F 0x099B      LSRS     R9,R11,#+2
   \   0000002A   0xEA5F 0x0989      LSLS     R9,R9,#+2
    149          
    150            /* Calculate the start_bytes */
    151              /* If the addr is not 4-byte aligned */
    152              if( byte_offset(addr) )
   \   0000002E   0xF01B 0x0003      ANDS     R0,R11,#0x3
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00D             BEQ.N    ??flashWrite_1
    153            {
    154                /* If the start-address and the end-address are in the
    155               * same 4-byte-aligned-chunk.
    156               */
    157              if((((uint32)addr) >> 2) == ((((uint32)addr) + len) >> 2))
   \   00000036   0xEA5F 0x009B      LSRS     R0,R11,#+2
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0xEB14 0x010B      ADDS     R1,R4,R11
   \   00000040   0xEBB0 0x0F91      CMP      R0,R1, LSR #+2
   \   00000044   0xD101             BNE.N    ??flashWrite_2
    158              {
    159                start_bytes = len;
   \   00000046   0x0026             MOVS     R6,R4
   \   00000048   0xE003             B.N      ??flashWrite_1
    160              }
    161              else
    162              {
    163                start_bytes = 4 - (byte_offset(addr));
   \                     ??flashWrite_2: (+1)
   \   0000004A   0xF01B 0x0003      ANDS     R0,R11,#0x3
   \   0000004E   0xF1D0 0x0604      RSBS     R6,R0,#+4
    164              }
    165            }
    166          
    167            /* Calculate the middle_bytes and end_bytes */
    168              /* If there are any bytes left */
    169              if( (len - start_bytes) > 0 )
   \                     ??flashWrite_1: (+1)
   \   00000052   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000054   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000056   0x1BA0             SUBS     R0,R4,R6
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xDB08             BLT.N    ??flashWrite_3
    170            {
    171              /* Highest-multiple-of-4 less than (len - start_bytes) */
    172              middle_bytes = ((len - start_bytes) & (~3));
   \   0000005C   0x1BA0             SUBS     R0,R4,R6
   \   0000005E   0xF64F 0x71FC      MOVW     R1,#+65532
   \   00000062   0x4008             ANDS     R0,R1,R0
   \   00000064   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    173              /* Remainder when divided by 4 */
    174              end_bytes = (len - start_bytes) & 3;
   \   00000068   0x1BA0             SUBS     R0,R4,R6
   \   0000006A   0xF010 0x0703      ANDS     R7,R0,#0x3
    175            }
    176          
    177              HAL_ENTER_CRITICAL_SECTION( IntState );
   \                     ??flashWrite_3: (+1)
   \   0000006E   0x.... 0x....      BL       IntMasterDisable
   \   00000072   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000076   0xF090 0x0801      EORS     R8,R0,#0x1
    178          
    179            /* Write the start bytes to the flash */
    180              if( start_bytes > 0 )
   \   0000007A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD043             BEQ.N    ??flashWrite_4
    181            {
    182              /* Take the first 4-byte chunk into a temp_u32 */
    183              temp_u32 = *uint32ptr;
   \   00000080   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000084   0x9000             STR      R0,[SP, #+0]
   \   00000086   0xE00D             B.N      ??flashWrite_5
    184              /* Write the required bytes into temp_u32 */
    185              for(; i < start_bytes; i++)
    186              {
    187                *(((uint8 *)(&temp_u32)) + i + byte_offset(addr)) = buf[i];
   \                     ??flashWrite_6: (+1)
   \   00000088   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000008C   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000096   0xEB1A 0x0101      ADDS     R1,R10,R1
   \   0000009A   0xF01B 0x0203      ANDS     R2,R11,#0x3
   \   0000009E   0x5450             STRB     R0,[R2, R1]
    188              }
   \   000000A0   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??flashWrite_5: (+1)
   \   000000A4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000A8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000AA   0x45B2             CMP      R10,R6
   \   000000AC   0xD3EC             BCC.N    ??flashWrite_6
    189              /* Write the 4-byte chunk into the flah */
    190              flash_write_word(uint32ptr, temp_u32);
   \   000000AE   0x9900             LDR      R1,[SP, #+0]
   \   000000B0   0x4648             MOV      R0,R9
   \   000000B2   0x.... 0x....      BL       flash_write_word
    191              /* Increment the 4-byte-aligned-address by 4 */
    192              uint32ptr++;
   \   000000B6   0xF119 0x0904      ADDS     R9,R9,#+4
   \   000000BA   0xE025             B.N      ??flashWrite_4
    193            }
    194          
    195            /* Write the middle bytes to the flash */
    196              while( i < start_bytes + middle_bytes )
    197            {
    198              /* Extract 4 bytes into from the buf */
    199                *((uint8*)(&temp_u32)) = buf[i++];
   \                     ??flashWrite_7: (+1)
   \   000000BC   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000C0   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   000000C4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000C8   0xF11A 0x0A01      ADDS     R10,R10,#+1
    200                *((uint8*)(&temp_u32) + 1) = buf[i++];
   \   000000CC   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000D0   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   000000D4   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   000000D8   0xF11A 0x0A01      ADDS     R10,R10,#+1
    201                *((uint8*)(&temp_u32) + 2) = buf[i++];
   \   000000DC   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000E0   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   000000E4   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   000000E8   0xF11A 0x0A01      ADDS     R10,R10,#+1
    202                *((uint8*)(&temp_u32) + 3) = buf[i++];
   \   000000EC   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000F0   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   000000F4   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   000000F8   0xF11A 0x0A01      ADDS     R10,R10,#+1
    203          
    204              /* Write the 4-byte chunk into the flash */
    205                flash_write_word( uint32ptr, temp_u32 );
   \   000000FC   0x9900             LDR      R1,[SP, #+0]
   \   000000FE   0x4648             MOV      R0,R9
   \   00000100   0x.... 0x....      BL       flash_write_word
    206              /* Increment the 4-byte-aligned-address by 4 */
    207              uint32ptr++;
   \   00000104   0xF119 0x0904      ADDS     R9,R9,#+4
    208            }
   \                     ??flashWrite_4: (+1)
   \   00000108   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000010C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000010E   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000112   0x1980             ADDS     R0,R0,R6
   \   00000114   0x4582             CMP      R10,R0
   \   00000116   0xDBD1             BLT.N    ??flashWrite_7
    209          
    210            /* Write the end bytes to the flash */
    211              if( end_bytes > 0 )
   \   00000118   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000011A   0x2F00             CMP      R7,#+0
   \   0000011C   0xD017             BEQ.N    ??flashWrite_8
    212            {
    213              j = 0;
   \   0000011E   0x2000             MOVS     R0,#+0
    214              /* Take the first 4-byte chunk into a temp_u32 */
    215              temp_u32 = *uint32ptr;
   \   00000120   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   00000124   0x9100             STR      R1,[SP, #+0]
   \   00000126   0xE009             B.N      ??flashWrite_9
    216              for(; i < len; i++)
    217              {
    218                *((uint8 *)&temp_u32 + j) = buf[i];
   \                     ??flashWrite_10: (+1)
   \   00000128   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000012C   0xF81A 0x1005      LDRB     R1,[R10, R5]
   \   00000130   0xAA00             ADD      R2,SP,#+0
   \   00000132   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000134   0x5481             STRB     R1,[R0, R2]
    219                j++;
   \   00000136   0x1C40             ADDS     R0,R0,#+1
    220              }
   \   00000138   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??flashWrite_9: (+1)
   \   0000013C   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000140   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000142   0x45A2             CMP      R10,R4
   \   00000144   0xD3F0             BCC.N    ??flashWrite_10
    221              /* Write the 4-byte chunk into the flash */
    222                flash_write_word( uint32ptr, temp_u32 );
   \   00000146   0x9900             LDR      R1,[SP, #+0]
   \   00000148   0x4648             MOV      R0,R9
   \   0000014A   0x.... 0x....      BL       flash_write_word
    223            }
    224          
    225            HAL_EXIT_CRITICAL_SECTION( IntState );
   \                     ??flashWrite_8: (+1)
   \   0000014E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000152   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000156   0xD001             BEQ.N    ??flashWrite_11
   \   00000158   0x.... 0x....      BL       IntMasterEnable
    226            }
    227          }
   \                     ??flashWrite_11: (+1)
   \                     ??flashWrite_0: (+1)
   \   0000015C   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    228          
    229          /*********************************************************************
    230          *********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   flashErasePage
        16   -> FlashMainPageErase
        16   -> IntMasterDisable
        16   -> IntMasterEnable
        16   -> initFlash
      48   flashWrite
        48   -> IntMasterDisable
        48   -> IntMasterEnable
        48   -> flash_write_word
        48   -> initFlash
       8   flash_write_word
         8   -- Indirect call
       0   initFlash


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  flashErasePage
     352  flashWrite
      16  flash_write_word
       2  initFlash

 
 408 bytes in section .text
 
 408 bytes of CODE memory

Errors: none
Warnings: none
