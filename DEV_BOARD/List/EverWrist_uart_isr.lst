###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        26/Jul/2015  22:07:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\EverWrist_uart_isr.c
#    Command line =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\EverWrist_uart_isr.c
#        -D FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        LCD_SUPPORTED=TRUE -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
#        --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\List\EverWrist_uart_isr.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\DEV_BOARD\Obj\EverWrist_uart_isr.o
#
###############################################################################

C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\EverWrist_uart_isr.c
      1          /********************************************************************
      2           *     program:  EverWrist_uart_isr.c
      3           *      Project: Zigbee Watch
      4           *     Version:  0.0.1 -- phase 1
      5           *   Copyright:  2014, Barron Associates
      6           *     Written:  Wednesday, March 18, 2015
      7           *      Author:  Tim Trudeau - Timware
      8           *   Processor:  TI CC2538
      9           *        Tool:  IAR Embedded Workbench
     10           *
     11           *-------------------------------------------------------------------
     12           * /brief This contains the interface to the UARTs.
     13           * The CP2102 USB to UART converter is assigned to UART0
     14           * The serial channel to the MSP processor is assinged to UART1
     15           *******************************************************************/
     16          
     17          
     18          /* ------------------------------------------------------------------------------------------------
     19           *                                          Includes
     20           * ------------------------------------------------------------------------------------------------
     21           */
     22          #include "hal_board.h"
     23          #include "hal_types.h"
     24          #include "OSAL.h"
     25          #include "OSAL_Timers.h"
     26          #include "ioc.h"
     27          #include "hw_ioc.h"
     28          #include "hw_uart.h"
     29          #include "hal_uart.h"
     30          #include "EverWrist_bsp.h"
     31          #include "WatchApp.h"
     32          
     33          /* ------------------------------------------------------------------------------------------------
     34           *                                           Constants
     35           * ------------------------------------------------------------------------------------------------
     36           */
     37          #define CP2102_UART_BASE          UART0_BASE
     38          #define MSP_UART_BASE             UART1_BASE
     39          #define CP2102_UART_SYS_CTRL      SYS_CTRL_PERIPH_UART0
     40          #define MSP_UART_SYS_CTRL         SYS_CTRL_PERIPH_UART1
     41          #define UART0                     0
     42          #define UART1                     1
     43          
     44          /* ------------------------------------------------------------------------------------------------
     45           *                                           Local Variables
     46           * ------------------------------------------------------------------------------------------------
     47           */
     48          

   \                                 In section .rodata, align 4
     49          const uint32 UBRRTable[] = {
   \                     UBRRTable:
   \   00000000   0x00002580         DC32 9600, 19200, 38400, 57600, 115200
   \              0x00004B00   
   \              0x00009600   
   \              0x0000E100   
   \              0x0001C200   
     50            9600,
     51            19200,
     52            38400,
     53            57600,
     54            115200
     55          };
     56          

   \                                 In section .bss, align 4
     57          static halUARTCfg_t CP2102_Record;
   \                     CP2102_Record:
   \   00000000                      DS8 44

   \                                 In section .bss, align 4
     58          static halUARTCfg_t MSP_Record;
   \                     MSP_Record:
   \   00000000                      DS8 44
     59          
     60          /* ------------------------------------------------------------------------------------------------
     61           *                                           Local Functions
     62           * ------------------------------------------------------------------------------------------------
     63           */
     64          static void recRst(halUARTCfg_t* config);
     65          static void procRx(uint8 port);
     66          static void procTx(uint8 port);
     67          
     68          void    HalUARTInitIsr(void);
     69          uint8   HalUARTOpenIsr(uint8 port, halUARTCfg_t* config);
     70          void    HalUARTCloseIsr(uint8 port);
     71          uint16  HalUARTReadIsr ( uint8 port, uint8* pBuffer, uint16 length );
     72          uint16  HalUARTWriteIsr(uint8 port, uint8* pBuffer, uint16 length);
     73          uint16  Hal_UART_RxBufLenIsr(uint8 port);
     74          
     75          void    interrupt_uart0(void);
     76          void    interrupt_uart1(void);
     77          void    CP2102_Message_Handler  (uint8 port, uint8 event);
     78          void    MSP_Message_Handler(uint8 port, uint8 event);
     79          
     80          /* ------------------------------------------------------------------------------------------------
     81           *                                           Global Functions
     82           * ------------------------------------------------------------------------------------------------
     83           */
     84          
     85           
     86          /* ------------------------------------------------------------------------------------------------
     87           *                                           Global Varables
     88           * ------------------------------------------------------------------------------------------------
     89           */
     90          
     91          /*************************************************************************************************
     92           * @fn      HalUARTInitIsr()
     93           *
     94           * @brief   Initialize both UARTs using the same port configuration parameters
     95           * Note:    HalUARTOpen redirects to HalUARTOpenIsr. HalUARTOpen is called here because the stack may also call it.     
     96           *
     97           * @param   none
     98           *
     99           * @return  none
    100           *
    101           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    102          void HalUARTInitIsr(void)
    103          {
   \                     HalUARTInitIsr: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    104            halUARTCfg_t uartConfig;
    105          
    106            /* UART Configuration */
    107            uartConfig.configured           = TRUE;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    108            uartConfig.baudRate             = UART_SEL_BAUD;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    109            uartConfig.flowControl          = UART_OVERFLOW;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
    110            uartConfig.flowControlThreshold = UART_THRESHOLD;
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    111            uartConfig.rx.maxBufSize        = UART_RX_BUFF_MAX;
   \   0000001C   0x2040             MOVS     R0,#+64
   \   0000001E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    112            uartConfig.tx.maxBufSize        = UART_TX_BUFF_MAX;
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    113            uartConfig.idleTimeout          = UART_IDLE_TIMEOUT;
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    114            uartConfig.intEnable            = TRUE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0020      STRB     R0,[SP, #+32]
    115          
    116            /* Start both UARTs */
    117            uartConfig.callBackFunc         = CP2102_Message_Handler;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000038   0x900A             STR      R0,[SP, #+40]
    118            HalUARTOpen (UART0, &uartConfig);
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       HalUARTOpen
    119            uartConfig.callBackFunc         = MSP_Message_Handler;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000046   0x900A             STR      R0,[SP, #+40]
    120            HalUARTOpen (UART1, &uartConfig);
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       HalUARTOpen
    121          
    122          }
   \   00000050   0xB00B             ADD      SP,SP,#+44
   \   00000052   0xBD00             POP      {PC}             ;; return
    123          
    124          /*************************************************************************************************
    125           * @fn      HalUARTOpenIsr()
    126           *
    127           * @brief   Open a port based on the configuration
    128           *
    129           * @param   port   - UART port
    130           *          config - contains configuration information
    131           *          cBack  - Call back function where events will be reported back
    132           *
    133           * @return  Status of the function call
    134           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          uint8 HalUARTOpenIsr(uint8 port, halUARTCfg_t* config)
    136          {
   \                     HalUARTOpenIsr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000C             MOVS     R4,R1
    137            uint32_t      interrupt_assignment;
    138            uint32_t      HAL_UART_port;
    139            halUARTCfg_t* uartRecord;
    140          
    141            if (port == UART1) {
   \   00000008   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000000C   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000010   0xD12B             BNE.N    ??HalUARTOpenIsr_0
    142            /* PA7 as CP2102_UART_RTS  
    143             * PA0 as CP2102_UART_TX and PA1 as CP2102_UART_RX
    144             * CTS, RTS, TX and RX are with respest to the CP2102 thus opposite on the CC2538
    145             */ 
    146                uartRecord = &CP2102_Record;
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable10_2
    147                interrupt_assignment = INT_UART1;
   \   00000016   0x2716             MOVS     R7,#+22
    148                IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_1, IOC_MUX_OUT_SEL_UART1_TXD);
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x2102             MOVS     R1,#+2
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000020   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    149                IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_7, IOC_MUX_OUT_SEL_UART1_RTS);
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   0000002C   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    150                IOCPinConfigPeriphInput(GPIO_A_BASE, GPIO_PIN_0, IOC_UARTRXD_UART1);
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable10_4  ;; 0x400d4108
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   0000003A   0x.... 0x....      BL       IOCPinConfigPeriphInput
    151                GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_1);    
   \   0000003E   0x2102             MOVS     R1,#+2
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000044   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    152                GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_7);    
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   0000004E   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    153                GPIOPinTypeUARTInput(GPIO_A_BASE, GPIO_PIN_0);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000058   0x.... 0x....      BL       GPIOPinTypeUARTInput
    154                HAL_UART_port = CP2102_UART_BASE;
   \   0000005C   0x.... 0x....      LDR.W    R5,??DataTable10_5  ;; 0x4000c000
    155                SysCtrlPeripheralEnable(SYS_CTRL_PERIPH_UART0);
   \   00000060   0xF44F 0x7000      MOV      R0,#+512
   \   00000064   0x.... 0x....      BL       SysCtrlPeripheralEnable
   \   00000068   0xE01C             B.N      ??HalUARTOpenIsr_1
    156            }else{
    157             /* PA3 as MSP_UART_TX and PA4 as MSP_UART_RX
    158             * TX and RX are with respest to the MSP thus opposite on the CC2538
    159             */ 
    160                uartRecord = &MSP_Record;
   \                     ??HalUARTOpenIsr_0: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R6,??DataTable10_6
    161                interrupt_assignment = INT_UART0;
   \   0000006E   0x2715             MOVS     R7,#+21
    162                IOCPinConfigPeriphOutput(GPIO_A_BASE, GPIO_PIN_4, IOC_MUX_OUT_SEL_UART0_TXD);
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x2110             MOVS     R1,#+16
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000078   0x.... 0x....      BL       IOCPinConfigPeriphOutput
    163                IOCPinConfigPeriphInput(GPIO_A_BASE, GPIO_PIN_3, IOC_UARTRXD_UART0);
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable10_7  ;; 0x400d4100
   \   00000080   0x2108             MOVS     R1,#+8
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400d9000
   \   00000086   0x.... 0x....      BL       IOCPinConfigPeriphInput
    164                GPIOPinTypeUARTOutput(GPIO_A_BASE, GPIO_PIN_4);  
   \   0000008A   0x2110             MOVS     R1,#+16
   \   0000008C   0x....             LDR.N    R0,??DataTable10_3  ;; 0x400d9000
   \   0000008E   0x.... 0x....      BL       GPIOPinTypeUARTOutput
    165                GPIOPinTypeUARTInput(GPIO_A_BASE, GPIO_PIN_3);
   \   00000092   0x2108             MOVS     R1,#+8
   \   00000094   0x....             LDR.N    R0,??DataTable10_3  ;; 0x400d9000
   \   00000096   0x.... 0x....      BL       GPIOPinTypeUARTInput
    166                HAL_UART_port = MSP_UART_BASE;
   \   0000009A   0x....             LDR.N    R5,??DataTable10_8  ;; 0x4000d000
    167                SysCtrlPeripheralEnable(SYS_CTRL_PERIPH_UART1);
   \   0000009C   0xF240 0x2001      MOVW     R0,#+513
   \   000000A0   0x.... 0x....      BL       SysCtrlPeripheralEnable
    168            }
    169            recRst(uartRecord);
   \                     ??HalUARTOpenIsr_1: (+1)
   \   000000A4   0x0030             MOVS     R0,R6
   \   000000A6   0x.... 0x....      BL       recRst
    170            
    171            if (uartRecord->configured) { // if already configured don't destroy buffers
   \   000000AA   0x7830             LDRB     R0,[R6, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD003             BEQ.N    ??HalUARTOpenIsr_2
    172              HalUARTClose(port);
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       HalUARTClose
    173            }
    174          
    175            if (config->baudRate > HAL_UART_BR_115200) {
   \                     ??HalUARTOpenIsr_2: (+1)
   \   000000B8   0x7860             LDRB     R0,[R4, #+1]
   \   000000BA   0x2805             CMP      R0,#+5
   \   000000BC   0xDB01             BLT.N    ??HalUARTOpenIsr_3
    176              return HAL_UART_BAUDRATE_ERROR;
   \   000000BE   0x2004             MOVS     R0,#+4
   \   000000C0   0xE05A             B.N      ??HalUARTOpenIsr_4
    177            }
    178          
    179            if (((uartRecord->rx.pBuffer = osal_mem_alloc(config->rx.maxBufSize)) == NULL) ||
    180                ((uartRecord->tx.pBuffer = osal_mem_alloc(config->tx.maxBufSize)) == NULL)) {
   \                     ??HalUARTOpenIsr_3: (+1)
   \   000000C2   0x89A0             LDRH     R0,[R4, #+12]
   \   000000C4   0x.... 0x....      BL       osal_mem_alloc
   \   000000C8   0x6130             STR      R0,[R6, #+16]
   \   000000CA   0x6930             LDR      R0,[R6, #+16]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD006             BEQ.N    ??HalUARTOpenIsr_5
   \   000000D0   0x8B20             LDRH     R0,[R4, #+24]
   \   000000D2   0x.... 0x....      BL       osal_mem_alloc
   \   000000D6   0x61F0             STR      R0,[R6, #+28]
   \   000000D8   0x69F0             LDR      R0,[R6, #+28]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD109             BNE.N    ??HalUARTOpenIsr_6
    181              if (uartRecord->rx.pBuffer != NULL) {
   \                     ??HalUARTOpenIsr_5: (+1)
   \   000000DE   0x6930             LDR      R0,[R6, #+16]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD004             BEQ.N    ??HalUARTOpenIsr_7
    182                osal_mem_free(uartRecord->rx.pBuffer);
   \   000000E4   0x6930             LDR      R0,[R6, #+16]
   \   000000E6   0x.... 0x....      BL       osal_mem_free
    183                uartRecord->rx.pBuffer = NULL;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x6130             STR      R0,[R6, #+16]
    184              }
    185          
    186              return HAL_UART_MEM_FAIL;
   \                     ??HalUARTOpenIsr_7: (+1)
   \   000000EE   0x2003             MOVS     R0,#+3
   \   000000F0   0xE042             B.N      ??HalUARTOpenIsr_4
    187            }
    188             
    189            IntEnable(interrupt_assignment);
   \                     ??HalUARTOpenIsr_6: (+1)
   \   000000F2   0x0038             MOVS     R0,R7
   \   000000F4   0x.... 0x....      BL       IntEnable
    190          
    191            uartRecord->configured = TRUE;
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0x7030             STRB     R0,[R6, #+0]
    192            uartRecord->baudRate = config->baudRate;
   \   000000FC   0x7860             LDRB     R0,[R4, #+1]
   \   000000FE   0x7070             STRB     R0,[R6, #+1]
    193            uartRecord->flowControl = config->flowControl;
   \   00000100   0x78A0             LDRB     R0,[R4, #+2]
   \   00000102   0x70B0             STRB     R0,[R6, #+2]
    194            uartRecord->flowControlThreshold = (config->flowControlThreshold > config->rx.maxBufSize) ? 0 :
    195                                               config->flowControlThreshold;
   \   00000104   0x89A0             LDRH     R0,[R4, #+12]
   \   00000106   0x88A1             LDRH     R1,[R4, #+4]
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xD201             BCS.N    ??HalUARTOpenIsr_8
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xE000             B.N      ??HalUARTOpenIsr_9
   \                     ??HalUARTOpenIsr_8: (+1)
   \   00000110   0x88A0             LDRH     R0,[R4, #+4]
   \                     ??HalUARTOpenIsr_9: (+1)
   \   00000112   0x80B0             STRH     R0,[R6, #+4]
    196            uartRecord->idleTimeout = config->idleTimeout;
   \   00000114   0x79A0             LDRB     R0,[R4, #+6]
   \   00000116   0x71B0             STRB     R0,[R6, #+6]
    197            uartRecord->rx.maxBufSize = config->rx.maxBufSize;
   \   00000118   0x89A0             LDRH     R0,[R4, #+12]
   \   0000011A   0x81B0             STRH     R0,[R6, #+12]
    198            uartRecord->tx.maxBufSize = config->tx.maxBufSize;
   \   0000011C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000011E   0x8330             STRH     R0,[R6, #+24]
    199            uartRecord->intEnable = config->intEnable;
   \   00000120   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000124   0xF886 0x0020      STRB     R0,[R6, #+32]
    200            uartRecord->callBackFunc = config->callBackFunc;
   \   00000128   0x6AA0             LDR      R0,[R4, #+40]
   \   0000012A   0x62B0             STR      R0,[R6, #+40]
    201          
    202            UARTConfigSetExpClk(HAL_UART_port, SysCtrlClockGet(), UBRRTable[uartRecord->baudRate],
    203                                   (UART_CONFIG_WLEN_8 | UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE));
   \   0000012C   0x.... 0x....      BL       SysCtrlClockGet
   \   00000130   0x2360             MOVS     R3,#+96
   \   00000132   0x....             LDR.N    R1,??DataTable10_9
   \   00000134   0x7872             LDRB     R2,[R6, #+1]
   \   00000136   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   \   0000013A   0x0001             MOVS     R1,R0
   \   0000013C   0x0028             MOVS     R0,R5
   \   0000013E   0x.... 0x....      BL       UARTConfigSetExpClk
    204          
    205            /* FIFO level set to 1/8th for both RX and TX which is 2 bytes */
    206            UARTFIFOLevelSet(HAL_UART_port, UART_FIFO_TX1_8, UART_FIFO_RX1_8);
   \   00000142   0x2200             MOVS     R2,#+0
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x0028             MOVS     R0,R5
   \   00000148   0x.... 0x....      BL       UARTFIFOLevelSet
    207            UARTFIFOEnable(HAL_UART_port);
   \   0000014C   0x0028             MOVS     R0,R5
   \   0000014E   0x.... 0x....      BL       UARTFIFOEnable
    208          
    209            /* Clear and enable UART TX, RX and Recieve Timeout interrupt. Not using CTS */
    210            UARTIntClear(HAL_UART_port,  (UART_INT_RX | UART_INT_TX | UART_INT_CTS | UART_INT_RT ));
   \   00000152   0x2172             MOVS     R1,#+114
   \   00000154   0x0028             MOVS     R0,R5
   \   00000156   0x.... 0x....      BL       UARTIntClear
    211            UARTIntEnable(HAL_UART_port, (UART_INT_RX | UART_INT_TX | UART_INT_CTS | UART_INT_RT ));
   \   0000015A   0x2172             MOVS     R1,#+114
   \   0000015C   0x0028             MOVS     R0,R5
   \   0000015E   0x.... 0x....      BL       UARTIntEnable
    212            
    213            if(config->flowControl) {
   \   00000162   0x78A0             LDRB     R0,[R4, #+2]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD003             BEQ.N    ??HalUARTOpenIsr_10
    214              /* Enable hardware flow control by enabling RTS */
    215              HWREG(HAL_UART_port + UART_O_CTL) |= (UART_CTL_RTSEN );
   \   00000168   0x6B28             LDR      R0,[R5, #+48]
   \   0000016A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000016E   0x6328             STR      R0,[R5, #+48]
    216            }
    217            UARTEnable(HAL_UART_port);
   \                     ??HalUARTOpenIsr_10: (+1)
   \   00000170   0x0028             MOVS     R0,R5
   \   00000172   0x.... 0x....      BL       UARTEnable
    218          
    219            return HAL_UART_SUCCESS;
   \   00000176   0x2000             MOVS     R0,#+0
   \                     ??HalUARTOpenIsr_4: (+1)
   \   00000178   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    220          }
    221          
    222          
    223          /*************************************************************************************************
    224           * @fn      HalUARTCloseIsr()
    225           *
    226           * @brief   Close the UART
    227           *
    228           * @param   port - UART port.
    229           *
    230           * @return  none
    231           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          void HalUARTCloseIsr(uint8 port)
    233          {
   \                     HalUARTCloseIsr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    234            halUARTCfg_t* uartRecord;
    235          
    236            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??HalUARTCloseIsr_0
   \   00000008   0x....             LDR.N    R4,??DataTable10_2
   \   0000000A   0xE000             B.N      ??HalUARTCloseIsr_1
   \                     ??HalUARTCloseIsr_0: (+1)
   \   0000000C   0x....             LDR.N    R4,??DataTable10_6
    237          
    238            UARTDisable(port);
   \                     ??HalUARTCloseIsr_1: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       UARTDisable
    239          
    240            if (uartRecord->configured) {
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD008             BEQ.N    ??HalUARTCloseIsr_2
    241              (void)osal_mem_free(uartRecord->rx.pBuffer);
   \   0000001A   0x6920             LDR      R0,[R4, #+16]
   \   0000001C   0x.... 0x....      BL       osal_mem_free
    242              (void)osal_mem_free(uartRecord->tx.pBuffer);
   \   00000020   0x69E0             LDR      R0,[R4, #+28]
   \   00000022   0x.... 0x....      BL       osal_mem_free
    243              recRst(uartRecord);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       recRst
    244            }
    245          }
   \                     ??HalUARTCloseIsr_2: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    246          
    247          /*************************************************************************************************
    248           * @fn      HalUARTReadIsr()
    249           *
    250           * @brief   Read a buffer from the UART
    251           *
    252           * @param   port - UART port.
    253           *          ppBuffer - pointer to a pointer that points to the data that will be read
    254           *          length - length of the requested buffer
    255           *
    256           * @return  length of buffer that was read
    257           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    258          uint16 HalUARTReadIsr ( uint8 port, uint8* pBuffer, uint16 length )
    259          {
   \                     HalUARTReadIsr: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    260            uint16        cnt, idx;
    261            halUARTCfg_t* uartRecord;
    262          
    263           
    264            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??HalUARTReadIsr_0
   \   00000008   0x....             LDR.N    R4,??DataTable10_2
   \   0000000A   0xE000             B.N      ??HalUARTReadIsr_1
   \                     ??HalUARTReadIsr_0: (+1)
   \   0000000C   0x....             LDR.N    R4,??DataTable10_6
    265          
    266            /* If port is not configured, no point to read it. */
    267            if (!uartRecord->configured) {
   \                     ??HalUARTReadIsr_1: (+1)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??HalUARTReadIsr_2
    268              return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE015             B.N      ??HalUARTReadIsr_3
    269            }
    270          
    271            idx = uartRecord->rx.bufferHead;
   \                     ??HalUARTReadIsr_2: (+1)
   \   00000018   0x8923             LDRH     R3,[R4, #+8]
    272            for (cnt = 0; cnt < length; cnt++) {
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE00B             B.N      ??HalUARTReadIsr_4
    273              pBuffer[cnt] = uartRecord->rx.pBuffer[idx++];
   \                     ??HalUARTReadIsr_5: (+1)
   \   0000001E   0x6925             LDR      R5,[R4, #+16]
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x5D5D             LDRB     R5,[R3, R5]
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x5445             STRB     R5,[R0, R1]
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
    274          
    275              if (idx >= uartRecord->rx.maxBufSize) {
   \   0000002A   0x89A5             LDRH     R5,[R4, #+12]
   \   0000002C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002E   0x42AB             CMP      R3,R5
   \   00000030   0xD300             BCC.N    ??HalUARTReadIsr_6
    276                idx = 0;
   \   00000032   0x2300             MOVS     R3,#+0
    277              }
    278            }
   \                     ??HalUARTReadIsr_6: (+1)
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??HalUARTReadIsr_4: (+1)
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003A   0x4290             CMP      R0,R2
   \   0000003C   0xD3EF             BCC.N    ??HalUARTReadIsr_5
    279            uartRecord->rx.bufferHead = idx;
   \   0000003E   0x8123             STRH     R3,[R4, #+8]
    280          
    281            /* Return number of bytes read. */
    282            return length;  
   \   00000040   0x0010             MOVS     R0,R2
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??HalUARTReadIsr_3: (+1)
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return
    283          }
    284          
    285          /*************************************************************************************************
    286           * @fn      HalUARTWriteIsr()
    287           *
    288           * @brief   Write a buffer to the UART
    289           *
    290           * @param   port    - UART port.
    291           *          pBuffer - pointer to the buffer that will be written
    292           *          length  - length of
    293           *
    294           * @return  length of the message that was sent
    295           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          uint16 HalUARTWriteIsr(uint8 port, uint8 *pBuffer, uint16 length)
    297          {
   \                     HalUARTWriteIsr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
    298            halUARTCfg_t* uartRecord;
    299          
    300            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD101             BNE.N    ??HalUARTWriteIsr_0
   \   0000000E   0x....             LDR.N    R6,??DataTable10_2
   \   00000010   0xE000             B.N      ??HalUARTWriteIsr_1
   \                     ??HalUARTWriteIsr_0: (+1)
   \   00000012   0x....             LDR.N    R6,??DataTable10_6
    301          
    302            if (!uartRecord->configured) {
   \                     ??HalUARTWriteIsr_1: (+1)
   \   00000014   0x7830             LDRB     R0,[R6, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??HalUARTWriteIsr_2
    303              return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE03D             B.N      ??HalUARTWriteIsr_3
    304            }
    305          
    306            uint16 idx = uartRecord->tx.bufferHead;
   \                     ??HalUARTWriteIsr_2: (+1)
   \   0000001E   0x8AB7             LDRH     R7,[R6, #+20]
    307            uint16 cnt = uartRecord->tx.bufferTail;
   \   00000020   0x8AF0             LDRH     R0,[R6, #+22]
    308          
    309            if (cnt == idx) {
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000026   0x42B8             CMP      R0,R7
   \   00000028   0xD101             BNE.N    ??HalUARTWriteIsr_4
    310              cnt = uartRecord->tx.maxBufSize;
   \   0000002A   0x8B30             LDRH     R0,[R6, #+24]
   \   0000002C   0xE008             B.N      ??HalUARTWriteIsr_5
    311            }
    312            else if (cnt > idx) {
   \                     ??HalUARTWriteIsr_4: (+1)
   \   0000002E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x4287             CMP      R7,R0
   \   00000034   0xD203             BCS.N    ??HalUARTWriteIsr_6
    313              cnt = uartRecord->tx.maxBufSize - cnt + idx;
   \   00000036   0x8B32             LDRH     R2,[R6, #+24]
   \   00000038   0x1A10             SUBS     R0,R2,R0
   \   0000003A   0x1838             ADDS     R0,R7,R0
   \   0000003C   0xE000             B.N      ??HalUARTWriteIsr_5
    314            }else{ /* (cnt < idx) */
    315              cnt = idx - cnt;
   \                     ??HalUARTWriteIsr_6: (+1)
   \   0000003E   0x1A38             SUBS     R0,R7,R0
    316            }
    317          
    318            /* Accept "all-or-none" on write request. */
    319            if (cnt < length) {
   \                     ??HalUARTWriteIsr_5: (+1)
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x42A8             CMP      R0,R5
   \   00000046   0xD201             BCS.N    ??HalUARTWriteIsr_7
    320              return 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE026             B.N      ??HalUARTWriteIsr_3
    321            }
    322          
    323             idx = uartRecord->tx.bufferTail;
   \                     ??HalUARTWriteIsr_7: (+1)
   \   0000004C   0x8AF7             LDRH     R7,[R6, #+22]
    324          
    325            for (cnt = 0; cnt < length; cnt++) {
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00B             B.N      ??HalUARTWriteIsr_8
    326              uartRecord->tx.pBuffer[idx++] = pBuffer[cnt];
   \                     ??HalUARTWriteIsr_9: (+1)
   \   00000052   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000054   0x5C42             LDRB     R2,[R0, R1]
   \   00000056   0x69F3             LDR      R3,[R6, #+28]
   \   00000058   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005A   0x54FA             STRB     R2,[R7, R3]
   \   0000005C   0x1C7F             ADDS     R7,R7,#+1
    327          
    328              if (idx >= uartRecord->tx.maxBufSize) {
   \   0000005E   0x8B32             LDRH     R2,[R6, #+24]
   \   00000060   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000062   0x4297             CMP      R7,R2
   \   00000064   0xD300             BCC.N    ??HalUARTWriteIsr_10
    329                idx = 0;
   \   00000066   0x2700             MOVS     R7,#+0
    330              }
    331            }
   \                     ??HalUARTWriteIsr_10: (+1)
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \                     ??HalUARTWriteIsr_8: (+1)
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006E   0x42A8             CMP      R0,R5
   \   00000070   0xD3EF             BCC.N    ??HalUARTWriteIsr_9
    332          
    333            halIntState_t intState;
    334            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000072   0x.... 0x....      BL       IntMasterDisable
   \   00000076   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007A   0xF090 0x0801      EORS     R8,R0,#0x1
    335            uartRecord->tx.bufferTail = idx;
   \   0000007E   0x82F7             STRH     R7,[R6, #+22]
    336            procTx(port);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x.... 0x....      BL       procTx
    337            HAL_EXIT_CRITICAL_SECTION(intState);
   \   00000088   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000090   0xD001             BEQ.N    ??HalUARTWriteIsr_11
   \   00000092   0x.... 0x....      BL       IntMasterEnable
    338          
    339            /* Return the number of bytes actually put into the buffer. */
    340            return length;  
   \                     ??HalUARTWriteIsr_11: (+1)
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??HalUARTWriteIsr_3: (+1)
   \   0000009A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    341          }
    342          
    343          /*************************************************************************************************
    344           * @fn      Hal_UART_RxBufLenIsr()
    345           *
    346           * @brief   Calculate Rx message length of a port
    347           *
    348           * @param   port - UART port.
    349           *
    350           * @return  length of current Rx Buffer
    351           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    352          uint16 Hal_UART_RxBufLenIsr(uint8 port)
    353          {
    354            int16 length;
    355            halUARTCfg_t* uartRecord;
    356          
    357            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \                     Hal_UART_RxBufLenIsr: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD101             BNE.N    ??Hal_UART_RxBufLenIsr_0
   \   00000006   0x....             LDR.N    R1,??DataTable10_2
   \   00000008   0xE000             B.N      ??Hal_UART_RxBufLenIsr_1
   \                     ??Hal_UART_RxBufLenIsr_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable10_6
    358            length = uartRecord->rx.bufferTail;
   \                     ??Hal_UART_RxBufLenIsr_1: (+1)
   \   0000000C   0xF9B1 0x000A      LDRSH    R0,[R1, #+10]
    359            length -= uartRecord->rx.bufferHead;
   \   00000010   0xF9B1 0x2008      LDRSH    R2,[R1, #+8]
   \   00000014   0x1A80             SUBS     R0,R0,R2
    360            if  (length < 0){
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD502             BPL.N    ??Hal_UART_RxBufLenIsr_2
    361                length += uartRecord->rx.maxBufSize;
   \   0000001C   0xF9B1 0x100C      LDRSH    R1,[R1, #+12]
   \   00000020   0x1808             ADDS     R0,R1,R0
    362            }
    363            return (uint16)length;
   \                     ??Hal_UART_RxBufLenIsr_2: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x4770             BX       LR               ;; return
    364          }
    365          
    366          /*************************************************************************************************
    367           * @fn      Hal_UART_TxBufLen()
    368           *
    369           * @brief   Calculate Tx Buffer length of a port
    370           *
    371           * @param   port - UART port.
    372           *
    373           * @return  length of current Tx buffer
    374           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    375          uint16 Hal_UART_TxBufLen( uint8 port )
    376          {
    377            int16 length;
    378            halUARTCfg_t* uartRecord;
    379          
    380            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \                     Hal_UART_TxBufLen: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD101             BNE.N    ??Hal_UART_TxBufLen_0
   \   00000006   0x....             LDR.N    R1,??DataTable10_2
   \   00000008   0xE000             B.N      ??Hal_UART_TxBufLen_1
   \                     ??Hal_UART_TxBufLen_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable10_6
    381            length = uartRecord->tx.bufferTail;
   \                     ??Hal_UART_TxBufLen_1: (+1)
   \   0000000C   0xF9B1 0x0016      LDRSH    R0,[R1, #+22]
    382            length -= uartRecord->tx.bufferHead;
   \   00000010   0xF9B1 0x2014      LDRSH    R2,[R1, #+20]
   \   00000014   0x1A80             SUBS     R0,R0,R2
    383            if  (length < 0) {
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD502             BPL.N    ??Hal_UART_TxBufLen_2
    384              length += uartRecord->tx.maxBufSize;
   \   0000001C   0xF9B1 0x1018      LDRSH    R1,[R1, #+24]
   \   00000020   0x1808             ADDS     R0,R1,R0
    385            }
    386            return (uint16)length;
   \                     ??Hal_UART_TxBufLen_2: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x4770             BX       LR               ;; return
    387          }
    388          
    389          /*************************************************************************************************
    390           * @fn      recRst()
    391           *
    392           * @brief   Reset the UART record.
    393           *
    394           * @param   uartRecord to reset
    395           *
    396           * @return  none
    397           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          static void recRst( halUARTCfg_t* uartRecord )
    399          {
    400            uartRecord->configured        = FALSE;
   \                     recRst: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    401            uartRecord->rx.bufferHead     = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8101             STRH     R1,[R0, #+8]
    402            uartRecord->rx.bufferTail     = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8141             STRH     R1,[R0, #+10]
    403            uartRecord->rx.pBuffer        = (uint8 *)NULL;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    404            uartRecord->tx.bufferHead     = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8281             STRH     R1,[R0, #+20]
    405            uartRecord->tx.bufferTail     = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x82C1             STRH     R1,[R0, #+22]
    406            uartRecord->tx.pBuffer        = (uint8 *)NULL;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
    407            uartRecord->rxChRvdTime       = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6241             STR      R1,[R0, #+36]
    408            uartRecord->intEnable         = FALSE;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF880 0x1020      STRB     R1,[R0, #+32]
    409          }
   \   00000026   0x4770             BX       LR               ;; return
    410          
    411          /*************************************************************************************************
    412           * @fn      procRx
    413           *
    414           * @brief   Process Tx bytes.
    415           *
    416           * @param   void
    417           *
    418           * @return  void
    419           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    420          static void procRx( uint8 port )
    421          {
   \                     procRx: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    422            halUARTCfg_t* uartRecord;
    423            uint16 tail;
    424            
    425            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD101             BNE.N    ??procRx_0
   \   0000000A   0x....             LDR.N    R5,??DataTable10_2
   \   0000000C   0xE000             B.N      ??procRx_1
   \                     ??procRx_0: (+1)
   \   0000000E   0x....             LDR.N    R5,??DataTable10_6
    426          
    427            tail = uartRecord->rx.bufferTail;
   \                     ??procRx_1: (+1)
   \   00000010   0x896E             LDRH     R6,[R5, #+10]
   \   00000012   0xE00C             B.N      ??procRx_2
    428          
    429            while (UARTCharsAvail(port)) {
    430              uartRecord->rx.pBuffer[tail++] = UARTCharGetNonBlocking(port);
   \                     ??procRx_3: (+1)
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       UARTCharGetNonBlocking
   \   0000001C   0x6929             LDR      R1,[R5, #+16]
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x5470             STRB     R0,[R6, R1]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
    431          
    432              if (tail >= uartRecord->rx.maxBufSize) {
   \   00000024   0x89A8             LDRH     R0,[R5, #+12]
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD300             BCC.N    ??procRx_2
    433                tail = 0;
   \   0000002C   0x2600             MOVS     R6,#+0
    434              }
    435            }
   \                     ??procRx_2: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       UARTCharsAvail
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1EC             BNE.N    ??procRx_3
    436          
    437            if (uartRecord->rx.bufferTail != tail) {
   \   0000003A   0x8968             LDRH     R0,[R5, #+10]
   \   0000003C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003E   0x42B0             CMP      R0,R6
   \   00000040   0xD003             BEQ.N    ??procRx_4
    438              uartRecord->rx.bufferTail = tail;
   \   00000042   0x816E             STRH     R6,[R5, #+10]
    439              uartRecord->rxChRvdTime = osal_GetSystemClock();
   \   00000044   0x.... 0x....      BL       osal_GetSystemClock
   \   00000048   0x6268             STR      R0,[R5, #+36]
    440            }
    441          }
   \                     ??procRx_4: (+1)
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    442          
    443          /*************************************************************************************************
    444           * @fn      procTx
    445           *
    446           * @brief   Process Tx bytes.
    447           *
    448           * @param   void
    449           *
    450           * @return  void
    451           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    452          static void procTx( uint8 port )
    453          {
   \                     procTx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    454            uint16 head;
    455            uint16 tail;
    456            halUARTCfg_t* uartRecord;
    457            
    458            uartRecord = (port == UART1) ? &CP2102_Record : &MSP_Record;
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD101             BNE.N    ??procTx_0
   \   0000000A   0x....             LDR.N    R7,??DataTable10_2
   \   0000000C   0xE000             B.N      ??procTx_1
   \                     ??procTx_0: (+1)
   \   0000000E   0x....             LDR.N    R7,??DataTable10_6
    459            head = uartRecord->tx.bufferHead;
   \                     ??procTx_1: (+1)
   \   00000010   0x8ABD             LDRH     R5,[R7, #+20]
    460            tail = uartRecord->tx.bufferTail;
   \   00000012   0x8AFE             LDRH     R6,[R7, #+22]
   \   00000014   0xE005             B.N      ??procTx_2
    461          
    462            while ((head != tail) && (UARTCharPutNonBlocking(port, uartRecord->tx.pBuffer[head]))) {
    463              if (++head >= uartRecord->tx.maxBufSize) {
   \                     ??procTx_3: (+1)
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0x8B38             LDRH     R0,[R7, #+24]
   \   0000001A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xD300             BCC.N    ??procTx_2
    464                head = 0;
   \   00000020   0x2500             MOVS     R5,#+0
    465              }
    466            }
   \                     ??procTx_2: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x42B5             CMP      R5,R6
   \   00000028   0xD008             BEQ.N    ??procTx_4
   \   0000002A   0x69F8             LDR      R0,[R7, #+28]
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x5C29             LDRB     R1,[R5, R0]
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UARTCharPutNonBlocking
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1EC             BNE.N    ??procTx_3
    467          
    468            uartRecord->tx.bufferHead = head;
   \                     ??procTx_4: (+1)
   \   0000003C   0x82BD             STRH     R5,[R7, #+20]
    469          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    470          
    471          /*************************************************************************************************
    472           * @fn      UART0 Rx/Tx ISR
    473           *
    474           * @brief   Called when a serial byte is ready to read and/or write.
    475           * NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    476           *
    477           * @param   void
    478           *
    479           * @return  void
    480          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          void interrupt_uart0(void)
    482          {
   \                     interrupt_uart0: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    483            UARTIntClear(UART0_BASE, (UART_INT_RX |  UART_INT_RT));
   \   00000002   0x2150             MOVS     R1,#+80
   \   00000004   0x....             LDR.N    R0,??DataTable10_5  ;; 0x4000c000
   \   00000006   0x.... 0x....      BL       UARTIntClear
    484            procRx(UART0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       procRx
    485          
    486            UARTIntClear(UART0_BASE, (UART_INT_TX | UART_INT_CTS));
   \   00000010   0x2122             MOVS     R1,#+34
   \   00000012   0x....             LDR.N    R0,??DataTable10_5  ;; 0x4000c000
   \   00000014   0x.... 0x....      BL       UARTIntClear
    487            procTx(UART0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       procTx
    488          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    489          
    490          /*************************************************************************************************
    491           * @fn      UART1 Rx/Tx ISR
    492           *
    493           * @brief   Called when a serial byte is ready to read and/or write.
    494           * NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    495           *
    496           * @param   void
    497           *
    498           * @return  void
    499          **************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    500          void interrupt_uart1(void)
    501          {
   \                     interrupt_uart1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    502            UARTIntClear(UART1_BASE, (UART_INT_RX |  UART_INT_RT));
   \   00000002   0x2150             MOVS     R1,#+80
   \   00000004   0x....             LDR.N    R0,??DataTable10_8  ;; 0x4000d000
   \   00000006   0x.... 0x....      BL       UARTIntClear
    503            procRx(UART1);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       procRx
    504          
    505            UARTIntClear(UART1_BASE, (UART_INT_TX | UART_INT_CTS));
   \   00000010   0x2122             MOVS     R1,#+34
   \   00000012   0x....             LDR.N    R0,??DataTable10_8  ;; 0x4000d000
   \   00000014   0x.... 0x....      BL       UARTIntClear
    506            procTx(UART1);
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      BL       procTx
    507          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     CP2102_Message_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     MSP_Message_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     CP2102_Record

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x400D9000         DC32     0x400d9000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400D4108         DC32     0x400d4108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     MSP_Record

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x400D4100         DC32     0x400d4100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x4000D000         DC32     0x4000d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     UBRRTable
    508          
    509          /**************************************************************************************************
    510          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HalUARTCloseIsr
         8   -> UARTDisable
         8   -> osal_mem_free
         8   -> recRst
      48   HalUARTInitIsr
        48   -> HalUARTOpen
      24   HalUARTOpenIsr
        24   -> GPIOPinTypeUARTInput
        24   -> GPIOPinTypeUARTOutput
        24   -> HalUARTClose
        24   -> IOCPinConfigPeriphInput
        24   -> IOCPinConfigPeriphOutput
        24   -> IntEnable
        24   -> SysCtrlClockGet
        24   -> SysCtrlPeripheralEnable
        24   -> UARTConfigSetExpClk
        24   -> UARTEnable
        24   -> UARTFIFOEnable
        24   -> UARTFIFOLevelSet
        24   -> UARTIntClear
        24   -> UARTIntEnable
        24   -> osal_mem_alloc
        24   -> osal_mem_free
        24   -> recRst
       8   HalUARTReadIsr
      24   HalUARTWriteIsr
        24   -> IntMasterDisable
        24   -> IntMasterEnable
        24   -> procTx
       0   Hal_UART_RxBufLenIsr
       0   Hal_UART_TxBufLen
       8   interrupt_uart0
         8   -> UARTIntClear
         8   -> procRx
         8   -> procTx
       8   interrupt_uart1
         8   -> UARTIntClear
         8   -> procRx
         8   -> procTx
      16   procRx
        16   -> UARTCharGetNonBlocking
        16   -> UARTCharsAvail
        16   -> osal_GetSystemClock
      24   procTx
        24   -> UARTCharPutNonBlocking
       0   recRst


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      44  CP2102_Record
      46  HalUARTCloseIsr
      84  HalUARTInitIsr
     380  HalUARTOpenIsr
      72  HalUARTReadIsr
     158  HalUARTWriteIsr
      38  Hal_UART_RxBufLenIsr
      38  Hal_UART_TxBufLen
      44  MSP_Record
      20  UBRRTable
      32  interrupt_uart0
      32  interrupt_uart1
      76  procRx
      64  procTx
      40  recRst

 
    88 bytes in section .bss
    20 bytes in section .rodata
 1 100 bytes in section .text
 
 1 100 bytes of CODE  memory
    20 bytes of CONST memory
    88 bytes of DATA  memory

Errors: none
Warnings: none
