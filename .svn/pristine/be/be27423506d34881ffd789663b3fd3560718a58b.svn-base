///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM       11/Apr/2015  21:30:15
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\AF.c
//    Command line =  
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\AF.c" -D
//        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
//        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
//        LCD_SUPPORTED=YES -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
//        --preprocess=cl
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
//        --diag_suppress Pa082 -o
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
//        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
//        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
//        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\"
//        -I "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
//        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
//    List file    =  
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\AF.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN APSDE_DataReq
        EXTERN APSDE_DataReqMTU
        EXTERN NLME_GetShortAddr
        EXTERN NLME_IsAddressBroadcast
        EXTERN RTG_AddSrcRtgEntry_Guaranteed
        EXTERN RTG_CheckRtStatus
        EXTERN aps_FindGroupForEndpoint
        EXTERN apsfSendFragmented
        EXTERN osal_mem_alloc
        EXTERN osal_mem_free
        EXTERN osal_memcpy
        EXTERN osal_msg_allocate
        EXTERN osal_msg_send
        EXTERN sAddrExtCpy

        PUBLIC AF_DataRequest
        PUBLIC AF_DataRequestDiscoverRoute
        PUBLIC AF_DataRequestSrcRtg
        PUBLIC afAPSF_ConfigGet
        PUBLIC afAPSF_ConfigSet
        PUBLIC afCopyAddress
        PUBLIC afDataConfirm
        PUBLIC afDataReqMTU
        PUBLIC afDelete
        PUBLIC afEndPoints
        PUBLIC afFindEndPointDesc
        PUBLIC afFindSimpleDesc
        PUBLIC afGetMatch
        PUBLIC afIncomingData
        PUBLIC afNumEndPoints
        PUBLIC afReflectError
        PUBLIC afRegister
        PUBLIC afRegisterExtended
        PUBLIC afSetApplCB
        PUBLIC afSetMatch
        PUBLIC epList

// C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\AF.c
//    1 /**************************************************************************************************
//    2   Filename:       AF.c
//    3   Revised:        $Date: 2014-06-30 16:29:17 -0700 (Mon, 30 Jun 2014) $
//    4   Revision:       $Revision: 39295 $
//    5 
//    6   Description:    Application Framework - Device Description helper functions
//    7 
//    8 
//    9   Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 
//   44 #include "OSAL.h"
//   45 #include "AF.h"
//   46 #include "nwk_globals.h"
//   47 #include "nwk_util.h"
//   48 #include "aps_groups.h"
//   49 #include "ZDProfile.h"
//   50 #include "aps_frag.h"
//   51 #include "rtg.h"
//   52 
//   53 #if defined ( MT_AF_CB_FUNC )
//   54   #include "MT_AF.h"
//   55 #endif
//   56 
//   57 #if defined ( INTER_PAN )
//   58   #include "stub_aps.h"
//   59 #endif
//   60 
//   61 /*********************************************************************
//   62  * MACROS
//   63  */
//   64 
//   65 /*********************************************************************
//   66  * @fn      afSend
//   67  *
//   68  * @brief   Helper macro for V1 API to invoke V2 API.
//   69  *
//   70  * input parameters
//   71  *
//   72  * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
//   73  * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
//   74  * @param   cID - A valid cluster ID as specified by the Profile.
//   75  * @param   len - Number of bytes of data pointed to by next param.
//   76  * @param  *buf - A pointer to the data bytes to send.
//   77  * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
//   78  * @param  *transID - A pointer to a byte which can be modified and which will
//   79  *                    be used as the transaction sequence number of the msg.
//   80  *
//   81  * output parameters
//   82  *
//   83  * @param  *transID - Incremented by one if the return value is success.
//   84  *
//   85  * @return  afStatus_t - See previous definition of afStatus_... types.
//   86  */
//   87 #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \ 
//   88         AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \ 
//   89                           (cID), (len), (buf), (transID), (options), (radius) )
//   90 
//   91 /*********************************************************************
//   92  * GLOBAL VARIABLES
//   93  */
//   94 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   95 epList_t *epList;
epList:
        DS8 4
//   96 
//   97 /*********************************************************************
//   98  * LOCAL FUNCTIONS
//   99  */
//  100 
//  101 static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
//  102                 zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
//  103                 uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp, uint8 radius );
//  104 
//  105 static epList_t *afFindEndPointDescList( uint8 EndPoint );
//  106 
//  107 static pDescCB afGetDescCB( endPointDesc_t *epDesc );
//  108 
//  109 /*********************************************************************
//  110  * PUBLIC FUNCTIONS
//  111  */
//  112 
//  113 /*********************************************************************
//  114  * @fn      afInit
//  115  *
//  116  * @brief   Initialization function for the AF.
//  117  *
//  118  * @param   none
//  119  *
//  120  * @return  none
//  121 void afInit( void )
//  122 {
//  123 }
//  124  */
//  125 
//  126 /*********************************************************************
//  127  * @fn      afRegisterExtended
//  128  *
//  129  * @brief   Register an Application's EndPoint description.
//  130  *
//  131  * @param   epDesc - pointer to the Application's endpoint descriptor.
//  132  * @param   descFn - pointer to descriptor callback function
//  133  * @param   applFn - pointer to the Application callback function
//  134  *
//  135  * NOTE:  The memory that epDesc is pointing to must exist after this call.
//  136  *
//  137  * @return  Pointer to epList_t on success, NULL otherwise.
//  138  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  139 epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn, pApplCB applFn )
//  140 {
afRegisterExtended:
        PUSH     {R4-R6,LR}
        MOVS     R5,R0
        MOVS     R6,R1
        MOVS     R4,R2
//  141   epList_t *ep = osal_mem_alloc(sizeof(epList_t));
        MOVS     R0,#+20
        BL       osal_mem_alloc
//  142 
//  143   if (ep != NULL)
        CMP      R0,#+0
        BEQ.N    ??afRegisterExtended_0
//  144   {
//  145     ep->nextDesc = epList;
        LDR.W    R1,??DataTable7
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
//  146     epList = ep;
        LDR.W    R1,??DataTable7
        STR      R0,[R1, #+0]
//  147     ep->epDesc = epDesc;
        STR      R5,[R0, #+4]
//  148     ep->pfnDescCB = descFn;
        STR      R6,[R0, #+8]
//  149     ep->apsfCfg.frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
        MOVS     R1,#+50
        STRB     R1,[R0, #+12]
//  150     ep->apsfCfg.windowSize = APSF_DEFAULT_WINDOW_SIZE;
        MOVS     R1,#+1
        STRB     R1,[R0, #+13]
//  151     ep->flags = eEP_AllowMatch;  // Default to allow Match Descriptor.
        MOVS     R1,#+1
        STRB     R1,[R0, #+14]
//  152     ep->pfnApplCB = applFn;
        STR      R4,[R0, #+16]
//  153   }
//  154 
//  155   return ep;
??afRegisterExtended_0:
        POP      {R4-R6,PC}       ;; return
//  156 }
//  157 
//  158 /*********************************************************************
//  159  * @fn      afRegister
//  160  *
//  161  * @brief   Register an Application's EndPoint description.
//  162  *
//  163  * @param   epDesc - pointer to the Application's endpoint descriptor.
//  164  *
//  165  * NOTE:  The memory that epDesc is pointing to must exist after this call.
//  166  *
//  167  * @return  afStatus_SUCCESS - Registered
//  168  *          afStatus_MEM_FAIL - not enough memory to add descriptor
//  169  *          afStatus_INVALID_PARAMETER - duplicate endpoint
//  170  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  171 afStatus_t afRegister( endPointDesc_t *epDesc )
//  172 {
afRegister:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  173   if (afFindEndPointDescList(epDesc->endPoint))  // Look for duplicate endpoint.
        LDRB     R0,[R4, #+0]
        BL       afFindEndPointDescList
        CMP      R0,#+0
        BEQ.N    ??afRegister_0
//  174   {
//  175     return afStatus_INVALID_PARAMETER;
        MOVS     R0,#+2
        B.N      ??afRegister_1
//  176   }
//  177 
//  178   return ((NULL == afRegisterExtended(epDesc, NULL, NULL)) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
??afRegister_0:
        MOVS     R2,#+0
        MOVS     R1,#+0
        MOVS     R0,R4
        BL       afRegisterExtended
        CMP      R0,#+0
        BNE.N    ??afRegister_2
        MOVS     R0,#+16
        B.N      ??afRegister_3
??afRegister_2:
        MOVS     R0,#+0
??afRegister_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??afRegister_1:
        POP      {R4,PC}          ;; return
//  179 }
//  180 
//  181 /*********************************************************************
//  182  * @fn      afDelete
//  183  *
//  184  * @brief   Delete an Application's EndPoint descriptor and frees the memory
//  185  *
//  186  * @param   EndPoint - Application Endpoint to delete
//  187  *
//  188  * @return  afStatus_SUCCESS - endpoint deleted
//  189  *          afStatus_INVALID_PARAMETER - endpoint not found
//  190  *          afStatus_FAILED - endpoint list empty
//  191  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  192 afStatus_t afDelete( uint8 EndPoint )
//  193 {
afDelete:
        PUSH     {R7,LR}
//  194   epList_t *epCurrent;
//  195   epList_t *epPrevious;
//  196 
//  197   if ( epList != NULL )
        LDR.W    R1,??DataTable7
        LDR      R1,[R1, #+0]
        CMP      R1,#+0
        BEQ.N    ??afDelete_0
//  198   {
//  199     epPrevious = epCurrent = epList;
        LDR.W    R1,??DataTable7
        LDR      R1,[R1, #+0]
        MOVS     R2,R1
//  200 
//  201     // first element of the list matches
//  202     if ( epCurrent->epDesc->endPoint == EndPoint )
        LDR      R3,[R1, #+4]
        LDRB     R3,[R3, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R3,R0
        BNE.N    ??afDelete_1
//  203     {
//  204       epList = epCurrent->nextDesc;
        LDR      R0,[R1, #+0]
        LDR.W    R2,??DataTable7
        STR      R0,[R2, #+0]
//  205       osal_mem_free( epCurrent );
        MOVS     R0,R1
        BL       osal_mem_free
//  206 
//  207       return ( afStatus_SUCCESS );
        MOVS     R0,#+0
        B.N      ??afDelete_2
//  208     }
//  209     else
//  210     {
//  211       // search the list
//  212       for ( epCurrent = epPrevious->nextDesc;
??afDelete_1:
        LDR      R1,[R2, #+0]
        B.N      ??afDelete_3
//  213             epCurrent != NULL;
//  214             epCurrent = epCurrent->nextDesc )
//  215       {
//  216         if ( epCurrent->epDesc->endPoint == EndPoint )
//  217         {
//  218           epPrevious->nextDesc = epCurrent->nextDesc;
//  219           osal_mem_free( epCurrent );
//  220 
//  221           // delete the entry and free the memory
//  222           return ( afStatus_SUCCESS );
//  223         }
//  224         epPrevious = epCurrent;
??afDelete_4:
        MOVS     R2,R1
        LDR      R1,[R1, #+0]
??afDelete_3:
        CMP      R1,#+0
        BEQ.N    ??afDelete_5
        LDR      R3,[R1, #+4]
        LDRB     R3,[R3, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R3,R0
        BNE.N    ??afDelete_4
        LDR      R0,[R1, #+0]
        STR      R0,[R2, #+0]
        MOVS     R0,R1
        BL       osal_mem_free
        MOVS     R0,#+0
        B.N      ??afDelete_2
//  225       }
//  226     }
//  227 
//  228     // no endpoint found
//  229     return ( afStatus_INVALID_PARAMETER );
??afDelete_5:
        MOVS     R0,#+2
        B.N      ??afDelete_2
//  230   }
//  231   else
//  232   {
//  233     // epList is empty
//  234     return ( afStatus_FAILED );
??afDelete_0:
        MOVS     R0,#+1
??afDelete_2:
        POP      {R1,PC}          ;; return
//  235   }
//  236 }
//  237 
//  238 /*********************************************************************
//  239  * @fn          afDataConfirm
//  240  *
//  241  * @brief       This function will generate the Data Confirm back to
//  242  *              the application.
//  243  *
//  244  * @param       endPoint - confirm end point
//  245  * @param       transID - transaction ID from APSDE_DATA_REQUEST
//  246  * @param       status - status of APSDE_DATA_REQUEST
//  247  *
//  248  * @return      none
//  249  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  250 void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
//  251 {
afDataConfirm:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
//  252   endPointDesc_t *epDesc;
//  253   afDataConfirm_t *msgPtr;
//  254 
//  255   // Find the endpoint description
//  256   epDesc = afFindEndPointDesc( endPoint );
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDesc
        MOVS     R7,R0
//  257   if ( epDesc == NULL )
        CMP      R7,#+0
        BEQ.N    ??afDataConfirm_0
//  258     return;
//  259 
//  260   // Determine the incoming command type
//  261   msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
??afDataConfirm_1:
        MOVS     R0,#+4
        BL       osal_msg_allocate
//  262   if ( msgPtr )
        CMP      R0,#+0
        BEQ.N    ??afDataConfirm_2
//  263   {
//  264     // Build the Data Confirm message
//  265     msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
        MOVS     R1,#+253
        STRB     R1,[R0, #+0]
//  266     msgPtr->hdr.status = status;
        STRB     R6,[R0, #+1]
//  267     msgPtr->endpoint = endPoint;
        STRB     R4,[R0, #+2]
//  268     msgPtr->transID = transID;
        STRB     R5,[R0, #+3]
//  269 
//  270 #if defined ( MT_AF_CB_FUNC )
//  271     /* If MT has subscribed for this callback, don't send as a message. */
//  272     if ( AFCB_CHECK(CB_ID_AF_DATA_CNF,*(epDesc->task_id)) )
//  273     {
//  274       /* Send callback if it's subscribed */
//  275       MT_AfDataConfirm ((void *)msgPtr);
//  276       /* Release the memory. */
//  277       osal_msg_deallocate( (void *)msgPtr );
//  278     }
//  279     else
//  280 #endif
//  281     {
//  282       /* send message through task message */
//  283       osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
        MOVS     R1,R0
        LDR      R0,[R7, #+4]
        LDRB     R0,[R0, #+0]
        BL       osal_msg_send
//  284     }
//  285   }
//  286 }
??afDataConfirm_2:
??afDataConfirm_0:
        POP      {R0,R4-R7,PC}    ;; return
//  287 
//  288 /*********************************************************************
//  289  * @fn          afReflectError
//  290  *
//  291  * @brief       This function will generate the Reflect Error message to
//  292  *              the application.
//  293  *
//  294  * @param       dstAddrMode - mode of dstAdd - 0 - normal short addr, 1 - group Address
//  295  * @param       dstAddr - intended destination
//  296  * @param       endPoint - confirm end point
//  297  * @param       transID - transaction ID from APSDE_DATA_REQUEST
//  298  * @param       status - status of APSDE_DATA_REQUEST
//  299  *
//  300  * @return      none
//  301  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  302 void afReflectError( uint8 dstAddrMode, uint16 dstAddr, uint8 endPoint, uint8 transID, ZStatus_t status )
//  303 {
afReflectError:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  304   endPointDesc_t *epDesc;
//  305   afReflectError_t *msgPtr;
//  306 
//  307   // Find the endpoint description
//  308   epDesc = afFindEndPointDesc( endPoint );
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDesc
        MOV      R8,R0
//  309   if ( epDesc == NULL )
        CMP      R8,#+0
        BEQ.N    ??afReflectError_0
//  310     return;
//  311 
//  312   // Determine the incoming command type
//  313   msgPtr = (afReflectError_t *)osal_msg_allocate( sizeof(afReflectError_t) );
??afReflectError_1:
        MOVS     R0,#+8
        BL       osal_msg_allocate
//  314   if ( msgPtr )
        CMP      R0,#+0
        BEQ.N    ??afReflectError_2
//  315   {
//  316     // Build the Data Confirm message
//  317     msgPtr->hdr.event = AF_REFLECT_ERROR_CMD;
        MOVS     R1,#+254
        STRB     R1,[R0, #+0]
//  318     msgPtr->hdr.status = status;
        LDR      R1,[SP, #+24]
        STRB     R1,[R0, #+1]
//  319     msgPtr->endpoint = endPoint;
        STRB     R6,[R0, #+2]
//  320     msgPtr->transID = transID;
        STRB     R7,[R0, #+3]
//  321     msgPtr->dstAddrMode = dstAddrMode;
        STRB     R4,[R0, #+4]
//  322     msgPtr->dstAddr = dstAddr;
        STRH     R5,[R0, #+6]
//  323 
//  324 #if defined ( MT_AF_CB_FUNC )
//  325     /* If MT has subscribed for this callback, don't send as a message. */
//  326     if ( AFCB_CHECK( CB_ID_AF_REFLECT_ERROR, *(epDesc->task_id) ) )
//  327     {
//  328       /* Send callback if it's subscribed */
//  329       MT_AfReflectError( (void *)msgPtr );
//  330       /* Release the memory. */
//  331       osal_msg_deallocate( (void *)msgPtr );
//  332     }
//  333     else
//  334 #endif
//  335     {
//  336       /* send message through task message */
//  337       osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
        MOVS     R1,R0
        LDR      R0,[R8, #+4]
        LDRB     R0,[R0, #+0]
        BL       osal_msg_send
//  338     }
//  339   }
//  340 }
??afReflectError_2:
??afReflectError_0:
        POP      {R4-R8,PC}       ;; return
//  341 
//  342 /*********************************************************************
//  343  * @fn          afIncomingData
//  344  *
//  345  * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
//  346  *
//  347  * @param       aff  - pointer to APS frame format
//  348  * @param       SrcAddress  - Source address
//  349  * @param       SrcPanId  - Source PAN ID
//  350  * @param       sig - incoming message's link quality
//  351  * @param       nwkSeqNum - incoming network sequence number (from nwk header frame)
//  352  * @param       SecurityUse - Security enable/disable
//  353  * @param       timestamp - the MAC Timer2 timestamp at Rx.
//  354  * @param       radius - incoming messages received radius
//  355  *
//  356  * @return      none
//  357  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  358 void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress, uint16 SrcPanId,
//  359                      NLDE_Signal_t *sig, uint8 nwkSeqNum, uint8 SecurityUse,
//  360                      uint32 timestamp, uint8 radius )
//  361 {
afIncomingData:
        PUSH     {R1-R11,LR}
        SUB      SP,SP,#+24
        MOVS     R7,R0
//  362   endPointDesc_t *epDesc = NULL;
        MOVS     R4,#+0
//  363   epList_t *pList = epList;
        LDR.W    R0,??DataTable7
        LDR      R9,[R0, #+0]
//  364 #if !defined ( APS_NO_GROUPS )
//  365   uint8 grpEp = APS_GROUPS_EP_NOT_FOUND;
        MOVS     R8,#+254
//  366 #endif
//  367 
//  368   if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
        LDRB     R0,[R7, #+0]
        ANDS     R0,R0,#0xC
        CMP      R0,#+12
        BNE.N    ??afIncomingData_0
//  369   {
//  370 #if !defined ( APS_NO_GROUPS )
//  371     // Find the first endpoint for this group
//  372     grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
        MOVS     R1,#+254
        LDRH     R0,[R7, #+4]
        BL       aps_FindGroupForEndpoint
        MOV      R8,R0
//  373     if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+254
        BEQ.W    ??afIncomingData_1
//  374       return;   // No endpoint found
//  375 
//  376     epDesc = afFindEndPointDesc( grpEp );
??afIncomingData_2:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDesc
        MOVS     R4,R0
//  377     if ( epDesc == NULL )
        CMP      R4,#+0
        BEQ.W    ??afIncomingData_1
//  378       return;   // Endpoint descriptor not found
//  379 
//  380     pList = afFindEndPointDescList( epDesc->endPoint );
??afIncomingData_3:
        LDRB     R0,[R4, #+0]
        BL       afFindEndPointDescList
        MOV      R9,R0
??afIncomingData_4:
        LDR      R5,[SP, #+76]
        LDR      R10,[SP, #+80]
        LDR      R6,[SP, #+84]
        B.N      ??afIncomingData_5
//  381 #else
//  382     return; // Not supported
//  383 #endif
//  384   }
//  385   else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
??afIncomingData_0:
        LDRB     R0,[R7, #+2]
        CMP      R0,#+255
        BNE.N    ??afIncomingData_6
//  386   {
//  387     // Set the list
//  388     if ( pList != NULL )
        CMP      R9,#+0
        BEQ.N    ??afIncomingData_4
//  389     {
//  390       epDesc = pList->epDesc;
        LDR      R4,[R9, #+4]
        B.N      ??afIncomingData_4
//  391     }
//  392   }
//  393   else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
??afIncomingData_6:
        LDRB     R0,[R7, #+2]
        BL       afFindEndPointDesc
        MOVS     R4,R0
        CMP      R0,#+0
        BEQ.N    ??afIncomingData_4
//  394   {
//  395     pList = afFindEndPointDescList( epDesc->endPoint );
        LDRB     R0,[R4, #+0]
        BL       afFindEndPointDescList
        MOV      R9,R0
        B.N      ??afIncomingData_4
//  396   }
//  397 
//  398   while ( epDesc )
//  399   {
//  400     uint16 epProfileID = 0xFFFE;  // Invalid Profile ID
//  401 
//  402     if ( pList->pfnDescCB )
//  403     {
//  404       uint16 *pID = (uint16 *)(pList->pfnDescCB(
//  405                                  AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
//  406       if ( pID )
//  407       {
//  408         epProfileID = *pID;
//  409         osal_mem_free( pID );
//  410       }
//  411     }
//  412     else if ( epDesc->simpleDesc )
//  413     {
//  414       epProfileID = epDesc->simpleDesc->AppProfId;
//  415     }
//  416 
//  417     // First part of verification is to make sure that:
//  418     // the local Endpoint ProfileID matches the received ProfileID OR
//  419     // the message is specifically send to ZDO (this excludes the broadcast endpoint) OR
//  420     // if the Wildcard ProfileID is received the message should not be sent to ZDO endpoint
//  421     if ( (aff->ProfileID == epProfileID) ||
//  422          ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) ||
//  423          ((epDesc->endPoint != ZDO_EP) && ( aff->ProfileID == ZDO_WILDCARD_PROFILE_ID )) )
//  424     {
//  425       // Save original endpoint
//  426       uint8 endpoint = aff->DstEndPoint;
//  427 
//  428       // overwrite with descriptor's endpoint
//  429       aff->DstEndPoint = epDesc->endPoint;
//  430 
//  431       afBuildMSGIncoming( aff, epDesc, SrcAddress, SrcPanId, sig,
//  432                          nwkSeqNum, SecurityUse, timestamp, radius );
//  433 
//  434       // Restore with original endpoint
//  435       aff->DstEndPoint = endpoint;
//  436     }
//  437 
//  438     if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
//  439     {
//  440 #if !defined ( APS_NO_GROUPS )
//  441       // Find the next endpoint for this group
//  442       grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
//  443       if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
//  444         return;   // No endpoint found
//  445 
//  446       epDesc = afFindEndPointDesc( grpEp );
//  447       if ( epDesc == NULL )
//  448         return;   // Endpoint descriptor not found
//  449 
//  450       pList = afFindEndPointDescList( epDesc->endPoint );
??afIncomingData_7:
        LDRB     R0,[R4, #+0]
        BL       afFindEndPointDescList
        MOV      R9,R0
??afIncomingData_5:
        CMP      R4,#+0
        BEQ.N    ??afIncomingData_8
        MOVW     R11,#+65534
        LDR      R0,[R9, #+8]
        CMP      R0,#+0
        BEQ.N    ??afIncomingData_9
        LDRB     R1,[R4, #+0]
        MOVS     R0,#+2
        LDR      R2,[R9, #+8]
        BLX      R2
        CMP      R0,#+0
        BEQ.N    ??afIncomingData_10
        LDRH     R11,[R0, #+0]
        BL       osal_mem_free
        B.N      ??afIncomingData_10
??afIncomingData_9:
        LDR      R0,[R4, #+8]
        CMP      R0,#+0
        BEQ.N    ??afIncomingData_10
        LDR      R0,[R4, #+8]
        LDRH     R11,[R0, #+2]
??afIncomingData_10:
        LDRH     R0,[R7, #+8]
        UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
        CMP      R0,R11
        BEQ.N    ??afIncomingData_11
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BNE.N    ??afIncomingData_12
        LDRH     R0,[R7, #+8]
        CMP      R0,#+0
        BEQ.N    ??afIncomingData_11
??afIncomingData_12:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??afIncomingData_13
        LDRH     R0,[R7, #+8]
        MOVW     R1,#+65535
        CMP      R0,R1
        BNE.N    ??afIncomingData_13
??afIncomingData_11:
        LDRB     R11,[R7, #+2]
        LDRB     R0,[R4, #+0]
        STRB     R0,[R7, #+2]
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+16]
        STR      R10,[SP, #+12]
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+8]
        LDRB     R0,[SP, #+72]
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+32]
        STR      R0,[SP, #+0]
        LDRH     R3,[SP, #+28]
        LDR      R2,[SP, #+24]
        MOVS     R1,R4
        MOVS     R0,R7
        BL       afBuildMSGIncoming
        STRB     R11,[R7, #+2]
??afIncomingData_13:
        LDRB     R0,[R7, #+0]
        ANDS     R0,R0,#0xC
        CMP      R0,#+12
        BNE.N    ??afIncomingData_14
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRH     R0,[R7, #+4]
        BL       aps_FindGroupForEndpoint
        MOV      R8,R0
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+254
        BEQ.N    ??afIncomingData_1
??afIncomingData_15:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDesc
        MOVS     R4,R0
        CMP      R4,#+0
        BNE.N    ??afIncomingData_7
        B.N      ??afIncomingData_1
//  451 #else
//  452       return;
//  453 #endif
//  454     }
//  455     else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
??afIncomingData_14:
        LDRB     R0,[R7, #+2]
        CMP      R0,#+255
        BNE.N    ??afIncomingData_16
//  456     {
//  457       pList = pList->nextDesc;
        LDR      R9,[R9, #+0]
//  458       if ( pList )
        CMP      R9,#+0
        BEQ.N    ??afIncomingData_17
//  459         epDesc = pList->epDesc;
        LDR      R4,[R9, #+4]
        B.N      ??afIncomingData_5
//  460       else
//  461         epDesc = NULL;
??afIncomingData_17:
        MOVS     R4,#+0
        B.N      ??afIncomingData_5
//  462     }
//  463     else
//  464       epDesc = NULL;
??afIncomingData_16:
        MOVS     R4,#+0
        B.N      ??afIncomingData_5
//  465   }
//  466 }
??afIncomingData_8:
??afIncomingData_1:
        ADD      SP,SP,#+36
        POP      {R4-R11,PC}      ;; return
//  467 
//  468 /*********************************************************************
//  469  * @fn          afBuildMSGIncoming
//  470  *
//  471  * @brief       Build the message for the app
//  472  *
//  473  * @param
//  474  *
//  475  * @return      pointer to next in data buffer
//  476  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  477 static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
//  478                  zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
//  479                  uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp, uint8 radius )
//  480 {
afBuildMSGIncoming:
        PUSH     {R3-R9,LR}
        MOVS     R7,R0
        MOVS     R4,R1
        MOV      R9,R2
        MOV      R8,R3
//  481   afIncomingMSGPacket_t *MSGpkt;
//  482   const uint8 len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
        LDRB     R0,[R7, #+20]
        ADDS     R0,R0,#+48
//  483   uint8 *asdu = aff->asdu;
        LDR      R5,[R7, #+16]
//  484   MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       osal_msg_allocate
        MOVS     R6,R0
//  485 
//  486   if ( MSGpkt == NULL )
        CMP      R6,#+0
        BEQ.N    ??afBuildMSGIncoming_0
//  487   {
//  488     return;
//  489   }
//  490 
//  491   MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
??afBuildMSGIncoming_1:
        MOVS     R0,#+26
        STRB     R0,[R6, #+0]
//  492   MSGpkt->groupId = aff->GroupID;
        LDRH     R0,[R7, #+4]
        STRH     R0,[R6, #+2]
//  493   MSGpkt->clusterId = aff->ClusterID;
        LDRH     R0,[R7, #+6]
        STRH     R0,[R6, #+4]
//  494   afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
        MOV      R1,R9
        ADDS     R0,R6,#+6
        BL       afCopyAddress
//  495   MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
        LDRB     R0,[R7, #+3]
        STRB     R0,[R6, #+15]
//  496   MSGpkt->endPoint = epDesc->endPoint;
        LDRB     R0,[R4, #+0]
        STRB     R0,[R6, #+20]
//  497   MSGpkt->wasBroadcast = aff->wasBroadcast;
        LDRB     R0,[R7, #+12]
        STRB     R0,[R6, #+21]
        LDR      R0,[SP, #+32]
//  498   MSGpkt->LinkQuality = sig->LinkQuality;
        LDRB     R1,[R0, #+0]
        STRB     R1,[R6, #+22]
//  499   MSGpkt->correlation = sig->correlation;
        LDRB     R1,[R0, #+1]
        STRB     R1,[R6, #+23]
//  500   MSGpkt->rssi = sig->rssi;
        LDRB     R0,[R0, #+2]
        STRB     R0,[R6, #+24]
//  501   MSGpkt->SecurityUse = SecurityUse;
        LDR      R0,[SP, #+40]
        STRB     R0,[R6, #+25]
//  502   MSGpkt->timestamp = timestamp;
        LDR      R0,[SP, #+44]
        STR      R0,[R6, #+28]
//  503   MSGpkt->nwkSeqNum = nwkSeqNum;
        LDR      R0,[SP, #+36]
        STRB     R0,[R6, #+32]
//  504   MSGpkt->macSrcAddr = aff->macSrcAddr;
        LDRH     R0,[R7, #+26]
        STRH     R0,[R6, #+44]
//  505   MSGpkt->macDestAddr = aff->macDestAddr;
        LDRH     R0,[R7, #+10]
        STRH     R0,[R6, #+18]
//  506   MSGpkt->srcAddr.panId = SrcPanId;
        STRH     R8,[R6, #+16]
//  507   MSGpkt->cmd.TransSeqNumber = 0;
        MOVS     R0,#+0
        STRB     R0,[R6, #+36]
//  508   MSGpkt->cmd.DataLength = aff->asduLength;
        LDRB     R0,[R7, #+20]
        STRH     R0,[R6, #+38]
//  509   MSGpkt->radius = radius;
        LDR      R0,[SP, #+48]
        STRB     R0,[R6, #+46]
//  510 
//  511   if ( MSGpkt->cmd.DataLength )
        LDRH     R0,[R6, #+38]
        CMP      R0,#+0
        BEQ.N    ??afBuildMSGIncoming_2
//  512   {
//  513     MSGpkt->cmd.Data = (uint8 *)(MSGpkt + 1);
        ADDS     R0,R6,#+48
        STR      R0,[R6, #+40]
//  514     osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
        LDRH     R2,[R6, #+38]
        MOVS     R1,R5
        LDR      R0,[R6, #+40]
        BL       osal_memcpy
        B.N      ??afBuildMSGIncoming_3
//  515   }
//  516   else
//  517   {
//  518     MSGpkt->cmd.Data = NULL;
??afBuildMSGIncoming_2:
        MOVS     R0,#+0
        STR      R0,[R6, #+40]
//  519   }
//  520 
//  521 #if defined ( MT_AF_CB_FUNC )
//  522   // If ZDO or SAPI have registered for this endpoint, dont intercept it here
//  523   if (AFCB_CHECK(CB_ID_AF_DATA_IND, *(epDesc->task_id)))
//  524   {
//  525     MT_AfIncomingMsg( (void *)MSGpkt );
//  526     // Release the memory.
//  527     osal_msg_deallocate( (void *)MSGpkt );
//  528   }
//  529   else
//  530 #endif
//  531   {
//  532     // Send message through task message.
//  533     osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
??afBuildMSGIncoming_3:
        MOVS     R1,R6
        LDR      R0,[R4, #+4]
        LDRB     R0,[R0, #+0]
        BL       osal_msg_send
//  534   }
//  535 }
??afBuildMSGIncoming_0:
        POP      {R0,R4-R9,PC}    ;; return
//  536 
//  537 /*********************************************************************
//  538  * @fn      AF_DataRequest
//  539  *
//  540  * @brief   Common functionality for invoking APSDE_DataReq() for both
//  541  *          SendMulti and MSG-Send.
//  542  *
//  543  * input parameters
//  544  *
//  545  * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
//  546  * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
//  547  * @param   cID - A valid cluster ID as specified by the Profile.
//  548  * @param   len - Number of bytes of data pointed to by next param.
//  549  * @param  *buf - A pointer to the data bytes to send.
//  550  * @param  *transID - A pointer to a byte which can be modified and which will
//  551  *                    be used as the transaction sequence number of the msg.
//  552  * @param   options - Valid bit mask of Tx options.
//  553  * @param   radius - Normally set to AF_DEFAULT_RADIUS.
//  554  *
//  555  * output parameters
//  556  *
//  557  * @param  *transID - Incremented by one if the return value is success.
//  558  *
//  559  * @return  afStatus_t - See previous definition of afStatus_... types.
//  560  */

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  561 uint8 AF_DataRequestDiscoverRoute = DISC_ROUTE_NETWORK;
AF_DataRequestDiscoverRoute:
        DATA
        DC8 1

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  562 afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
//  563                            uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
//  564                            uint8 options, uint8 radius )
//  565 {
AF_DataRequest:
        PUSH     {R4-R8,LR}
        SUB      SP,SP,#+40
        MOVS     R5,R0
        MOVS     R6,R1
        MOVS     R7,R2
        MOV      R8,R3
//  566   pDescCB pfnDescCB;
//  567   ZStatus_t stat;
//  568   APSDE_DataReq_t req;
//  569   afDataReqMTU_t mtu;
//  570   epList_t *pList;
//  571 
//  572   // Verify source end point
//  573   if ( srcEP == NULL )
        CMP      R6,#+0
        BNE.N    ??AF_DataRequest_0
//  574   {
//  575     return afStatus_INVALID_PARAMETER;
        MOVS     R0,#+2
        B.N      ??AF_DataRequest_1
//  576   }
??AF_DataRequest_0:
        LDR      R4,[SP, #+72]
//  577 
//  578 #if !defined( REFLECTOR )
//  579   if ( dstAddr->addrMode == afAddrNotPresent )
//  580   {
//  581     return afStatus_INVALID_PARAMETER;
//  582   }
//  583 #endif
//  584 
//  585   // Check if route is available before sending data
//  586   if ( options & AF_LIMIT_CONCENTRATOR  )
        LSLS     R0,R4,#+28
        BPL.N    ??AF_DataRequest_2
//  587   {
//  588     if ( dstAddr->addrMode != afAddr16Bit )
        LDRB     R0,[R5, #+8]
        CMP      R0,#+2
        BEQ.N    ??AF_DataRequest_3
//  589     {
//  590       return ( afStatus_INVALID_PARAMETER );
        MOVS     R0,#+2
        B.N      ??AF_DataRequest_1
//  591     }
//  592 
//  593     // First, make sure the destination is not its self, then check for an existing route.
//  594     if ( (dstAddr->addr.shortAddr != NLME_GetShortAddr())
//  595         && (RTG_CheckRtStatus( dstAddr->addr.shortAddr, RT_ACTIVE, (MTO_ROUTE | NO_ROUTE_CACHE) ) != RTG_SUCCESS) )
??AF_DataRequest_3:
        BL       NLME_GetShortAddr
        LDRH     R1,[R5, #+0]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R1,R0
        BEQ.N    ??AF_DataRequest_2
        MOVS     R2,#+3
        MOVS     R1,#+1
        LDRH     R0,[R5, #+0]
        BL       RTG_CheckRtStatus
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_2
//  596     {
//  597       // A valid route to a concentrator wasn't found
//  598       return ( afStatus_NO_ROUTE );
        MOVS     R0,#+205
        B.N      ??AF_DataRequest_1
//  599     }
//  600   }
//  601 
//  602   // Validate broadcasting
//  603   if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
//  604        ( dstAddr->addrMode == afAddrBroadcast )    )
??AF_DataRequest_2:
        LDRB     R0,[R5, #+8]
        CMP      R0,#+2
        BEQ.N    ??AF_DataRequest_4
        LDRB     R0,[R5, #+8]
        CMP      R0,#+15
        BNE.N    ??AF_DataRequest_5
//  605   {
//  606     // Check for valid broadcast values
//  607     if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
??AF_DataRequest_4:
        LDRH     R0,[R5, #+0]
        BL       NLME_IsAddressBroadcast
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_6
//  608     {
//  609       // Force mode to broadcast
//  610       dstAddr->addrMode = afAddrBroadcast;
        MOVS     R0,#+15
        STRB     R0,[R5, #+8]
//  611     }
//  612     else
//  613     {
//  614       // Address is not a valid broadcast type
//  615       if ( dstAddr->addrMode == afAddrBroadcast )
//  616       {
//  617         return afStatus_INVALID_PARAMETER;
//  618       }
//  619     }
//  620   }
//  621   else if ( dstAddr->addrMode != afAddr64Bit &&
//  622             dstAddr->addrMode != afAddrGroup &&
//  623             dstAddr->addrMode != afAddrNotPresent )
//  624   {
//  625     return afStatus_INVALID_PARAMETER;
//  626   }
//  627 
//  628   // Set destination address
//  629   req.dstAddr.addrMode = dstAddr->addrMode;
??AF_DataRequest_7:
        LDRB     R0,[R5, #+8]
        STRB     R0,[SP, #+12]
//  630   if ( dstAddr->addrMode == afAddr64Bit )
        LDRB     R0,[R5, #+8]
        CMP      R0,#+3
        BNE.N    ??AF_DataRequest_8
//  631   {
//  632     osal_cpyExtAddr( req.dstAddr.addr.extAddr, dstAddr->addr.extAddr );
        MOVS     R1,R5
        ADD      R0,SP,#+4
        BL       sAddrExtCpy
        B.N      ??AF_DataRequest_9
//  633   }
??AF_DataRequest_6:
        LDRB     R0,[R5, #+8]
        CMP      R0,#+15
        BNE.N    ??AF_DataRequest_7
        MOVS     R0,#+2
        B.N      ??AF_DataRequest_1
??AF_DataRequest_5:
        LDRB     R0,[R5, #+8]
        CMP      R0,#+3
        BEQ.N    ??AF_DataRequest_7
        LDRB     R0,[R5, #+8]
        CMP      R0,#+1
        BEQ.N    ??AF_DataRequest_7
        LDRB     R0,[R5, #+8]
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_7
        MOVS     R0,#+2
        B.N      ??AF_DataRequest_1
//  634   else
//  635   {
//  636     req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
??AF_DataRequest_8:
        LDRH     R0,[R5, #+0]
        STRH     R0,[SP, #+4]
//  637   }
//  638 
//  639   // This option is to use Wildcard ProfileID in outgoing packets
//  640   if ( options & AF_WILDCARD_PROFILEID )
??AF_DataRequest_9:
        LSLS     R0,R4,#+30
        BPL.N    ??AF_DataRequest_10
//  641   {
//  642     req.profileID = ZDO_WILDCARD_PROFILE_ID;
        MOVW     R0,#+65535
        STRH     R0,[SP, #+20]
        B.N      ??AF_DataRequest_11
//  643   }
//  644   else
//  645   {
//  646     req.profileID = ZDO_PROFILE_ID;
??AF_DataRequest_10:
        MOVS     R0,#+0
        STRH     R0,[SP, #+20]
//  647 
//  648     if ( (pfnDescCB = afGetDescCB( srcEP )) )
        MOVS     R0,R6
        BL       afGetDescCB
        MOVS     R2,R0
        MOVS     R0,R2
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_12
//  649     {
//  650       uint16 *pID = (uint16 *)(pfnDescCB(
//  651                                    AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
        LDRB     R1,[R6, #+0]
        MOVS     R0,#+2
        BLX      R2
//  652       if ( pID )
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_11
//  653       {
//  654         req.profileID = *pID;
        LDRH     R1,[R0, #+0]
        STRH     R1,[SP, #+20]
//  655         osal_mem_free( pID );
        BL       osal_mem_free
        B.N      ??AF_DataRequest_11
//  656       }
//  657     }
//  658     else if ( srcEP->simpleDesc )
??AF_DataRequest_12:
        LDR      R0,[R6, #+8]
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_11
//  659     {
//  660       req.profileID = srcEP->simpleDesc->AppProfId;
        LDR      R0,[R6, #+8]
        LDRH     R0,[R0, #+2]
        STRH     R0,[SP, #+20]
//  661     }
//  662   }
//  663 
//  664   req.txOptions = 0;
??AF_DataRequest_11:
        MOVS     R0,#+0
        STRH     R0,[SP, #+28]
//  665 
//  666   if ( ( options & AF_ACK_REQUEST              ) &&
//  667        ( req.dstAddr.addrMode != AddrBroadcast ) &&
//  668        ( req.dstAddr.addrMode != AddrGroup     )    )
        LSLS     R0,R4,#+27
        BPL.N    ??AF_DataRequest_13
        LDRB     R0,[SP, #+12]
        CMP      R0,#+15
        BEQ.N    ??AF_DataRequest_13
        LDRB     R0,[SP, #+12]
        CMP      R0,#+1
        BEQ.N    ??AF_DataRequest_13
//  669   {
//  670     req.txOptions |=  APS_TX_OPTIONS_ACK;
        LDRH     R0,[SP, #+28]
        ORRS     R0,R0,#0x4
        STRH     R0,[SP, #+28]
//  671   }
//  672 
//  673   if ( options & AF_SKIP_ROUTING )
??AF_DataRequest_13:
        LSLS     R0,R4,#+24
        BPL.N    ??AF_DataRequest_14
//  674   {
//  675     req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
        LDRH     R0,[SP, #+28]
        ORRS     R0,R0,#0x10
        STRH     R0,[SP, #+28]
//  676   }
//  677 
//  678   if ( options & AF_EN_SECURITY )
??AF_DataRequest_14:
        LSLS     R0,R4,#+25
        BPL.N    ??AF_DataRequest_15
//  679   {
//  680     req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
        LDRH     R0,[SP, #+28]
        ORRS     R0,R0,#0x1
        STRH     R0,[SP, #+28]
//  681     mtu.aps.secure = TRUE;
        MOVS     R0,#+1
        STRB     R0,[SP, #+1]
        B.N      ??AF_DataRequest_16
//  682   }
//  683   else
//  684   {
//  685     mtu.aps.secure = FALSE;
??AF_DataRequest_15:
        MOVS     R0,#+0
        STRB     R0,[SP, #+1]
//  686   }
//  687 
//  688   if ( options & AF_PREPROCESS )
??AF_DataRequest_16:
        LSLS     R0,R4,#+29
        BPL.N    ??AF_DataRequest_17
//  689   {
//  690     req.txOptions |=  APS_TX_OPTIONS_PREPROCESS;
        LDRH     R0,[SP, #+28]
        ORRS     R0,R0,#0x40
        STRH     R0,[SP, #+28]
//  691   }
//  692 
//  693   mtu.kvp = FALSE;
??AF_DataRequest_17:
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
//  694 
//  695   if ( options & AF_SUPRESS_ROUTE_DISC_NETWORK )
        LSLS     R0,R4,#+26
        BPL.N    ??AF_DataRequest_18
//  696   {
//  697     req.discoverRoute = DISC_ROUTE_INITIATE;
        MOVS     R0,#+4
        STRB     R0,[SP, #+31]
        B.N      ??AF_DataRequest_19
//  698   }
//  699   else
//  700   {
//  701     req.discoverRoute = AF_DataRequestDiscoverRoute;
??AF_DataRequest_18:
        LDR.N    R0,??DataTable7_1
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+31]
??AF_DataRequest_19:
        LDR      R4,[SP, #+68]
//  702   }
//  703 
//  704   req.transID       = *transID;
        LDRB     R0,[R4, #+0]
        STRB     R0,[SP, #+30]
//  705   req.srcEP         = srcEP->endPoint;
        LDRB     R0,[R6, #+0]
        STRB     R0,[SP, #+14]
//  706   req.dstEP         = dstAddr->endPoint;
        LDRB     R0,[R5, #+9]
        STRB     R0,[SP, #+15]
//  707   req.clusterID     = cID;
        STRH     R7,[SP, #+18]
//  708   req.asduLen       = len;
        STRH     R8,[SP, #+22]
//  709   req.asdu          = buf;
        LDR      R0,[SP, #+64]
        STR      R0,[SP, #+24]
//  710   req.radiusCounter = radius;
        LDR      R0,[SP, #+76]
        STRB     R0,[SP, #+32]
//  711 #if defined ( INTER_PAN )
//  712   req.dstPanId      = dstAddr->panId;
//  713 #endif // INTER_PAN
//  714 
//  715   // Look if there is a Callback function registered for this endpoint
//  716   // The callback is used to control the AF Transaction ID used when sending messages
//  717   pList = afFindEndPointDescList( srcEP->endPoint );
        LDRB     R0,[R6, #+0]
        BL       afFindEndPointDescList
        MOVS     R1,R0
//  718 
//  719   if ( ( pList != NULL ) && ( pList->pfnApplCB != NULL ) )
        CMP      R1,#+0
        BEQ.N    ??AF_DataRequest_20
        LDR      R0,[R1, #+16]
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_20
//  720   {
//  721     pList->pfnApplCB( &req );
        ADD      R0,SP,#+4
        LDR      R1,[R1, #+16]
        BLX      R1
//  722   }
//  723 
//  724 #if defined ( INTER_PAN )
//  725   if ( StubAPS_InterPan( dstAddr->panId, dstAddr->endPoint ) )
//  726   {
//  727     if ( len > INTERP_DataReqMTU() )
//  728     {
//  729       stat = afStatus_INVALID_PARAMETER;
//  730     }
//  731     else
//  732     {
//  733       stat = INTERP_DataReq( &req );
//  734     }
//  735   }
//  736   else
//  737 #endif // INTER_PAN
//  738   {
//  739     if (len > afDataReqMTU( &mtu ) )
??AF_DataRequest_20:
        ADD      R0,SP,#+0
        BL       afDataReqMTU
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
        CMP      R0,R8
        BCS.N    ??AF_DataRequest_21
//  740     {
//  741       if (apsfSendFragmented)
        LDR.N    R0,??DataTable7_2
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??AF_DataRequest_22
//  742       {
//  743         stat = (*apsfSendFragmented)( &req );
        ADD      R0,SP,#+4
        LDR.N    R1,??DataTable7_2
        LDR      R1,[R1, #+0]
        BLX      R1
        MOVS     R5,R0
        B.N      ??AF_DataRequest_23
//  744       }
//  745       else
//  746       {
//  747         stat = afStatus_INVALID_PARAMETER;
??AF_DataRequest_22:
        MOVS     R5,#+2
        B.N      ??AF_DataRequest_23
//  748       }
//  749     }
//  750     else
//  751     {
//  752       stat = APSDE_DataReq( &req );
??AF_DataRequest_21:
        ADD      R0,SP,#+4
        BL       APSDE_DataReq
        MOVS     R5,R0
//  753     }
//  754   }
//  755 
//  756   /*
//  757    * If this is an EndPoint-to-EndPoint message on the same device, it will not
//  758    * get added to the NWK databufs. So it will not go OTA and it will not get
//  759    * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
//  760    * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
//  761    * message with the first in line TransSeqNumber, even on a multi message.
//  762    * Also note that a reflected msg will not have its confirmation generated
//  763    * here.
//  764    */
//  765   if ( (req.dstAddr.addrMode == Addr16Bit) &&
//  766        (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
??AF_DataRequest_23:
        LDRB     R0,[SP, #+12]
        CMP      R0,#+2
        BNE.N    ??AF_DataRequest_24
        BL       NLME_GetShortAddr
        LDRH     R1,[SP, #+4]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R1,R0
        BNE.N    ??AF_DataRequest_24
//  767   {
//  768     afDataConfirm( srcEP->endPoint, *transID, stat );
        MOVS     R2,R5
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R1,[R4, #+0]
        LDRB     R0,[R6, #+0]
        BL       afDataConfirm
//  769   }
//  770 
//  771   if ( stat == afStatus_SUCCESS )
??AF_DataRequest_24:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??AF_DataRequest_25
//  772   {
//  773     (*transID)++;
        LDRB     R0,[R4, #+0]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+0]
//  774   }
//  775 
//  776   return (afStatus_t)stat;
??AF_DataRequest_25:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??AF_DataRequest_1:
        ADD      SP,SP,#+40
        POP      {R4-R8,PC}       ;; return
//  777 }
//  778 
//  779 #if defined ( ZIGBEE_SOURCE_ROUTING )
//  780 /*********************************************************************
//  781  * @fn      AF_DataRequestSrcRtg
//  782  *
//  783  * @brief   Common functionality for invoking APSDE_DataReq() for both
//  784  *          SendMulti and MSG-Send.
//  785  *
//  786  * input parameters
//  787  *
//  788  * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
//  789  * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
//  790  * @param   cID - A valid cluster ID as specified by the Profile.
//  791  * @param   len - Number of bytes of data pointed to by next param.
//  792  * @param  *buf - A pointer to the data bytes to send.
//  793  * @param  *transID - A pointer to a byte which can be modified and which will
//  794  *                    be used as the transaction sequence number of the msg.
//  795  * @param   options - Valid bit mask of Tx options.
//  796  * @param   radius - Normally set to AF_DEFAULT_RADIUS.
//  797  * @param   relayCnt - Number of devices in the relay list
//  798  * @param   pRelayList - Pointer to the relay list
//  799  *
//  800  * output parameters
//  801  *
//  802  * @param  *transID - Incremented by one if the return value is success.
//  803  *
//  804  * @return  afStatus_t - See previous definition of afStatus_... types.
//  805  */
//  806 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  807 afStatus_t AF_DataRequestSrcRtg( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
//  808                            uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
//  809                            uint8 options, uint8 radius, uint8 relayCnt, uint16* pRelayList )
//  810 {
AF_DataRequestSrcRtg:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
        MOVS     R7,R3
//  811   uint8 status;
//  812 
//  813   /* Add the source route to the source routing table */
//  814   status = RTG_AddSrcRtgEntry_Guaranteed( dstAddr->addr.shortAddr, relayCnt,
//  815                                          pRelayList );
        LDR      R2,[SP, #+60]
        LDR      R1,[SP, #+56]
        LDRH     R0,[R4, #+0]
        BL       RTG_AddSrcRtgEntry_Guaranteed
//  816 
//  817   if( status == RTG_SUCCESS)
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??AF_DataRequestSrcRtg_0
//  818   {
//  819     /* Call AF_DataRequest to send the data */
//  820     status = AF_DataRequest( dstAddr, srcEP, cID, len, buf, transID, options, radius );
        LDR      R0,[SP, #+52]
        STR      R0,[SP, #+12]
        LDR      R0,[SP, #+48]
        STR      R0,[SP, #+8]
        LDR      R0,[SP, #+44]
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+40]
        STR      R0,[SP, #+0]
        MOVS     R3,R7
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        MOVS     R2,R6
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R1,R5
        MOVS     R0,R4
        BL       AF_DataRequest
        B.N      ??AF_DataRequestSrcRtg_1
//  821   }
//  822   else if( status == RTG_INVALID_PATH )
??AF_DataRequestSrcRtg_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??AF_DataRequestSrcRtg_2
//  823   {
//  824     /* The source route relay count is exceeding the network limit */
//  825     status = afStatus_INVALID_PARAMETER;
        MOVS     R0,#+2
        B.N      ??AF_DataRequestSrcRtg_1
//  826   }
//  827   else
//  828   {
//  829     /* The guaranteed adding entry fails due to memory failure */
//  830     status = afStatus_MEM_FAIL;
??AF_DataRequestSrcRtg_2:
        MOVS     R0,#+16
//  831   }
//  832   return status;
??AF_DataRequestSrcRtg_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADD      SP,SP,#+20
        POP      {R4-R7,PC}       ;; return
//  833 }
//  834 
//  835 #endif
//  836 
//  837 /*********************************************************************
//  838  * @fn      afFindEndPointDescList
//  839  *
//  840  * @brief   Find the endpoint description entry from the endpoint
//  841  *          number.
//  842  *
//  843  * @param   EndPoint - Application Endpoint to look for
//  844  *
//  845  * @return  the address to the endpoint/interface description entry
//  846  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  847 static epList_t *afFindEndPointDescList( uint8 EndPoint )
//  848 {
//  849   epList_t *epSearch;
//  850 
//  851   for (epSearch = epList; epSearch != NULL; epSearch = epSearch->nextDesc)
afFindEndPointDescList:
        LDR.N    R1,??DataTable7
        LDR      R1,[R1, #+0]
        B.N      ??afFindEndPointDescList_0
??afFindEndPointDescList_1:
        LDR      R1,[R1, #+0]
??afFindEndPointDescList_0:
        CMP      R1,#+0
        BEQ.N    ??afFindEndPointDescList_2
//  852   {
//  853     if (epSearch->epDesc->endPoint == EndPoint)
        LDR      R2,[R1, #+4]
        LDRB     R2,[R2, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R2,R0
        BNE.N    ??afFindEndPointDescList_1
//  854     {
//  855       break;
//  856     }
//  857   }
//  858 
//  859   return epSearch;
??afFindEndPointDescList_2:
        MOVS     R0,R1
        BX       LR               ;; return
//  860 }
//  861 
//  862 /*********************************************************************
//  863  * @fn      afFindEndPointDesc
//  864  *
//  865  * @brief   Find the endpoint description entry from the endpoint
//  866  *          number.
//  867  *
//  868  * @param   EndPoint - Application Endpoint to look for
//  869  *
//  870  * @return  the address to the endpoint/interface description entry
//  871  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  872 endPointDesc_t *afFindEndPointDesc( uint8 EndPoint )
//  873 {
afFindEndPointDesc:
        PUSH     {R7,LR}
//  874   epList_t *epSearch;
//  875 
//  876   // Look for the endpoint
//  877   epSearch = afFindEndPointDescList( EndPoint );
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
//  878 
//  879   if ( epSearch )
        CMP      R0,#+0
        BEQ.N    ??afFindEndPointDesc_0
//  880     return ( epSearch->epDesc );
        LDR      R0,[R0, #+4]
        B.N      ??afFindEndPointDesc_1
//  881   else
//  882     return ( (endPointDesc_t *)NULL );
??afFindEndPointDesc_0:
        MOVS     R0,#+0
??afFindEndPointDesc_1:
        POP      {R1,PC}          ;; return
//  883 }
//  884 
//  885 /*********************************************************************
//  886  * @fn      afFindSimpleDesc
//  887  *
//  888  * @brief   Find the Simple Descriptor from the endpoint number.
//  889  *
//  890  * @param   EP - Application Endpoint to look for.
//  891  *
//  892  * @return  Non-zero to indicate that the descriptor memory must be freed.
//  893  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  894 uint8 afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, uint8 EP )
//  895 {
afFindSimpleDesc:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  896   epList_t *epItem = afFindEndPointDescList( EP );
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
        MOVS     R2,R0
//  897   uint8 rtrn = FALSE;
        MOVS     R0,#+0
//  898 
//  899   if ( epItem )
        CMP      R2,#+0
        BEQ.N    ??afFindSimpleDesc_0
//  900   {
//  901     if ( epItem->pfnDescCB )
        LDR      R1,[R2, #+8]
        CMP      R1,#+0
        BEQ.N    ??afFindSimpleDesc_1
//  902     {
//  903       *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+1
        LDR      R2,[R2, #+8]
        BLX      R2
        STR      R0,[R4, #+0]
//  904       rtrn = TRUE;
        MOVS     R0,#+1
        B.N      ??afFindSimpleDesc_2
//  905     }
//  906     else
//  907     {
//  908       *ppDesc = epItem->epDesc->simpleDesc;
??afFindSimpleDesc_1:
        LDR      R1,[R2, #+4]
        LDR      R1,[R1, #+8]
        STR      R1,[R4, #+0]
        B.N      ??afFindSimpleDesc_2
//  909     }
//  910   }
//  911   else
//  912   {
//  913     *ppDesc = NULL;
??afFindSimpleDesc_0:
        MOVS     R1,#+0
        STR      R1,[R4, #+0]
//  914   }
//  915 
//  916   return rtrn;
??afFindSimpleDesc_2:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  917 }
//  918 
//  919 /*********************************************************************
//  920  * @fn      afGetDescCB
//  921  *
//  922  * @brief   Get the Descriptor callback function.
//  923  *
//  924  * @param   epDesc - pointer to the endpoint descriptor
//  925  *
//  926  * @return  function pointer or NULL
//  927  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  928 static pDescCB afGetDescCB( endPointDesc_t *epDesc )
//  929 {
//  930   epList_t *epSearch;
//  931 
//  932   // Start at the beginning
//  933   epSearch = epList;
afGetDescCB:
        LDR.N    R1,??DataTable7
        LDR      R1,[R1, #+0]
        B.N      ??afGetDescCB_0
//  934 
//  935   // Look through the list until the end
//  936   while ( epSearch )
//  937   {
//  938     // Is there a match?
//  939     if ( epSearch->epDesc == epDesc )
//  940     {
//  941       return ( epSearch->pfnDescCB );
//  942     }
//  943     else
//  944       epSearch = epSearch->nextDesc;  // Next entry
??afGetDescCB_1:
        LDR      R1,[R1, #+0]
??afGetDescCB_0:
        CMP      R1,#+0
        BEQ.N    ??afGetDescCB_2
        LDR      R2,[R1, #+4]
        CMP      R2,R0
        BNE.N    ??afGetDescCB_1
        LDR      R0,[R1, #+8]
        B.N      ??afGetDescCB_3
//  945   }
//  946 
//  947   return ( (pDescCB)NULL );
??afGetDescCB_2:
        MOVS     R0,#+0
??afGetDescCB_3:
        BX       LR               ;; return
//  948 }
//  949 
//  950 /*********************************************************************
//  951  * @fn      afDataReqMTU
//  952  *
//  953  * @brief   Get the Data Request MTU(Max Transport Unit).
//  954  *
//  955  * @param   fields - afDataReqMTU_t
//  956  *
//  957  * @return  uint8(MTU)
//  958  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  959 uint8 afDataReqMTU( afDataReqMTU_t* fields )
//  960 {
afDataReqMTU:
        PUSH     {R4,LR}
//  961   uint8 len;
//  962   uint8 hdr;
//  963 
//  964   if ( fields->kvp == TRUE )
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??afDataReqMTU_0
//  965   {
//  966     hdr = AF_HDR_KVP_MAX_LEN;
        MOVS     R4,#+8
        B.N      ??afDataReqMTU_1
//  967   }
//  968   else
//  969   {
//  970     hdr = AF_HDR_V1_1_MAX_LEN;
??afDataReqMTU_0:
        MOVS     R4,#+0
//  971   }
//  972 
//  973   len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
??afDataReqMTU_1:
        ADDS     R0,R0,#+1
        BL       APSDE_DataReqMTU
        SUBS     R0,R0,R4
//  974 
//  975   return len;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4,PC}          ;; return
//  976 }
//  977 
//  978 /*********************************************************************
//  979  * @fn      afGetMatch
//  980  *
//  981  * @brief   Set the allow response flag.
//  982  *
//  983  * @param   ep - Application Endpoint to look for
//  984  * @param   action - true - allow response, false - no response
//  985  *
//  986  * @return  TRUE allow responses, FALSE no response
//  987  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  988 uint8 afGetMatch( uint8 ep )
//  989 {
afGetMatch:
        PUSH     {R7,LR}
//  990   epList_t *epSearch;
//  991 
//  992   // Look for the endpoint
//  993   epSearch = afFindEndPointDescList( ep );
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
//  994 
//  995   if ( epSearch )
        CMP      R0,#+0
        BEQ.N    ??afGetMatch_0
//  996   {
//  997     if ( epSearch->flags & eEP_AllowMatch )
        LDRB     R0,[R0, #+14]
        LSLS     R0,R0,#+31
        BPL.N    ??afGetMatch_1
//  998       return ( TRUE );
        MOVS     R0,#+1
        B.N      ??afGetMatch_2
//  999     else
// 1000       return ( FALSE );
??afGetMatch_1:
        MOVS     R0,#+0
        B.N      ??afGetMatch_2
// 1001   }
// 1002   else
// 1003     return ( FALSE );
??afGetMatch_0:
        MOVS     R0,#+0
??afGetMatch_2:
        POP      {R1,PC}          ;; return
// 1004 }
// 1005 
// 1006 /*********************************************************************
// 1007  * @fn      afSetMatch
// 1008  *
// 1009  * @brief   Set the allow response flag.
// 1010  *
// 1011  * @param   ep - Application Endpoint to look for
// 1012  * @param   action - true - allow response, false - no response
// 1013  *
// 1014  * @return  TRUE if success, FALSE if endpoint not found
// 1015  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1016 uint8 afSetMatch( uint8 ep, uint8 action )
// 1017 {
afSetMatch:
        PUSH     {R4,LR}
        MOVS     R4,R1
// 1018   epList_t *epSearch;
// 1019 
// 1020   // Look for the endpoint
// 1021   epSearch = afFindEndPointDescList( ep );
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
// 1022 
// 1023   if ( epSearch )
        CMP      R0,#+0
        BEQ.N    ??afSetMatch_0
// 1024   {
// 1025     if ( action )
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??afSetMatch_1
// 1026     {
// 1027       epSearch->flags |= eEP_AllowMatch;
        LDRB     R1,[R0, #+14]
        ORRS     R1,R1,#0x1
        STRB     R1,[R0, #+14]
        B.N      ??afSetMatch_2
// 1028     }
// 1029     else
// 1030     {
// 1031       epSearch->flags &= (eEP_AllowMatch ^ 0xFFFF);
??afSetMatch_1:
        LDRB     R1,[R0, #+14]
        ANDS     R1,R1,#0xFE
        STRB     R1,[R0, #+14]
// 1032     }
// 1033     return ( TRUE );
??afSetMatch_2:
        MOVS     R0,#+1
        B.N      ??afSetMatch_3
// 1034   }
// 1035   else
// 1036     return ( FALSE );
??afSetMatch_0:
        MOVS     R0,#+0
??afSetMatch_3:
        POP      {R4,PC}          ;; return
// 1037 }
// 1038 
// 1039 /*********************************************************************
// 1040  * @fn      afNumEndPoints
// 1041  *
// 1042  * @brief   Returns the number of endpoints defined (including 0)
// 1043  *
// 1044  * @param   none
// 1045  *
// 1046  * @return  number of endpoints
// 1047  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1048 uint8 afNumEndPoints( void )
// 1049 {
// 1050   epList_t *epSearch;
// 1051   uint8 endpoints;
// 1052 
// 1053   // Start at the beginning
// 1054   epSearch = epList;
afNumEndPoints:
        LDR.N    R0,??DataTable7
        LDR      R1,[R0, #+0]
// 1055   endpoints = 0;
        MOVS     R0,#+0
        B.N      ??afNumEndPoints_0
// 1056 
// 1057   while ( epSearch )
// 1058   {
// 1059     endpoints++;
??afNumEndPoints_1:
        ADDS     R0,R0,#+1
// 1060     epSearch = epSearch->nextDesc;
        LDR      R1,[R1, #+0]
// 1061   }
??afNumEndPoints_0:
        CMP      R1,#+0
        BNE.N    ??afNumEndPoints_1
// 1062 
// 1063   return ( endpoints );
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
// 1064 }
// 1065 
// 1066 /*********************************************************************
// 1067  * @fn      afEndPoints
// 1068  *
// 1069  * @brief   Fills in the passed in buffer with the endpoint (numbers).
// 1070  *          Use afNumEndPoints to find out how big a buffer to supply.
// 1071  *
// 1072  * @param   epBuf - pointer to mem used
// 1073  *
// 1074  * @return  void
// 1075  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1076 void afEndPoints( uint8 *epBuf, uint8 skipZDO )
// 1077 {
// 1078   epList_t *epSearch;
// 1079   uint8 endPoint;
// 1080 
// 1081   // Start at the beginning
// 1082   epSearch = epList;
afEndPoints:
        LDR.N    R2,??DataTable7
        LDR      R2,[R2, #+0]
        B.N      ??afEndPoints_0
// 1083 
// 1084   while ( epSearch )
// 1085   {
// 1086     endPoint = epSearch->epDesc->endPoint;
??afEndPoints_1:
        LDR      R3,[R2, #+4]
        LDRB     R3,[R3, #+0]
// 1087 
// 1088     if ( !skipZDO || endPoint != 0 )
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??afEndPoints_2
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BEQ.N    ??afEndPoints_3
// 1089       *epBuf++ = endPoint;
??afEndPoints_2:
        STRB     R3,[R0, #+0]
        ADDS     R0,R0,#+1
// 1090 
// 1091     epSearch = epSearch->nextDesc;
??afEndPoints_3:
        LDR      R2,[R2, #+0]
// 1092   }
??afEndPoints_0:
        CMP      R2,#+0
        BNE.N    ??afEndPoints_1
// 1093 }
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7:
        DC32     epList

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_1:
        DC32     AF_DataRequestDiscoverRoute

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_2:
        DC32     apsfSendFragmented
// 1094 
// 1095 /*********************************************************************
// 1096  * @fn      afCopyAddress
// 1097  *
// 1098  * @brief   Fills in the passed in afAddrType_t parameter with the corresponding information
// 1099  *          from the zAddrType_t parameter.
// 1100  *
// 1101  * @param   epBuf - pointer to mem used
// 1102  *
// 1103  * @return  void
// 1104  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1105 void afCopyAddress( afAddrType_t *afAddr, zAddrType_t *zAddr )
// 1106 {
afCopyAddress:
        PUSH     {R4,LR}
        MOVS     R4,R0
// 1107   afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
        LDRB     R0,[R1, #+8]
        STRB     R0,[R4, #+8]
// 1108   if ( zAddr->addrMode == Addr64Bit )
        LDRB     R0,[R1, #+8]
        CMP      R0,#+3
        BNE.N    ??afCopyAddress_0
// 1109   {
// 1110     (void)osal_cpyExtAddr( afAddr->addr.extAddr, zAddr->addr.extAddr );
        MOVS     R0,R4
        BL       sAddrExtCpy
        B.N      ??afCopyAddress_1
// 1111   }
// 1112   else
// 1113   {
// 1114     afAddr->addr.shortAddr = zAddr->addr.shortAddr;
??afCopyAddress_0:
        LDRH     R0,[R1, #+0]
        STRH     R0,[R4, #+0]
// 1115   }
// 1116 
// 1117   // Since zAddrType_t has no INTER-PAN information, set the panId member to zero.
// 1118   afAddr->panId = 0;
??afCopyAddress_1:
        MOVS     R0,#+0
        STRH     R0,[R4, #+10]
// 1119 }
        POP      {R4,PC}          ;; return
// 1120 
// 1121 /**************************************************************************************************
// 1122  * @fn          afAPSF_ConfigGet
// 1123  *
// 1124  * @brief       This function ascertains the fragmentation configuration that corresponds to
// 1125  *              the specified EndPoint.
// 1126  *
// 1127  * input parameters
// 1128  *
// 1129  * @param       endPoint - The source EP of a Tx or destination EP of a Rx fragmented message.
// 1130  *
// 1131  * output parameters
// 1132  *
// 1133  * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
// 1134  *
// 1135  * @return      None.
// 1136  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1137 void afAPSF_ConfigGet(uint8 endPoint, afAPSF_Config_t *pCfg)
// 1138 {
afAPSF_ConfigGet:
        PUSH     {R4,LR}
        MOVS     R4,R1
// 1139   epList_t *pList = afFindEndPointDescList(endPoint);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
// 1140 
// 1141   if (pList == NULL)
        CMP      R0,#+0
        BNE.N    ??afAPSF_ConfigGet_0
// 1142   {
// 1143     pCfg->frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
        MOVS     R0,#+50
        STRB     R0,[R4, #+0]
// 1144     pCfg->windowSize = APSF_DEFAULT_WINDOW_SIZE;
        MOVS     R0,#+1
        STRB     R0,[R4, #+1]
        B.N      ??afAPSF_ConfigGet_1
// 1145   }
// 1146   else
// 1147   {
// 1148     (void)osal_memcpy(pCfg, &pList->apsfCfg, sizeof(afAPSF_Config_t));
??afAPSF_ConfigGet_0:
        MOVS     R2,#+2
        ADDS     R1,R0,#+12
        MOVS     R0,R4
        BL       osal_memcpy
// 1149   }
// 1150 }
??afAPSF_ConfigGet_1:
        POP      {R4,PC}          ;; return
// 1151 
// 1152 /**************************************************************************************************
// 1153  * @fn          afAPSF_ConfigSet
// 1154  *
// 1155  * @brief       This function attempts to set the fragmentation configuration that corresponds to
// 1156  *              the specified EndPoint.
// 1157  *
// 1158  * input parameters
// 1159  *
// 1160  * @param       endPoint - The specific EndPoint for which to set the fragmentation configuration.
// 1161  * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
// 1162  *
// 1163  * output parameters
// 1164  *
// 1165  * None.
// 1166  *
// 1167  * @return      afStatus_SUCCESS for success.
// 1168  *              afStatus_INVALID_PARAMETER if the specified EndPoint is not registered.
// 1169  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1170 afStatus_t afAPSF_ConfigSet(uint8 endPoint, afAPSF_Config_t *pCfg)
// 1171 {
afAPSF_ConfigSet:
        PUSH     {R4,LR}
        MOVS     R4,R1
// 1172   epList_t *pList = afFindEndPointDescList(endPoint);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
// 1173 
// 1174   if (pList == NULL)
        CMP      R0,#+0
        BNE.N    ??afAPSF_ConfigSet_0
// 1175   {
// 1176     return afStatus_INVALID_PARAMETER;
        MOVS     R0,#+2
        B.N      ??afAPSF_ConfigSet_1
// 1177   }
// 1178 
// 1179   (void)osal_memcpy(&pList->apsfCfg, pCfg, sizeof(afAPSF_Config_t));
??afAPSF_ConfigSet_0:
        MOVS     R2,#+2
        MOVS     R1,R4
        ADDS     R0,R0,#+12
        BL       osal_memcpy
// 1180   return afStatus_SUCCESS;
        MOVS     R0,#+0
??afAPSF_ConfigSet_1:
        POP      {R4,PC}          ;; return
// 1181 }
// 1182 
// 1183 /**************************************************************************************************
// 1184  * @fn          afSetApplCB
// 1185  *
// 1186  * @brief       Sets the pointer to the Application Callback function for a
// 1187  *              specific EndPoint.
// 1188  *
// 1189  * input parameters
// 1190  *
// 1191  * @param       endPoint - The specific EndPoint for which to set Application Callback.
// 1192  * @param       pApplFn - A pointer to the Application Callback function.
// 1193  *
// 1194  * output parameters
// 1195  *
// 1196  * None.
// 1197  *
// 1198  * @return      TRUE if success, FALSE if endpoint not found
// 1199  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1200 uint8 afSetApplCB( uint8 endPoint, pApplCB pApplFn )
// 1201 {
afSetApplCB:
        PUSH     {R4,LR}
        MOVS     R4,R1
// 1202   if ( pApplFn != NULL )
        MOVS     R1,R4
        CMP      R1,#+0
        BEQ.N    ??afSetApplCB_0
// 1203   {
// 1204     epList_t *epSearch;
// 1205 
// 1206     // Look for the endpoint
// 1207     epSearch = afFindEndPointDescList( endPoint );
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       afFindEndPointDescList
// 1208 
// 1209     if ( epSearch )
        CMP      R0,#+0
        BEQ.N    ??afSetApplCB_0
// 1210     {
// 1211       epSearch->pfnApplCB = pApplFn;
        STR      R4,[R0, #+16]
// 1212 
// 1213       return ( TRUE );
        MOVS     R0,#+1
        B.N      ??afSetApplCB_1
// 1214     }
// 1215   }
// 1216 
// 1217   return ( FALSE );
??afSetApplCB_0:
        MOVS     R0,#+0
??afSetApplCB_1:
        POP      {R4,PC}          ;; return
// 1218 }

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 1219 
// 1220 /**************************************************************************************************
// 1221 */
// 
//     4 bytes in section .bss
//     1 byte  in section .data
// 1 862 bytes in section .text
// 
// 1 862 bytes of CODE memory
//     5 bytes of DATA memory
//
//Errors: none
//Warnings: none
