///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM       12/Apr/2015  15:43:35
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WatchHW.c
//    Command line =  
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WatchHW.c -D
//        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
//        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
//        LCD_SUPPORTED=YES -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1
//        --preprocess=cl
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
//        --diag_suppress Pa082 -o
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
//        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
//        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
//        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\"
//        -I "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
//        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
//    List file    =  
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\WatchHW.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN GPIOPinTypeGPIOInput
        EXTERN GPIOPinTypeGPIOOutput
        EXTERN GPIOPinWrite
        EXTERN HalUARTInit
        EXTERN Hal_KeyIntEnable
        EXTERN Hal_TaskID
        EXTERN IntAltMapEnable
        EXTERN SysCtrlClockStartSetting
        EXTERN SysCtrlDeepSleepSetting
        EXTERN SysCtrlRunSetting
        EXTERN SysCtrlSleepSetting
        EXTERN SysCtrlWakeupSetting
        EXTERN bspKeyInit
        EXTERN macMcuRandomWord
        EXTERN osal_int_disable
        EXTERN osal_msg_send
        EXTERN osal_set_event

        PUBLIC BigLight_Off
        PUBLIC BigLight_On
        PUBLIC BuzzerControl
        PUBLIC Dimmer
        PUBLIC GetUserDipSw
        PUBLIC InitWatch
        PUBLIC OnBoard_KeyCallback
        PUBLIC OnBoard_SendKeys
        PUBLIC OnboardKeyIntEnable
        PUBLIC Onboard_rand
        PUBLIC RegisterForKeys
        PUBLIC _itoa
        PUBLIC aExtendedAddress

// C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\WatchHW.c
//    1 /*
//    2  *     program:  WatchHW.c
//    3  *      Project: Zigbee Watch
//    4  *     Version:  0.0.1 -- phase 1
//    5  *   Copyright:  2014, Barron Associates
//    6  *     Written:  Wednesday, March 18, 2015
//    7  *      Author:  Tim Trudeau - Timware
//    8  *   Processor:  TI CC2538
//    9  *        Tool:  IAR Embedded Workbench
//   10  *
//   11  *-------------------------------------------------------------------
//   12  *
//   13  *******************************************************************/
//   14 
//   15 
//   16 /* ------------------------------------------------------------------------------------------------
//   17  *                                          Includes
//   18  * ------------------------------------------------------------------------------------------------
//   19  */
//   20 #include "ZComDef.h"
//   21 #include "Hal_drivers.h" 
//   22 #include "hal_key.h" 
//   23 #include "OSAL.h"
//   24 #include "WatchApp.h"
//   25 #include "MT.h"
//   26 #include "MT_SYS.h"
//   27 #include "DebugTrace.h"
//   28 #include "mac_api.h"
//   29 
//   30 /* Hal */
//   31 //#include "hal_lcd.h"
//   32 #include "hal_mcu.h"
//   33 //#if (defined OTA_CLIENT) && (OTA_CLIENT == TRUE)
//   34 //#include "hal_ota.h"
//   35 //#endif
//   36 #include "hal_timer.h"
//   37 //#include "hal_key.h"
//   38 //#include "hal_led.h"
//   39 
//   40 /* Allow access macRandomByte() */
//   41 #include "mac_radio_defs.h"
//   42 
//   43 /* ------------------------------------------------------------------------------------------------
//   44  *                                           Constants
//   45  * ------------------------------------------------------------------------------------------------
//   46  */
//   47 // Task ID not initialized
//   48 #define NO_TASK_ID 0xFF
//   49 
//   50 // Minimum length RAM "pattern" for Stack check
//   51 #define MIN_RAM_INIT 12
//   52 
//   53 
//   54 /* ------------------------------------------------------------------------------------------------
//   55  *                                           Global Variables
//   56  * ------------------------------------------------------------------------------------------------
//   57  */
//   58 
//   59 extern void HalUARTInit(void);
//   60 void OnBoard_KeyCallback ( uint8 keys, uint8 state );
//   61 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   62 uint8 OnboardKeyIntEnable;
OnboardKeyIntEnable:
        DS8 1
//   63 // Registered keys task ID, initialized to NOT USED.

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//   64 static uint8 registeredKeysTaskID = NO_TASK_ID;
registeredKeysTaskID:
        DATA
        DC8 255
//   65 
//   66 // 64-bit Extended Address of this device

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   67 uint8 aExtendedAddress[8];
aExtendedAddress:
        DS8 8
//   68 
//   69 #if defined ZCL_KEY_ESTABLISH
//   70 #include "ZGlobals.h"
//   71 // Only include certificate data if we are building an initial OTA capable image
//   72 // or an image not designed to be transferred via OTA or SBL.
//   73 #if ( ((!defined OTA_CLIENT) && (!defined SBL_CLIENT)) || (defined OTA_INITIAL_IMAGE))
//   74 #include "zcl_cert_data.c"
//   75 #endif
//   76 #endif
//   77 
//   78 //Used for handling button
//   79 static uint8 halSavedKeys;
//   80 static uint8 halIntKeys;

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   81 static halKeyCBack_t pHal_KeyProcessFunction;
pHal_KeyProcessFunction:
        DS8 4
//   82 
//   83 /******************************************************************************
//   84  * LOCAL FUNCTIONS
//   85  */
//   86 
//   87 
//   88 // TODO These functions are left here as templates for whatever watch tasks are defined.
//   89 /* TODO Determine if any of this is needed and what should be done to ready the watch */
//   90 /**************************************************************************************************
//   91  * @fn       InitWatch
//   92  *
//   93  * @brief    Initialize the Watch CC22538 Peripherals like IO. The Hal is set
//   94              to do polling of the button and make the callback.
//   95  *
//   96  * input parameters
//   97  *
//   98  * @param   none
//   99  *
//  100  * output parameters
//  101  *
//  102  * @param    None    
//  103  *
//  104  * @return  void
//  105  **************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  106 void InitWatch( void)
//  107 {
InitWatch:
        PUSH     {R7,LR}
//  108    // Interrupts off
//  109     osal_int_disable( INTS_ALL );
        MOVS     R0,#+255
        BL       osal_int_disable
//  110       /* Initialize NVIC Vector Table offset register */                     
//  111     /* Initialize NVIC Vector Table offset register */                     
//  112     HWREG(NVIC_VTABLE) = HAL_NVIC_ADDR;                                    
        MOVS     R0,#+2097152
        LDR.N    R1,??DataTable2  ;; 0xe000ed08
        STR      R0,[R1, #+0]
//  113                                                                            
//  114     /* Setup the System Clocks */                                          
//  115     SysCtrlClockStartSetting();                                            
        BL       SysCtrlClockStartSetting
//  116                                                                            
//  117     /* Check if clock is stable */                                         
//  118     HAL_CLOCK_STABLE();                                                    
??InitWatch_0:
        LDR.N    R0,??DataTable2_1  ;; 0x400d2004
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+12
        BPL.N    ??InitWatch_0
//  119                                                                            
//  120     /* Turn on cache prefetch mode */                                      
//  121     PREFETCH_ENABLE();                                                     
        MOVS     R0,#+8
        LDR.N    R1,??DataTable2_2  ;; 0x400d3008
        STR      R0,[R1, #+0]
//  122                                                                            
//  123     /* Enable Alternate Interrupt Map */                                   
//  124     IntAltMapEnable();                                                     
        BL       IntAltMapEnable
//  125                                                                            
//  126     /* Setup Deep Sleep settings for peripherals */                        
//  127     SysCtrlDeepSleepSetting();                                             
        BL       SysCtrlDeepSleepSetting
//  128     /* Setup Sleep settings for peripherals */                             
//  129     SysCtrlSleepSetting();                                                 
        BL       SysCtrlSleepSetting
//  130     /* Setup Run settings for peripherals */                               
//  131     SysCtrlRunSetting();                                                   
        BL       SysCtrlRunSetting
//  132     /* Setup which peripherals can wake the system from sleep */           
//  133     SysCtrlWakeupSetting();                                                
        BL       SysCtrlWakeupSetting
//  134                                                                            
//  135     /* Configure the leds as outputs */                                    
//  136     GPIOPinTypeGPIOOutput(BSP_LED_BASE, BSP_LED_1);                        
        MOVS     R1,#+1
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinTypeGPIOOutput
//  137     GPIOPinTypeGPIOOutput(BSP_LED_BASE, BSP_LED_2);                        
        MOVS     R1,#+2
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinTypeGPIOOutput
//  138     GPIOPinTypeGPIOOutput(BSP_LED_BASE, BSP_LED_3);                        
        MOVS     R1,#+4
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinTypeGPIOOutput
//  139     GPIOPinTypeGPIOOutput(BSP_LED_BASE, BSP_LED_4);                        
        MOVS     R1,#+8
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinTypeGPIOOutput
//  140                                                                            
//  141     /* reset does not affect GPIO state */                                 
//  142     HAL_TURN_OFF_LED1();                                                   
        MOVS     R2,#+0
        MOVS     R1,#+1
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinWrite
//  143     HAL_TURN_OFF_LED2();                                                   
        MOVS     R2,#+0
        MOVS     R1,#+2
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinWrite
//  144     HAL_TURN_OFF_LED3();                                                   
        MOVS     R2,#+0
        MOVS     R1,#+4
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinWrite
//  145     HAL_TURN_OFF_LED4();                                                   
        MOVS     R2,#+0
        MOVS     R1,#+8
        LDR.N    R0,??DataTable2_3  ;; 0x400db000
        BL       GPIOPinWrite
//  146                                                                            
//  147     GPIOPinTypeGPIOOutput(BSP_LCD_PWR_BASE, BSP_LCD_PWR);  /* PWR output */
        MOVS     R1,#+16
        LDR.N    R0,??DataTable2_4  ;; 0x400da000
        BL       GPIOPinTypeGPIOOutput
//  148     GPIOPinWrite(BSP_LCD_PWR_BASE, BSP_LCD_PWR, 0);        /* low */       
        MOVS     R2,#+0
        MOVS     R1,#+16
        LDR.N    R0,??DataTable2_4  ;; 0x400da000
        BL       GPIOPinWrite
//  149     GPIOPinTypeGPIOInput(BSP_LCD_CS_BASE, BSP_LCD_CS); /*CSn input no drive*/
        MOVS     R1,#+32
        LDR.N    R0,??DataTable2_4  ;; 0x400da000
        BL       GPIOPinTypeGPIOInput
//  150                                                                            
//  151     HAL_BOARD_RF_FRONTEND_SETUP();                                         
//  152 
//  153     HalUARTInit();
        BL       HalUARTInit
//  154     /* Initialize Key stuff */
//  155     bspKeyInit(BSP_KEY_MODE_POLL);
        MOVS     R0,#+0
        BL       bspKeyInit
//  156     
//  157     /* Start polling if callback function is setup*/
//  158     osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
        MOVS     R1,#+16
        LDR.N    R0,??DataTable2_5
        LDRB     R0,[R0, #+0]
        BL       osal_set_event
//  159 }
        POP      {R0,PC}          ;; return
//  160 
//  161 /******************************************************************************
//  162  * Button Register function
//  163  *
//  164  * The Button handler is setup to send all keyboard changes to
//  165  * one task (if a task is registered). 
//  166  *
//  167  * If a task registers, it will get all button events. 
//  168  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  169 uint8 RegisterForKeys( uint8 task_id )
//  170 {
RegisterForKeys:
        PUSH     {R7,LR}
//  171   // Allow only the one task is registed since watch has only one button 
//  172   if ( registeredKeysTaskID == NO_TASK_ID )
        LDR.N    R1,??DataTable2_6
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BNE.N    ??RegisterForKeys_0
//  173   {
//  174     registeredKeysTaskID = task_id;
        LDR.N    R1,??DataTable2_6
        STRB     R0,[R1, #+0]
//  175     Hal_KeyIntEnable = FALSE;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable2_7
        STRB     R0,[R1, #+0]
//  176     bspKeyInit(BSP_KEY_MODE_POLL); 
        MOVS     R0,#+0
        BL       bspKeyInit
//  177    
//  178     if( OnBoard_KeyCallback != NULL)  // OnBoard_KeyCallback is a pointer to function
        ADR.W    R0,OnBoard_KeyCallback
        CMP      R0,#+0
        BEQ.N    ??RegisterForKeys_1
//  179     {
//  180       /* Register the callback fucntion */
//  181       pHal_KeyProcessFunction = OnBoard_KeyCallback;  
        ADR.W    R0,OnBoard_KeyCallback
        LDR.N    R1,??DataTable2_8
        STR      R0,[R1, #+0]
//  182       /* Start polling if callback function is setup*/
//  183       osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
        MOVS     R1,#+16
        LDR.N    R0,??DataTable2_5
        LDRB     R0,[R0, #+0]
        BL       osal_set_event
//  184     }
//  185     return ( true );
??RegisterForKeys_1:
        MOVS     R0,#+1
        B.N      ??RegisterForKeys_2
//  186   }
//  187   else
//  188   {
//  189     return ( false );
??RegisterForKeys_0:
        MOVS     R0,#+0
??RegisterForKeys_2:
        POP      {R1,PC}          ;; return
//  190   }
//  191 }
//  192 
//  193 /******************************************************************************
//  194  * @fn      OnBoard_SendKeys
//  195  *
//  196  * @brief   Send "Button Pressed" message to application.
//  197  *
//  198  * @param   keys  - keys that were pressed
//  199  *          state - shifted
//  200  *
//  201  * @return  status
//  202  ******************************************************************************/
//  203 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  204 uint8 OnBoard_SendKeys( uint8 keys, uint8 state )
//  205 {
OnBoard_SendKeys:
        PUSH     {R1,LR}
        SUB      SP,SP,#+8
//  206   uint8 keystate = state;
        LDRB     R0,[SP, #+8]
        STRB     R0,[SP, #+0]
//  207   uint8 *msgPtr = &keystate;
        ADD      R1,SP,#+0
//  208 
//  209   if ( registeredKeysTaskID != NO_TASK_ID ) {
        LDR.N    R0,??DataTable2_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??OnBoard_SendKeys_0
//  210     // Send the address to the task
//  211     msgPtr = &state;
        ADD      R1,SP,#+8
//  212     osal_msg_send( registeredKeysTaskID, msgPtr );
        LDR.N    R0,??DataTable2_6
        LDRB     R0,[R0, #+0]
        BL       osal_msg_send
//  213     return ( ZSuccess );
        MOVS     R0,#+0
        B.N      ??OnBoard_SendKeys_1
//  214   } else {
//  215     return ( ZFailure );
??OnBoard_SendKeys_0:
        MOVS     R0,#+1
??OnBoard_SendKeys_1:
        POP      {R1-R3,PC}       ;; return
//  216   }
//  217 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2:
        DC32     0xe000ed08

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_1:
        DC32     0x400d2004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_2:
        DC32     0x400d3008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_3:
        DC32     0x400db000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_4:
        DC32     0x400da000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_5:
        DC32     Hal_TaskID

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_6:
        DC32     registeredKeysTaskID

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_7:
        DC32     Hal_KeyIntEnable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_8:
        DC32     pHal_KeyProcessFunction
//  218 
//  219 /******************************************************************************
//  220  * @fn      OnBoard_KeyCallback
//  221  *
//  222  * @brief   Callback service for keys
//  223  *
//  224  * @param   keys  - keys that were pressed
//  225  *          state - shifted
//  226  *
//  227  * @return  void
//  228  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  229 void OnBoard_KeyCallback ( uint8 keys, uint8 state )
//  230 {
OnBoard_KeyCallback:
        PUSH     {R7,LR}
//  231   (void)state;
//  232   uint8 shift = false;
        MOVS     R1,#+0
//  233 
//  234   if ( OnBoard_SendKeys( keys, shift ) != ZSuccess ) { //ZSuccess is active low
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       OnBoard_SendKeys
//  235     //Buttom message has been sent to coordinator. Now what?
//  236   }else{
//  237    //Message was not sent. Now What?
//  238   }
//  239 }
        POP      {R0,PC}          ;; return
//  240 
//  241 /******************************************************************************
//  242  * @fn      _itoa
//  243  *
//  244  * @brief   convert a 16bit number to ASCII
//  245  *
//  246  * @param   num -
//  247  *          buf -
//  248  *          radix -
//  249  *
//  250  * @return  void
//  251  *
//  252  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  253 void _itoa(uint16 num, uint8 *buf, uint8 radix)
//  254 {
_itoa:
        PUSH     {R2-R6}
//  255   char c,i;
//  256   uint8 *p, rst[5];
//  257 
//  258   p = rst;
        ADD      R5,SP,#+0
//  259   for ( i=0; i<5; i++,p++ )
        MOVS     R4,#+0
        B.N      ??_itoa_0
??_itoa_1:
        ADDS     R4,R4,#+1
        ADDS     R5,R5,#+1
??_itoa_0:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+5
        BGE.N    ??_itoa_2
//  260   {
//  261     c = num % radix;  // Isolate a digit
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SDIV     R3,R0,R2
        MLS      R3,R2,R3,R0
//  262     *p = c + (( c < 10 ) ? '0' : '7');  // Convert to Ascii
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+10
        BGE.N    ??_itoa_3
        MOVS     R6,#+48
        B.N      ??_itoa_4
??_itoa_3:
        MOVS     R6,#+55
??_itoa_4:
        ADDS     R3,R6,R3
        STRB     R3,[R5, #+0]
//  263     num /= radix;
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SDIV     R0,R0,R2
//  264     if ( !num )
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,#+0
        BNE.N    ??_itoa_1
//  265     {
//  266       break;
//  267     }
//  268   }
//  269 
//  270   for ( c=0 ; c<=i; c++ )
??_itoa_2:
        MOVS     R3,#+0
        B.N      ??_itoa_5
//  271   {
//  272     *buf++ = *p--;  // Reverse character order
??_itoa_6:
        LDRB     R0,[R5, #+0]
        STRB     R0,[R1, #+0]
        SUBS     R5,R5,#+1
        ADDS     R1,R1,#+1
//  273   }
        ADDS     R3,R3,#+1
??_itoa_5:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R4,R3
        BCS.N    ??_itoa_6
//  274 
//  275   *buf = '\0';
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
//  276 }
        POP      {R0,R1,R4-R6}
        BX       LR               ;; return
//  277 /******************************************************************************
//  278  * @fn        Onboard_rand
//  279  *
//  280  * @brief    Random number generator
//  281  *
//  282  * @param   none
//  283  *
//  284  * @return  uint16 - new random number
//  285  *
//  286  ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  287 uint16 Onboard_rand( void )
//  288 {
Onboard_rand:
        PUSH     {R7,LR}
//  289    return ( MAC_RADIO_RANDOM_WORD() );
        BL       macMcuRandomWord
        POP      {R1,PC}          ;; return
//  290 }
//  291 
//  292 /******************************************************************************
//  293  *                     DEV BOARD EXTERNAL I/O FUNCTIONS
//  294  *
//  295  * User defined functions to control external devices. Add your code
//  296  * to the following functions to control devices wired to DB outputs.
//  297  *
//  298  * NOTE - These functions MUST be left here as is if code is running on DEV board
//  299  ******************************************************************************/
//  300 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  301 void BigLight_On( void )
//  302 {
//  303   // Put code here to turn on an external light
//  304 }
BigLight_On:
        BX       LR               ;; return
//  305 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  306 void BigLight_Off( void )
//  307 {
//  308   // Put code here to turn off an external light
//  309 }
BigLight_Off:
        BX       LR               ;; return
//  310 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  311 void BuzzerControl( uint8 on )
//  312 {
//  313   // Put code here to turn a buzzer on/off
//  314   (void)on;
//  315 }
BuzzerControl:
        BX       LR               ;; return
//  316 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  317 void Dimmer( uint8 lvl )
//  318 {
//  319   // Put code here to control a dimmer
//  320   (void)lvl;
//  321 }
Dimmer:
        BX       LR               ;; return
//  322 
//  323 // No dip switches on this board

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  324 uint8 GetUserDipSw( void )
//  325 {
//  326   return 0;
GetUserDipSw:
        MOVS     R0,#+0
        BX       LR               ;; return
//  327 }

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  328 
//  329 /******************************************************************************
//  330  */
// 
//  13 bytes in section .bss
//   1 byte  in section .data
// 434 bytes in section .text
// 
// 434 bytes of CODE memory
//  14 bytes of DATA memory
//
//Errors: none
//Warnings: 4
