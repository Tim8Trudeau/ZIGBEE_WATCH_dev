###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        12/Apr/2015  15:43:27
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\mac_autopend.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\mac_autopend.c" -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=YES
#        -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1 --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\mac_autopend.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\mac_autopend.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\mac_autopend.c
      1          /**************************************************************************************************
      2            Filename:       mac_autopend.c
      3            Revised:        $Date: 2014-05-29 13:33:32 -0700 (Thu, 29 May 2014) $
      4            Revision:       $Revision: 38710 $
      5          
      6            Description:    This file implements the TIMAC Autopend feature.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* low-level */
     41          #include "mac_api.h"
     42          #include "mac_radio_defs.h"
     43          
     44          /* osal */
     45          #include "OSAL.h"
     46          #include "saddr.h"
     47          #include "ZComDef.h"
     48          
     49          #include "mac_autopend.h"
     50          
     51          /* ------------------------------------------------------------------------------------------------
     52           *                                           Defines
     53           * ------------------------------------------------------------------------------------------------
     54           */
     55          #define MAC_SRCMATCH_INVALID_INDEX           0xFF
     56          
     57          #define MAC_SRCMATCH_SHORT_ENTRY_SIZE        4
     58          #define MAC_SRCMATCH_EXT_ENTRY_SIZE          Z_EXTADDR_LEN
     59          
     60          #define MAC_SRCMATCH_SHORT_MAX_NUM_ENTRIES   24
     61          #define MAC_SRCMATCH_EXT_MAX_NUM_ENTRIES     12
     62          
     63          #define MAC_SRCMATCH_ENABLE_BITMAP_LEN       3
     64          
     65          #define EXT_ADDR_INDEX_SIZE                  2
     66          #define SHORT_ADDR_INDEX_SIZE                1
     67                    
     68          /* ------------------------------------------------------------------------------------------------
     69           *                                      Global Variables
     70           * ------------------------------------------------------------------------------------------------
     71           */

   \                                 In section .bss, align 1
     72          bool macSrcMatchIsEnabled = FALSE; 
   \                     macSrcMatchIsEnabled:
   \   00000000                      DS8 1
     73          
     74          /* ------------------------------------------------------------------------------------------------
     75           *                                         Local Variables
     76           * ------------------------------------------------------------------------------------------------
     77           */
     78          
     79          /* 
     80           The following local Varables are only set in MAC_SrcMatchEnable()  
     81           They are read only to the rest of the module.
     82           */

   \                                 In section .bss, align 1
     83          bool macSrcMatchIsAckAllPending = FALSE;
   \                     macSrcMatchIsAckAllPending:
   \   00000000                      DS8 1
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86           *                                         Local Functions
     87           * ------------------------------------------------------------------------------------------------
     88           */
     89          static uint8 macSrcMatchFindEmptyEntry( uint8 macSrcMatchAddrMode );
     90          static uint8 macSrcMatchCheckSrcAddr ( sAddr_t *addr, uint16 panID  );
     91          static void macSrcMatchSetPendEnBit( uint8 index, uint8 macSrcMatchAddrMode );
     92          static void macSrcMatchSetEnableBit( uint8 index, bool option, uint8 macSrcMatchAddrMode );
     93          static bool macSrcMatchCheckEnableBit( uint8 index, uint24 enable);
     94          static uint24 macSrcMatchGetShortAddrPendEnBit( void );
     95          static uint24 macSrcMatchGetExtAddrPendEnBit( void );
     96          static uint24 macSrcMatchGetShortAddrEnableBit( void );
     97          static uint24 macSrcMatchGetExtAddrEnableBit( void );
     98          
     99          /*********************************************************************
    100           * @fn          MAC_SrcMatchEnable
    101           *
    102           * @brief      Enabled AUTOPEND and source address matching. If number of source
    103           *             address table entries asked for is more than the hardware
    104           *             supports. It will allocate maximum number of entries and return 
    105           *             MAC_INVALID_PARAMETER. This function shall be not be called from 
    106           *             ISR. It is not thread safe.
    107           *
    108           * @param      None
    109           *
    110           * @return     None
    111           */

   \                                 In section .text, align 2, keep-with-next
    112          void MAC_SrcMatchEnable (void)
    113          {
    114            /* Turn on Frame Filter (TIMAC enables frame filter by default), TBD */
    115            MAC_RADIO_TURN_ON_RX_FRAME_FILTERING();
   \                     MAC_SrcMatchEnable: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable11  ;; 0x40088600
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x40088600
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0009      ORRS     R0,R0,#0x9
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable11  ;; 0x40088600
   \   00000016   0x6008             STR      R0,[R1, #+0]
    116            
    117            /* Turn on Auto ACK (TIMAC turn on Auto ACK by default), TBD */
    118            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x40088624
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable11_1  ;; 0x40088624
   \   00000026   0x6008             STR      R0,[R1, #+0]
    119            
    120            /* Turn on Autopend: set SRCMATCH.AUTOPEND and SRCMATCH.SRC_MATCH_EN */
    121            MAC_RADIO_TURN_ON_SRC_MATCH();
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x40088608
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable11_2  ;; 0x40088608
   \   00000036   0x6008             STR      R0,[R1, #+0]
    122           
    123            /* Set SRCMATCH.AUTOPEND */
    124            MAC_RADIO_TURN_ON_AUTOPEND();
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x40088608
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable11_2  ;; 0x40088608
   \   00000046   0x6008             STR      R0,[R1, #+0]
    125            
    126            /* AUTOPEND function requires that the received 
    127             * frame is a DATA REQUEST MAC command frame
    128             */
    129            MAC_RADIO_TURN_ON_AUTOPEND_DATAREQ_ONLY();
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x40088608
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable11_2  ;; 0x40088608
   \   00000056   0x6008             STR      R0,[R1, #+0]
    130            
    131            /* Configure all the globals */
    132            macSrcMatchIsEnabled = TRUE;           
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
    133          }
   \   00000060   0x4770             BX       LR               ;; return
    134          
    135          /*********************************************************************
    136           * @fn          MAC_SrcMatchAddEntry
    137           *
    138           * @brief       Add a short or extended address to source address table. This 
    139           *              function shall be not be called from ISR. It is not thread safe.
    140           *
    141           * @param       addr  - a pointer to sAddr_t which contains addrMode 
    142           *                      and a union of a short 16-bit MAC address or an extended 
    143           *                      64-bit MAC address to be added to the source address 
    144            *                     table. 
    145           * @param       panID - the device PAN ID. It is only used when the addr is 
    146           *                      using short address 
    147          
    148           * @return      MAC_SUCCESS or MAC_NO_RESOURCES (source address table full) 
    149           *              or MAC_DUPLICATED_ENTRY (the entry added is duplicated),
    150           *              or MAC_INVALID_PARAMETER if the input parameters are invalid.
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          uint8 MAC_SrcMatchAddEntry ( sAddr_t *addr, uint16 panID )
    153          {
   \                     MAC_SrcMatchAddEntry: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
    154            uint8 index;
    155            uint8 entry[MAC_SRCMATCH_SHORT_ENTRY_SIZE];
    156            
    157            /* Check if the input parameters are valid */
    158            if ( addr == NULL || (addr->addrMode !=  SADDR_MODE_SHORT && addr->addrMode !=  SADDR_MODE_EXT))
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD005             BEQ.N    ??MAC_SrcMatchAddEntry_0
   \   0000000C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD004             BEQ.N    ??MAC_SrcMatchAddEntry_1
   \   00000012   0x7A20             LDRB     R0,[R4, #+8]
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xD001             BEQ.N    ??MAC_SrcMatchAddEntry_1
    159            {
    160              return MAC_INVALID_PARAMETER;  
   \                     ??MAC_SrcMatchAddEntry_0: (+1)
   \   00000018   0x20E8             MOVS     R0,#+232
   \   0000001A   0xE049             B.N      ??MAC_SrcMatchAddEntry_2
    161            }
    162            
    163            /* Check if the entry already exists. Do not add duplicated entry */
    164            if ( macSrcMatchCheckSrcAddr( addr, panID ) != MAC_SRCMATCH_INVALID_INDEX )
   \                     ??MAC_SrcMatchAddEntry_1: (+1)
   \   0000001C   0x0031             MOVS     R1,R6
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       macSrcMatchCheckSrcAddr
   \   00000026   0x28FF             CMP      R0,#+255
   \   00000028   0xD001             BEQ.N    ??MAC_SrcMatchAddEntry_3
    165            {
    166              return MAC_DUPLICATED_ENTRY; 
   \   0000002A   0x201E             MOVS     R0,#+30
   \   0000002C   0xE040             B.N      ??MAC_SrcMatchAddEntry_2
    167            }
    168            
    169            /* If not duplicated, write to the radio RAM and enable the control bit */
    170            
    171            /* Find the first empty entry */
    172            index = macSrcMatchFindEmptyEntry(addr->addrMode);
   \                     ??MAC_SrcMatchAddEntry_3: (+1)
   \   0000002E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000030   0x.... 0x....      BL       macSrcMatchFindEmptyEntry
   \   00000034   0x0005             MOVS     R5,R0
    173            
    174          
    175            if ( (index == MAC_SRCMATCH_SHORT_MAX_NUM_ENTRIES && addr->addrMode == SADDR_MODE_SHORT) || 
    176                 (index == MAC_SRCMATCH_EXT_MAX_NUM_ENTRIES && addr->addrMode == SADDR_MODE_EXT) )
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D18             CMP      R5,#+24
   \   0000003A   0xD102             BNE.N    ??MAC_SrcMatchAddEntry_4
   \   0000003C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xD005             BEQ.N    ??MAC_SrcMatchAddEntry_5
   \                     ??MAC_SrcMatchAddEntry_4: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D0C             CMP      R5,#+12
   \   00000046   0xD104             BNE.N    ??MAC_SrcMatchAddEntry_6
   \   00000048   0x7A20             LDRB     R0,[R4, #+8]
   \   0000004A   0x2803             CMP      R0,#+3
   \   0000004C   0xD101             BNE.N    ??MAC_SrcMatchAddEntry_6
    177            {
    178              return MAC_NO_RESOURCES;   /* Table is full */
   \                     ??MAC_SrcMatchAddEntry_5: (+1)
   \   0000004E   0x201A             MOVS     R0,#+26
   \   00000050   0xE02E             B.N      ??MAC_SrcMatchAddEntry_2
    179            }
    180            
    181            if ( addr->addrMode == SADDR_MODE_SHORT )
   \                     ??MAC_SrcMatchAddEntry_6: (+1)
   \   00000052   0x7A20             LDRB     R0,[R4, #+8]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD117             BNE.N    ??MAC_SrcMatchAddEntry_7
    182            {
    183              /* Write the PanID and short address */
    184              entry[0] = LO_UINT16( panID );  /* Little Endian for the radio RAM */
   \   00000058   0x0030             MOVS     R0,R6
   \   0000005A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    185              entry[1] = HI_UINT16( panID );
   \   0000005E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000060   0x0A30             LSRS     R0,R6,#+8
   \   00000062   0xF88D 0x0001      STRB     R0,[SP, #+1]
    186              entry[2] = LO_UINT16( addr->addr.shortAddr );
   \   00000066   0x8820             LDRH     R0,[R4, #+0]
   \   00000068   0xF88D 0x0002      STRB     R0,[SP, #+2]
    187              entry[3] = HI_UINT16( addr->addr.shortAddr );
   \   0000006C   0x8820             LDRH     R0,[R4, #+0]
   \   0000006E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000070   0x0A00             LSRS     R0,R0,#+8
   \   00000072   0xF88D 0x0003      STRB     R0,[SP, #+3]
    188              MAC_RADIO_SRC_MATCH_TABLE_WRITE( ( index * MAC_SRCMATCH_SHORT_ENTRY_SIZE ), 
    189                             entry, MAC_SRCMATCH_SHORT_ENTRY_SIZE );
   \   00000076   0x2204             MOVS     R2,#+4
   \   00000078   0xA900             ADD      R1,SP,#+0
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x....             LDR.N    R0,??DataTable11_4  ;; 0x40088400
   \   0000007E   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   00000082   0x.... 0x....      BL       macMemWriteRam
   \   00000086   0xE007             B.N      ??MAC_SrcMatchAddEntry_8
    190            }
    191            else
    192            {
    193              /* Write the extended address */
    194              MAC_RADIO_SRC_MATCH_TABLE_WRITE( ( index * MAC_SRCMATCH_EXT_ENTRY_SIZE ), 
    195                             addr->addr.extAddr, MAC_SRCMATCH_EXT_ENTRY_SIZE ); 
   \                     ??MAC_SrcMatchAddEntry_7: (+1)
   \   00000088   0x2208             MOVS     R2,#+8
   \   0000008A   0x0021             MOVS     R1,R4
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0x....             LDR.N    R0,??DataTable11_4  ;; 0x40088400
   \   00000090   0xEB10 0x1045      ADDS     R0,R0,R5, LSL #+5
   \   00000094   0x.... 0x....      BL       macMemWriteRam
    196            }
    197            
    198            /* Set the Autopend enable bits */
    199            macSrcMatchSetPendEnBit( index, addr->addrMode );
   \                     ??MAC_SrcMatchAddEntry_8: (+1)
   \   00000098   0x7A21             LDRB     R1,[R4, #+8]
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x.... 0x....      BL       macSrcMatchSetPendEnBit
    200            
    201            /* Set the Src Match enable bits */
    202            macSrcMatchSetEnableBit( index, TRUE, addr->addrMode);
   \   000000A2   0x7A22             LDRB     R2,[R4, #+8]
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x.... 0x....      BL       macSrcMatchSetEnableBit
    203            
    204            return MAC_SUCCESS;
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??MAC_SrcMatchAddEntry_2: (+1)
   \   000000B0   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    205          }
    206          
    207          /*********************************************************************
    208           * @fn         MAC_SrcMatchDeleteEntry
    209           *
    210           * @brief      Delete a short or extended address from source address table. 
    211           *             This function shall be not be called from ISR. It is not thread 
    212           *             safe.
    213           *
    214           * @param      addr  - a pointer to sAddr_t which contains addrMode 
    215           *                     and a union of a short 16-bit MAC address or an extended 
    216           *                     64-bit MAC address to be deleted from the source address 
    217                                 table. 
    218           * @param      panID - the device PAN ID. It is only used when the addr is 
    219           *                     using short address  
    220           *
    221           * @return     MAC_SUCCESS or MAC_INVALID_PARAMETER (address to be deleted 
    222           *                  cannot be found in the source address table).
    223           */

   \                                 In section .text, align 2, keep-with-next
    224          uint8 MAC_SrcMatchDeleteEntry ( sAddr_t *addr, uint16 panID  )
    225          {
   \                     MAC_SrcMatchDeleteEntry: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            uint8 index;
    227            
    228            if ( addr == NULL || (addr->addrMode !=  SADDR_MODE_SHORT && addr->addrMode !=  SADDR_MODE_EXT))
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ.N    ??MAC_SrcMatchDeleteEntry_0
   \   00000008   0x7A20             LDRB     R0,[R4, #+8]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD004             BEQ.N    ??MAC_SrcMatchDeleteEntry_1
   \   0000000E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD001             BEQ.N    ??MAC_SrcMatchDeleteEntry_1
    229            {
    230              return MAC_INVALID_PARAMETER;  
   \                     ??MAC_SrcMatchDeleteEntry_0: (+1)
   \   00000014   0x20E8             MOVS     R0,#+232
   \   00000016   0xE00E             B.N      ??MAC_SrcMatchDeleteEntry_2
    231            }
    232            
    233            /* Look up the source address table and find the entry. */
    234            index = macSrcMatchCheckSrcAddr( addr, panID );
   \                     ??MAC_SrcMatchDeleteEntry_1: (+1)
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       macSrcMatchCheckSrcAddr
    235          
    236            if( index == MAC_SRCMATCH_INVALID_INDEX )
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xD101             BNE.N    ??MAC_SrcMatchDeleteEntry_3
    237            {
    238              return MAC_INVALID_PARAMETER; 
   \   00000026   0x20E8             MOVS     R0,#+232
   \   00000028   0xE005             B.N      ??MAC_SrcMatchDeleteEntry_2
    239            }
    240            
    241            /* Clear Src Match enable bits */
    242            macSrcMatchSetEnableBit( index, FALSE, addr->addrMode);
   \                     ??MAC_SrcMatchDeleteEntry_3: (+1)
   \   0000002A   0x7A22             LDRB     R2,[R4, #+8]
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x.... 0x....      BL       macSrcMatchSetEnableBit
    243          
    244            return MAC_SUCCESS;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??MAC_SrcMatchDeleteEntry_2: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    245          }
    246                            
    247          /*********************************************************************
    248           * @fn          MAC_SrcMatchAckAllPending
    249           *
    250           * @brief       Enabled/disable acknowledging all packets with pending bit set
    251           *              The application normally enables it when adding new entries to 
    252           *              the source address table fails due to the table is full, or 
    253           *              disables it when more entries are deleted and the table has
    254           *              empty slots.
    255           *
    256           * @param       option - TRUE (acknowledging all packets with pending field set)
    257           *                       FALSE (address filtering and FSM control sets 
    258          *                               the pending field) 
    259           *
    260           * @return      none
    261           */

   \                                 In section .text, align 2, keep-with-next
    262          void MAC_SrcMatchAckAllPending ( uint8 option  ) 
    263          {
    264            if( option == TRUE )
   \                     MAC_SrcMatchAckAllPending: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD109             BNE.N    ??MAC_SrcMatchAckAllPending_0
    265            {
    266              macSrcMatchIsAckAllPending = TRUE;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable11_5
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    267              
    268              /* Set the PENDING_OR register */
    269              MAC_RADIO_TURN_ON_PENDING_OR();
   \   0000000C   0x....             LDR.N    R0,??DataTable11_6  ;; 0x40088628
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000014   0x....             LDR.N    R1,??DataTable11_6  ;; 0x40088628
   \   00000016   0x6008             STR      R0,[R1, #+0]
   \   00000018   0xE008             B.N      ??MAC_SrcMatchAckAllPending_1
    270            }
    271            else
    272            {
    273              macSrcMatchIsAckAllPending = FALSE;
   \                     ??MAC_SrcMatchAckAllPending_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable11_5
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    274              
    275              /* Clear the PENDING_OR register */
    276              MAC_RADIO_TURN_OFF_PENDING_OR();
   \   00000020   0x....             LDR.N    R0,??DataTable11_6  ;; 0x40088628
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000028   0x....             LDR.N    R1,??DataTable11_6  ;; 0x40088628
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    277            }
    278          }
   \                     ??MAC_SrcMatchAckAllPending_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    279          
    280          /*********************************************************************
    281           * @fn          MAC_SrcMatchCheckAllPending
    282           *
    283           * @brief       Check if acknowledging all packets with pending bit set
    284           *              is enabled. 
    285           *
    286           * @param       none 
    287           *
    288           * @return      MAC_AUTOACK_PENDING_ALL_ON or MAC_AUTOACK_PENDING_ALL_OFF
    289           */

   \                                 In section .text, align 2, keep-with-next
    290          uint8 MAC_SrcMatchCheckAllPending ( void )
    291          {
    292            if( macSrcMatchIsAckAllPending == TRUE )
   \                     MAC_SrcMatchCheckAllPending: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??MAC_SrcMatchCheckAllPending_0
    293            {
    294              return MAC_AUTOACK_PENDING_ALL_ON; 
   \   00000008   0x20FE             MOVS     R0,#+254
   \   0000000A   0xE000             B.N      ??MAC_SrcMatchCheckAllPending_1
    295            }
    296            
    297            return MAC_AUTOACK_PENDING_ALL_OFF;
   \                     ??MAC_SrcMatchCheckAllPending_0: (+1)
   \   0000000C   0x20FF             MOVS     R0,#+255
   \                     ??MAC_SrcMatchCheckAllPending_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    298          }
    299          
    300          /*********************************************************************
    301           * @fn          MAC_SrcMatchCheckResult
    302           *
    303           * @brief       Check the result of source matching
    304           *
    305           * @param       none
    306           *
    307           * @return      TRUE or FALSE
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          MAC_INTERNAL_API bool MAC_SrcMatchCheckResult( void )
    310          {
    311            uint8 resIndex;
    312            
    313            if ( macSrcMatchIsAckAllPending )
   \                     MAC_SrcMatchCheckResult: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??MAC_SrcMatchCheckResult_0
    314            {
    315              return (TRUE);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE005             B.N      ??MAC_SrcMatchCheckResult_1
    316            }
    317            
    318            MAC_RADIO_SRC_MATCH_RESINDEX( resIndex );
   \                     ??MAC_SrcMatchCheckResult_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable11_7  ;; 0x4008858c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
    319            
    320            return ( resIndex & AUTOPEND_RES );
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x0980             LSRS     R0,R0,#+6
   \   00000014   0xF010 0x0001      ANDS     R0,R0,#0x1
   \                     ??MAC_SrcMatchCheckResult_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /*********************************************************************
    324           * @fn          macSrcMatchFindEmptyEntry
    325           *
    326           * @brief       return index of the first empty entry found
    327           *
    328           * @param       macSrcMatchAddrMode - Address Mode for the entry. Valid values
    329           *              are SADDR_MODE_SHORT or SADDR_MODE_EXT
    330           *
    331           * @return      uint8 - return index of the first empty entry found
    332           */

   \                                 In section .text, align 2, keep-with-next
    333          static uint8 macSrcMatchFindEmptyEntry( uint8 macSrcMatchAddrMode )
    334          {
   \                     macSrcMatchFindEmptyEntry: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    335            uint8  index;
    336            uint24 shortAddrEnable = MAC_RADIO_SRC_MATCH_GET_SHORTADDR_EN();
   \   00000004   0x.... 0x....      BL       macSrcMatchGetShortAddrEnableBit
   \   00000008   0x0004             MOVS     R4,R0
    337            uint24 extAddrEnable = MAC_RADIO_SRC_MATCH_GET_EXTADDR_EN();
   \   0000000A   0x.... 0x....      BL       macSrcMatchGetExtAddrEnableBit
   \   0000000E   0x0001             MOVS     R1,R0
    338            uint24 enable = shortAddrEnable | extAddrEnable;
   \   00000010   0xEA51 0x0204      ORRS     R2,R1,R4
    339          
    340            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D02             CMP      R5,#+2
   \   00000018   0xD11B             BNE.N    ??macSrcMatchFindEmptyEntry_0
    341             {
    342               for( index = 0; index < MAC_SRCMATCH_SHORT_MAX_NUM_ENTRIES; index ++ )
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??macSrcMatchFindEmptyEntry_1
   \                     ??macSrcMatchFindEmptyEntry_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \                     ??macSrcMatchFindEmptyEntry_1: (+1)
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2818             CMP      R0,#+24
   \   00000024   0xDA23             BGE.N    ??macSrcMatchFindEmptyEntry_3
    343               {
    344                 /* Both 2n bit of extAddrEnable and
    345                  * corresponding bit of shortAddrEnable must be clear
    346                  * in order to assume that the entry location for a short address
    347                  * is not used.
    348                  */
    349                 if( (extAddrEnable & ((uint24)0x01 << ((index/2)*2))) == 0 &&
    350                     (shortAddrEnable & ((uint24)0x01 << index)) == 0 )
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x0052             LSLS     R2,R2,#+1
   \   00000032   0x000B             MOVS     R3,R1
   \   00000034   0x40D3             LSRS     R3,R3,R2
   \   00000036   0xF013 0x0201      ANDS     R2,R3,#0x1
   \   0000003A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003C   0x2A00             CMP      R2,#+0
   \   0000003E   0xD1EE             BNE.N    ??macSrcMatchFindEmptyEntry_2
   \   00000040   0x0022             MOVS     R2,R4
   \   00000042   0x40C2             LSRS     R2,R2,R0
   \   00000044   0xF012 0x0201      ANDS     R2,R2,#0x1
   \   00000048   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD1E7             BNE.N    ??macSrcMatchFindEmptyEntry_2
    351                 {
    352                   return index;
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0xE00E             B.N      ??macSrcMatchFindEmptyEntry_4
    353                 }
    354               }
    355             }
    356             else
    357             {
    358               for( index = 0; index < MAC_SRCMATCH_EXT_MAX_NUM_ENTRIES; index++ )
   \                     ??macSrcMatchFindEmptyEntry_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE000             B.N      ??macSrcMatchFindEmptyEntry_5
   \                     ??macSrcMatchFindEmptyEntry_6: (+1)
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \                     ??macSrcMatchFindEmptyEntry_5: (+1)
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x280C             CMP      R0,#+12
   \   0000005C   0xDA07             BGE.N    ??macSrcMatchFindEmptyEntry_3
    359               {
    360                 /* Both 2n bit of extAddrEnable and
    361                  * 2n bit and 2n+1 bit of shortAddrEnable must be clear in order
    362                  * to assume that the entry location for an extended address
    363                  * is not used.        
    364                  */
    365                 if( (enable & ((uint24)0x03 << (index*2))) == 0 )
   \   0000005E   0x2103             MOVS     R1,#+3
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x0043             LSLS     R3,R0,#+1
   \   00000064   0x4099             LSLS     R1,R1,R3
   \   00000066   0x420A             TST      R2,R1
   \   00000068   0xD1F5             BNE.N    ??macSrcMatchFindEmptyEntry_6
    366                 {
    367                   return index;
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xE000             B.N      ??macSrcMatchFindEmptyEntry_4
    368                 }
    369               }
    370             }
    371            return index;
   \                     ??macSrcMatchFindEmptyEntry_3: (+1)
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??macSrcMatchFindEmptyEntry_4: (+1)
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    372          }
    373          
    374          /*********************************************************************
    375           * @fn         macSrcMatchCheckSrcAddr
    376           *
    377           * @brief      Check if a short or extended address is in the source address 
    378           *             table.
    379           *             This function shall not be called from ISR. It is not thread 
    380           *             safe.
    381           *
    382           * @param      addr -  a pointer to sAddr_t which contains addrMode 
    383           *                     and a union of a short 16-bit MAC address or an extended 
    384           *                     64-bit MAC address to be checked in the source address 
    385           *                     table. 
    386           * @param      panID - the device PAN ID. It is only used when the addr is 
    387           *                     using short address 
    388          
    389           * @return     uint8 - index of the entry in the table. Return 
    390           *                     MAC_SRCMATCH_INVALID_INDEX (0xFF) if address not found.
    391           */

   \                                 In section .text, align 2, keep-with-next
    392          static uint8 macSrcMatchCheckSrcAddr ( sAddr_t *addr, uint16 panID  )
    393          {
   \                     macSrcMatchCheckSrcAddr: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    394            uint8 index;     
    395            uint8 *pAddr;
    396            uint8 entrySize;
    397            uint8 indexUsed;
    398            uint8 indexSize;
    399            uint8 entry[MAC_SRCMATCH_SHORT_ENTRY_SIZE];  
    400            uint8 ramEntry[MAC_SRCMATCH_EXT_ENTRY_SIZE];
    401            uint24 enable;
    402            
    403            /*
    404             Currently, shadow memory is not supported to optimize SPI traffic.
    405            */
    406            if( addr->addrMode ==  SADDR_MODE_SHORT )
   \   00000006   0x7A20             LDRB     R0,[R4, #+8]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD116             BNE.N    ??macSrcMatchCheckSrcAddr_0
    407            {
    408              entry[0] = LO_UINT16( panID );  /* Little Endian for the radio RAM */
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    409              entry[1] = HI_UINT16( panID );
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0x0A08             LSRS     R0,R1,#+8
   \   00000016   0xF88D 0x0001      STRB     R0,[SP, #+1]
    410              entry[2] = LO_UINT16( addr->addr.shortAddr );
   \   0000001A   0x8820             LDRH     R0,[R4, #+0]
   \   0000001C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    411              entry[3] = HI_UINT16( addr->addr.shortAddr );
   \   00000020   0x8820             LDRH     R0,[R4, #+0]
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x0A00             LSRS     R0,R0,#+8
   \   00000026   0xF88D 0x0003      STRB     R0,[SP, #+3]
    412              pAddr = entry;
   \   0000002A   0xAC00             ADD      R4,SP,#+0
    413              entrySize = MAC_SRCMATCH_SHORT_ENTRY_SIZE;
   \   0000002C   0x2604             MOVS     R6,#+4
    414              indexSize = 1;
   \   0000002E   0xF05F 0x0801      MOVS     R8,#+1
    415              enable = MAC_RADIO_SRC_MATCH_GET_SHORTADDR_EN();
   \   00000032   0x.... 0x....      BL       macSrcMatchGetShortAddrEnableBit
   \   00000036   0x4681             MOV      R9,R0
   \   00000038   0xE005             B.N      ??macSrcMatchCheckSrcAddr_1
    416            }
    417            else
    418            {
    419              pAddr = addr->addr.extAddr;
    420              entrySize = MAC_SRCMATCH_EXT_ENTRY_SIZE;
   \                     ??macSrcMatchCheckSrcAddr_0: (+1)
   \   0000003A   0x2608             MOVS     R6,#+8
    421              indexSize = 2;
   \   0000003C   0xF05F 0x0802      MOVS     R8,#+2
    422              enable = MAC_RADIO_SRC_MATCH_GET_EXTADDR_EN();
   \   00000040   0x.... 0x....      BL       macSrcMatchGetExtAddrEnableBit
   \   00000044   0x4681             MOV      R9,R0
    423            }
    424            
    425            for( index = 0; index < MAC_SRCMATCH_SHORT_MAX_NUM_ENTRIES; index += 
   \                     ??macSrcMatchCheckSrcAddr_1: (+1)
   \   00000046   0x2500             MOVS     R5,#+0
   \   00000048   0xE001             B.N      ??macSrcMatchCheckSrcAddr_2
    426                indexSize )
    427            {
    428              /* Check if the entry is enabled */
    429              if( macSrcMatchCheckEnableBit( index, enable ) == FALSE )
    430              {
    431                continue; 
   \                     ??macSrcMatchCheckSrcAddr_3: (+1)
   \                     ??macSrcMatchCheckSrcAddr_4: (+1)
   \   0000004A   0xEB18 0x0505      ADDS     R5,R8,R5
   \                     ??macSrcMatchCheckSrcAddr_2: (+1)
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D18             CMP      R5,#+24
   \   00000052   0xDA22             BGE.N    ??macSrcMatchCheckSrcAddr_5
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       macSrcMatchCheckEnableBit
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD0F3             BEQ.N    ??macSrcMatchCheckSrcAddr_3
    432              }
    433              
    434              indexUsed = index / indexSize;
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000068   0xFB95 0xF7F8      SDIV     R7,R5,R8
    435                
    436              /* Compare the short address or extended address */
    437              MAC_RADIO_SRC_MATCH_TABLE_READ( ( indexUsed * entrySize ), ramEntry, 
    438                                             entrySize );
   \   0000006C   0x0032             MOVS     R2,R6
   \   0000006E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000070   0xA901             ADD      R1,SP,#+4
   \   00000072   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0xFB06 0xF007      MUL      R0,R6,R7
   \   0000007A   0x....             LDR.N    R3,??DataTable11_4  ;; 0x40088400
   \   0000007C   0xEB13 0x0080      ADDS     R0,R3,R0, LSL #+2
   \   00000080   0x.... 0x....      BL       macMemReadRam
    439               
    440              if( osal_memcmp( pAddr, ramEntry, entrySize ) == TRUE )
   \   00000084   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000086   0x0032             MOVS     R2,R6
   \   00000088   0xA901             ADD      R1,SP,#+4
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       osal_memcmp
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD1DA             BNE.N    ??macSrcMatchCheckSrcAddr_4
    441              {
    442                /* Match found */
    443                return indexUsed;
   \   00000094   0x0038             MOVS     R0,R7
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0xE000             B.N      ??macSrcMatchCheckSrcAddr_6
    444              }
    445            }
    446            
    447            return MAC_SRCMATCH_INVALID_INDEX;
   \                     ??macSrcMatchCheckSrcAddr_5: (+1)
   \   0000009A   0x20FF             MOVS     R0,#+255
   \                     ??macSrcMatchCheckSrcAddr_6: (+1)
   \   0000009C   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    448          }
    449          
    450          /*********************************************************************
    451           * @fn          macSrcMatchSetPendEnBit
    452           *
    453           * @brief       Set the enable bit in the source address table
    454           *
    455           * @param       index - index of the entry in the source address table
    456           * @param       macSrcMatchAddrMode - Address Mode for the entry. Valid values
    457           *              are SADDR_MODE_SHORT or SADDR_MODE_EXT
    458           * @return      none
    459           */

   \                                 In section .text, align 2, keep-with-next
    460          static void macSrcMatchSetPendEnBit( uint8 index, uint8 macSrcMatchAddrMode )
    461          {
   \                     macSrcMatchSetPendEnBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    462            uint24 enable;
    463            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    464                 
    465            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD10E             BNE.N    ??macSrcMatchSetPendEnBit_0
    466            {
    467              enable = MAC_RADIO_SRC_MATCH_GET_SHORTADDR_PENDEN(); 
   \   0000000C   0x.... 0x....      BL       macSrcMatchGetShortAddrPendEnBit
    468              enable |= ( (uint24)0x01 << index );
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x40A1             LSLS     R1,R1,R4
   \   00000014   0x4308             ORRS     R0,R1,R0
    469              osal_buffer_uint24( buf, enable );
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       osal_buffer_uint24
    470              MAC_RADIO_SRC_MATCH_SET_SHORTPENDEN( buf );
   \   0000001E   0x2203             MOVS     R2,#+3
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x....             LDR.N    R0,??DataTable11_8  ;; 0x4008859c
   \   00000024   0x.... 0x....      BL       macMemWriteRam
   \   00000028   0xE015             B.N      ??macSrcMatchSetPendEnBit_1
    471            }
    472            else
    473            {
    474              enable = MAC_RADIO_SRC_MATCH_GET_EXTADDR_PENDEN(); 
   \                     ??macSrcMatchSetPendEnBit_0: (+1)
   \   0000002A   0x.... 0x....      BL       macSrcMatchGetExtAddrPendEnBit
    475              enable |= ( (uint24)0x01 << ( index * EXT_ADDR_INDEX_SIZE ) );
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x0062             LSLS     R2,R4,#+1
   \   00000034   0x4091             LSLS     R1,R1,R2
   \   00000036   0x4308             ORRS     R0,R1,R0
    476              enable |= ( (uint24)0x01 << ( ( index * EXT_ADDR_INDEX_SIZE ) + 1 ) );
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x0062             LSLS     R2,R4,#+1
   \   0000003E   0x1C52             ADDS     R2,R2,#+1
   \   00000040   0x4091             LSLS     R1,R1,R2
   \   00000042   0x4308             ORRS     R0,R1,R0
    477              osal_buffer_uint24( buf, enable );
   \   00000044   0x0001             MOVS     R1,R0
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       osal_buffer_uint24
    478              MAC_RADIO_SRC_MATCH_SET_EXTPENDEN( buf );
   \   0000004C   0x2203             MOVS     R2,#+3
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x....             LDR.N    R0,??DataTable11_9  ;; 0x40088590
   \   00000052   0x.... 0x....      BL       macMemWriteRam
    479            }
    480          }
   \                     ??macSrcMatchSetPendEnBit_1: (+1)
   \   00000056   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    481          
    482          /*********************************************************************
    483           * @fn          macSrcMatchSetEnableBit
    484           *
    485           * @brief       Set or clear the enable bit in the SRCMATCH EN register
    486           *
    487           * @param       index - index of the entry in the source address table
    488           * @param       option - true (set the enable bit), or false (clear the 
    489           *              enable bit)
    490           * @param       macSrcMatchAddrMode - Address Mode for the entry. Valid values
    491           *              are SADDR_MODE_SHORT or SADDR_MODE_EXT
    492           *
    493           * @return      none
    494           */

   \                                 In section .text, align 2, keep-with-next
    495          static void macSrcMatchSetEnableBit(uint8 index, 
    496                                              bool option, 
    497                                              uint8 macSrcMatchAddrMode)
    498          {
   \                     macSrcMatchSetEnableBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    499            uint24 enable;  
    500            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    501            
    502            if( option == TRUE )
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD022             BEQ.N    ??macSrcMatchSetEnableBit_0
    503            {
    504              if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x2A02             CMP      R2,#+2
   \   00000010   0xD10E             BNE.N    ??macSrcMatchSetEnableBit_1
    505              {
    506                enable = MAC_RADIO_SRC_MATCH_GET_SHORTADDR_EN(); 
   \   00000012   0x.... 0x....      BL       macSrcMatchGetShortAddrEnableBit
    507                enable |= ( (uint24)0x01 << index );
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x40A1             LSLS     R1,R1,R4
   \   0000001A   0x4308             ORRS     R0,R1,R0
    508                osal_buffer_uint24( buf, enable );
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0xA800             ADD      R0,SP,#+0
   \   00000020   0x.... 0x....      BL       osal_buffer_uint24
    509                MAC_RADIO_SRC_MATCH_SET_SHORTEN( buf );
   \   00000024   0x2203             MOVS     R2,#+3
   \   00000026   0xA900             ADD      R1,SP,#+0
   \   00000028   0x....             LDR.N    R0,??DataTable11_10  ;; 0x4008860c
   \   0000002A   0x.... 0x....      BL       macMemWriteRam
   \   0000002E   0xE032             B.N      ??macSrcMatchSetEnableBit_2
    510              }
    511              else
    512              {
    513                enable = MAC_RADIO_SRC_MATCH_GET_EXTADDR_EN(); 
   \                     ??macSrcMatchSetEnableBit_1: (+1)
   \   00000030   0x.... 0x....      BL       macSrcMatchGetExtAddrEnableBit
    514                enable |= ( (uint24)0x01 << ( index *  EXT_ADDR_INDEX_SIZE) );
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x0062             LSLS     R2,R4,#+1
   \   0000003A   0x4091             LSLS     R1,R1,R2
   \   0000003C   0x4308             ORRS     R0,R1,R0
    515                osal_buffer_uint24( buf, enable );
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       osal_buffer_uint24
    516                MAC_RADIO_SRC_MATCH_SET_EXTEN( buf );
   \   00000046   0x2203             MOVS     R2,#+3
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x....             LDR.N    R0,??DataTable11_11  ;; 0x40088618
   \   0000004C   0x.... 0x....      BL       macMemWriteRam
   \   00000050   0xE021             B.N      ??macSrcMatchSetEnableBit_2
    517              }
    518            }
    519            else
    520            {
    521              if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \                     ??macSrcMatchSetEnableBit_0: (+1)
   \   00000052   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000054   0x2A02             CMP      R2,#+2
   \   00000056   0xD10E             BNE.N    ??macSrcMatchSetEnableBit_3
    522              {
    523                enable = MAC_RADIO_SRC_MATCH_GET_SHORTADDR_EN();
   \   00000058   0x.... 0x....      BL       macSrcMatchGetShortAddrEnableBit
    524                enable &= ~( (uint24)0x01 << index );
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x40A1             LSLS     R1,R1,R4
   \   00000060   0x4388             BICS     R0,R0,R1
    525                osal_buffer_uint24( buf, enable );
   \   00000062   0x0001             MOVS     R1,R0
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x.... 0x....      BL       osal_buffer_uint24
    526                MAC_RADIO_SRC_MATCH_SET_SHORTEN( buf );
   \   0000006A   0x2203             MOVS     R2,#+3
   \   0000006C   0xA900             ADD      R1,SP,#+0
   \   0000006E   0x....             LDR.N    R0,??DataTable11_10  ;; 0x4008860c
   \   00000070   0x.... 0x....      BL       macMemWriteRam
   \   00000074   0xE00F             B.N      ??macSrcMatchSetEnableBit_2
    527              }
    528              else
    529              {
    530                enable = MAC_RADIO_SRC_MATCH_GET_EXTADDR_EN(); 
   \                     ??macSrcMatchSetEnableBit_3: (+1)
   \   00000076   0x.... 0x....      BL       macSrcMatchGetExtAddrEnableBit
    531                enable &= ~( (uint24)0x01 << ( index * EXT_ADDR_INDEX_SIZE ) );
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x0062             LSLS     R2,R4,#+1
   \   00000080   0x4091             LSLS     R1,R1,R2
   \   00000082   0x4388             BICS     R0,R0,R1
    532                osal_buffer_uint24( buf, enable );
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0xA800             ADD      R0,SP,#+0
   \   00000088   0x.... 0x....      BL       osal_buffer_uint24
    533                MAC_RADIO_SRC_MATCH_SET_EXTEN( buf );
   \   0000008C   0x2203             MOVS     R2,#+3
   \   0000008E   0xA900             ADD      R1,SP,#+0
   \   00000090   0x....             LDR.N    R0,??DataTable11_11  ;; 0x40088618
   \   00000092   0x.... 0x....      BL       macMemWriteRam
    534              }
    535            }
    536          }
   \                     ??macSrcMatchSetEnableBit_2: (+1)
   \   00000096   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    537          
    538          /*********************************************************************
    539           * @fn          macSrcMatchCheckEnableBit
    540           *
    541           * @brief       Check the enable bit in the source address table
    542           *
    543           * @param       index - index of the entry in the source address table
    544           * @param       enable - enable register should be read before passing 
    545           *              it here
    546           *            
    547           * @return      TRUE or FALSE
    548           */

   \                                 In section .text, align 2, keep-with-next
    549          static bool macSrcMatchCheckEnableBit( uint8 index, uint24 enable)
    550          {
    551            if( enable & ( (uint24)0x01 << index ) )
   \                     macSrcMatchCheckEnableBit: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x40C2             LSRS     R2,R2,R0
   \   00000004   0x07D0             LSLS     R0,R2,#+31
   \   00000006   0xD501             BPL.N    ??macSrcMatchCheckEnableBit_0
    552            {
    553              return TRUE;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??macSrcMatchCheckEnableBit_1
    554            }
    555            
    556            return FALSE; 
   \                     ??macSrcMatchCheckEnableBit_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??macSrcMatchCheckEnableBit_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    557          }
    558           
    559          /*********************************************************************
    560           * @fn          macSrcMatchGetShortAddrPendEnBit
    561           *
    562           * @brief       Return the SRCMATCH ShortAddr Pend enable bitmap
    563           *
    564           * @param       none
    565           *
    566           * @return      uint24 - 24 bits bitmap
    567           */

   \                                 In section .text, align 2, keep-with-next
    568          static uint24 macSrcMatchGetShortAddrPendEnBit( void )
    569          {
   \                     macSrcMatchGetShortAddrPendEnBit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    570            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    571            
    572            MAC_RADIO_GET_SRC_SHORTPENDEN( buf );
   \   00000002   0x2203             MOVS     R2,#+3
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable11_8  ;; 0x4008859c
   \   00000008   0x.... 0x....      BL       macMemReadRam
    573            
    574            return osal_build_uint32( buf, MAC_SRCMATCH_ENABLE_BITMAP_LEN );
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       osal_build_uint32
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    575          }
    576          
    577           
    578          /*********************************************************************
    579           * @fn          macSrcMatchGetExtAddrPendEnBit
    580           *
    581           * @brief       Return the SRCMATCH Extended Address Pend enable bitmap
    582           *
    583           * @param       none
    584           *
    585           * @return      uint24 - 24 bits bitmap
    586           */

   \                                 In section .text, align 2, keep-with-next
    587          static uint24 macSrcMatchGetExtAddrPendEnBit( void )
    588          {
   \                     macSrcMatchGetExtAddrPendEnBit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    589            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    590            
    591            MAC_RADIO_GET_SRC_EXTENPEND( buf );
   \   00000002   0x2203             MOVS     R2,#+3
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable11_9  ;; 0x40088590
   \   00000008   0x.... 0x....      BL       macMemReadRam
    592            
    593            return osal_build_uint32( buf, MAC_SRCMATCH_ENABLE_BITMAP_LEN );
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       osal_build_uint32
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    594          }
    595          
    596          /*********************************************************************
    597           * @fn          macSrcMatchGetShortAddrEnableBit
    598           *
    599           * @brief       Return the SRCMATCH ShortAddr enable bitmap
    600           *
    601           * @param       none
    602           *
    603           * @return      uint24 - 24 bits bitmap
    604           */

   \                                 In section .text, align 2, keep-with-next
    605          static uint24 macSrcMatchGetShortAddrEnableBit( void )
    606          {
   \                     macSrcMatchGetShortAddrEnableBit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    607            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    608            
    609            MAC_RADIO_GET_SRC_SHORTEN( buf );
   \   00000002   0x2203             MOVS     R2,#+3
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable11_10  ;; 0x4008860c
   \   00000008   0x.... 0x....      BL       macMemReadRam
    610            
    611            return osal_build_uint32( buf, MAC_SRCMATCH_ENABLE_BITMAP_LEN );
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       osal_build_uint32
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    612          }
    613          
    614          /*********************************************************************
    615           * @fn          macSrcMatchGetExtAddrEnBit
    616           *
    617           * @brief       Return the SRCMATCH ExtAddr enable bitmap
    618           *
    619           * @param       none
    620           *
    621           * @return      uint24 - 24 bits bitmap
    622           */

   \                                 In section .text, align 2, keep-with-next
    623          static uint24 macSrcMatchGetExtAddrEnableBit( void )
    624          {
   \                     macSrcMatchGetExtAddrEnableBit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    625            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    626            
    627            MAC_RADIO_GET_SRC_EXTEN( buf );
   \   00000002   0x2203             MOVS     R2,#+3
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable11_11  ;; 0x40088618
   \   00000008   0x.... 0x....      BL       macMemReadRam
    628            
    629            return osal_build_uint32( buf, MAC_SRCMATCH_ENABLE_BITMAP_LEN );
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       osal_build_uint32
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    630          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40088600         DC32     0x40088600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x40088624         DC32     0x40088624

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x40088608         DC32     0x40088608

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     macSrcMatchIsEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x40088400         DC32     0x40088400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     macSrcMatchIsAckAllPending

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x40088628         DC32     0x40088628

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x4008858C         DC32     0x4008858c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x4008859C         DC32     0x4008859c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x40088590         DC32     0x40088590

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x4008860C         DC32     0x4008860c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x40088618         DC32     0x40088618
    631          
    632          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MAC_SrcMatchAckAllPending
      24   MAC_SrcMatchAddEntry
        24   -> macMemWriteRam
        24   -> macSrcMatchCheckSrcAddr
        24   -> macSrcMatchFindEmptyEntry
        24   -> macSrcMatchSetEnableBit
        24   -> macSrcMatchSetPendEnBit
       0   MAC_SrcMatchCheckAllPending
       0   MAC_SrcMatchCheckResult
       8   MAC_SrcMatchDeleteEntry
         8   -> macSrcMatchCheckSrcAddr
         8   -> macSrcMatchSetEnableBit
       0   MAC_SrcMatchEnable
       0   macSrcMatchCheckEnableBit
      40   macSrcMatchCheckSrcAddr
        40   -> macMemReadRam
        40   -> macSrcMatchCheckEnableBit
        40   -> macSrcMatchGetExtAddrEnableBit
        40   -> macSrcMatchGetShortAddrEnableBit
        40   -> osal_memcmp
      16   macSrcMatchFindEmptyEntry
        16   -> macSrcMatchGetExtAddrEnableBit
        16   -> macSrcMatchGetShortAddrEnableBit
       8   macSrcMatchGetExtAddrEnableBit
         8   -> macMemReadRam
         8   -> osal_build_uint32
       8   macSrcMatchGetExtAddrPendEnBit
         8   -> macMemReadRam
         8   -> osal_build_uint32
       8   macSrcMatchGetShortAddrEnableBit
         8   -> macMemReadRam
         8   -> osal_build_uint32
       8   macSrcMatchGetShortAddrPendEnBit
         8   -> macMemReadRam
         8   -> osal_build_uint32
      16   macSrcMatchSetEnableBit
        16   -> macMemWriteRam
        16   -> macSrcMatchGetExtAddrEnableBit
        16   -> macSrcMatchGetShortAddrEnableBit
        16   -> osal_buffer_uint24
      16   macSrcMatchSetPendEnBit
        16   -> macMemWriteRam
        16   -> macSrcMatchGetExtAddrPendEnBit
        16   -> macSrcMatchGetShortAddrPendEnBit
        16   -> osal_buffer_uint24


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      46  MAC_SrcMatchAckAllPending
     178  MAC_SrcMatchAddEntry
      16  MAC_SrcMatchCheckAllPending
      26  MAC_SrcMatchCheckResult
      56  MAC_SrcMatchDeleteEntry
      98  MAC_SrcMatchEnable
      16  macSrcMatchCheckEnableBit
     160  macSrcMatchCheckSrcAddr
     114  macSrcMatchFindEmptyEntry
      22  macSrcMatchGetExtAddrEnableBit
      22  macSrcMatchGetExtAddrPendEnBit
      22  macSrcMatchGetShortAddrEnableBit
      22  macSrcMatchGetShortAddrPendEnBit
       1  macSrcMatchIsAckAllPending
       1  macSrcMatchIsEnabled
     152  macSrcMatchSetEnableBit
      88  macSrcMatchSetPendEnBit

 
     2 bytes in section .bss
 1 086 bytes in section .text
 
 1 086 bytes of CODE memory
     2 bytes of DATA memory

Errors: none
Warnings: none
