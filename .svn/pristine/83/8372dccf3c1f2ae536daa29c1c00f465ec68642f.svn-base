///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM       12/Apr/2015  15:43:27
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\hal\target\CC2538\hal_uart.c
//    Command line =  
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\hal\target\CC2538\hal_uart.c" -D FEATURE_RESET_MACRO
//        -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D ZTOOL_P1 -D MT_TASK -D
//        MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=YES -D
//        CC2538_USE_ALTERNATE_INTERRUPT_MAP=1 --preprocess=cl
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
//        --diag_suppress Pa082 -o
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
//        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
//        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
//        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\"
//        -I "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
//        "C:\Texas Instruments\Z-Stack Mesh
//        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
//        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
//        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
//        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
//    List file    =  
//        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\hal_uart.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN GPIOPinTypeUARTInput
        EXTERN GPIOPinTypeUARTOutput
        EXTERN IOCPinConfigPeriphInput
        EXTERN IOCPinConfigPeriphOutput
        EXTERN IntEnable
        EXTERN IntMasterDisable
        EXTERN IntMasterEnable
        EXTERN SysCtrlClockGet
        EXTERN SysCtrlPeripheralEnable
        EXTERN UARTCharGetNonBlocking
        EXTERN UARTCharPutNonBlocking
        EXTERN UARTCharsAvail
        EXTERN UARTConfigSetExpClk
        EXTERN UARTDisable
        EXTERN UARTEnable
        EXTERN UARTFIFOEnable
        EXTERN UARTFIFOLevelSet
        EXTERN UARTIntClear
        EXTERN UARTIntEnable
        EXTERN osal_GetSystemClock
        EXTERN osal_mem_alloc
        EXTERN osal_mem_free

        PUBLIC HalUARTClose
        PUBLIC HalUARTCloseIsr
        PUBLIC HalUARTInit
        PUBLIC HalUARTInitIsr
        PUBLIC HalUARTOpen
        PUBLIC HalUARTOpenIsr
        PUBLIC HalUARTPoll
        PUBLIC HalUARTPollIsr
        PUBLIC HalUARTRead
        PUBLIC HalUARTReadIsr
        PUBLIC HalUARTWrite
        PUBLIC HalUARTWriteIsr
        PUBLIC Hal_UART_RxBufLen
        PUBLIC Hal_UART_RxBufLenIsr
        PUBLIC Hal_UART_TxBufLen
        PUBLIC UBRRTable
        PUBLIC interrupt_uart1

// C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\hal_uart.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_uart.c
//    3   Revised:        $Date: 2013-05-17 11:25:11 -0700 (Fri, 17 May 2013) $
//    4   Revision:       $Revision: 34355 $
//    5 
//    6   Description:    This file contains the interface to the UART.
//    7 
//    8 
//    9   Copyright 2012-2013 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 #if HAL_UART_USB
//   46 #include "_hal_uart_usb.c"
//   47 #else
//   48 #include "_hal_uart_isr.c"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
// __absolute unsigned long const UBRRTable[5]
UBRRTable:
        DATA
        DC32 9600, 19200, 38400, 57600, 115200

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// static __absolute halUARTCfg_t uartRecord
uartRecord:
        DS8 44

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
// static __absolute bool txMT
txMT:
        DS8 1

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp void HalUARTInitIsr(void)
HalUARTInitIsr:
        PUSH     {R7,LR}
        MOVW     R0,#+513
        BL       SysCtrlPeripheralEnable
        MOVS     R2,#+2
        MOVS     R1,#+2
        LDR.W    R0,??DataTable11  ;; 0x400d9000
        BL       IOCPinConfigPeriphOutput
        LDR.W    R2,??DataTable11_1  ;; 0x400d4108
        MOVS     R1,#+1
        LDR.W    R0,??DataTable11  ;; 0x400d9000
        BL       IOCPinConfigPeriphInput
        MOVS     R1,#+1
        LDR.W    R0,??DataTable11  ;; 0x400d9000
        BL       GPIOPinTypeUARTInput
        MOVS     R1,#+2
        LDR.W    R0,??DataTable11  ;; 0x400d9000
        BL       GPIOPinTypeUARTOutput
        BL       recRst
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp uint8 HalUARTOpenIsr(uint8, halUARTCfg_t *)
HalUARTOpenIsr:
        PUSH     {R4,LR}
        MOVS     R4,R1
        LDR.W    R1,??DataTable11_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BEQ.N    ??HalUARTOpenIsr_0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       HalUARTClose
??HalUARTOpenIsr_0:
        LDRB     R0,[R4, #+1]
        CMP      R0,#+5
        BLT.N    ??HalUARTOpenIsr_1
        MOVS     R0,#+4
        B.N      ??HalUARTOpenIsr_2
??HalUARTOpenIsr_1:
        LDRH     R0,[R4, #+12]
        BL       osal_mem_alloc
        LDR.W    R1,??DataTable11_2
        STR      R0,[R1, #+16]
        LDR.W    R0,??DataTable11_2
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??HalUARTOpenIsr_3
        LDRH     R0,[R4, #+24]
        BL       osal_mem_alloc
        LDR.W    R1,??DataTable11_2
        STR      R0,[R1, #+28]
        LDR.W    R0,??DataTable11_2
        LDR      R0,[R0, #+28]
        CMP      R0,#+0
        BNE.N    ??HalUARTOpenIsr_4
??HalUARTOpenIsr_3:
        LDR.W    R0,??DataTable11_2
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??HalUARTOpenIsr_5
        LDR.W    R0,??DataTable11_2
        LDR      R0,[R0, #+16]
        BL       osal_mem_free
        MOVS     R0,#+0
        LDR.W    R1,??DataTable11_2
        STR      R0,[R1, #+16]
??HalUARTOpenIsr_5:
        MOVS     R0,#+3
        B.N      ??HalUARTOpenIsr_2
??HalUARTOpenIsr_4:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??HalUARTOpenIsr_6
        MOVS     R2,#+1
        MOVS     R1,#+8
        LDR.W    R0,??DataTable11_3  ;; 0x400dc000
        BL       IOCPinConfigPeriphOutput
        MOVS     R1,#+8
        LDR.W    R0,??DataTable11_3  ;; 0x400dc000
        BL       GPIOPinTypeUARTOutput
        LDR.W    R2,??DataTable11_4  ;; 0x400d4104
        MOVS     R1,#+1
        LDR.W    R0,??DataTable11_5  ;; 0x400da000
        BL       IOCPinConfigPeriphInput
        MOVS     R1,#+1
        LDR.W    R0,??DataTable11_5  ;; 0x400da000
        BL       GPIOPinTypeUARTInput
??HalUARTOpenIsr_6:
        MOVS     R0,#+22
        BL       IntEnable
        MOVS     R0,#+1
        LDR.W    R1,??DataTable11_2
        STRB     R0,[R1, #+0]
        LDRB     R0,[R4, #+1]
        LDR.W    R1,??DataTable11_2
        STRB     R0,[R1, #+1]
        LDRB     R0,[R4, #+2]
        LDR.W    R1,??DataTable11_2
        STRB     R0,[R1, #+2]
        LDRH     R0,[R4, #+12]
        LDRH     R1,[R4, #+4]
        CMP      R0,R1
        BCS.N    ??HalUARTOpenIsr_7
        MOVS     R0,#+0
        LDR.W    R1,??DataTable11_2
        STRH     R0,[R1, #+4]
        B.N      ??HalUARTOpenIsr_8
??HalUARTOpenIsr_7:
        LDRH     R0,[R4, #+4]
        LDR.W    R1,??DataTable11_2
        STRH     R0,[R1, #+4]
??HalUARTOpenIsr_8:
        LDRB     R0,[R4, #+6]
        LDR.W    R1,??DataTable11_2
        STRB     R0,[R1, #+6]
        LDRH     R0,[R4, #+12]
        LDR.W    R1,??DataTable11_2
        STRH     R0,[R1, #+12]
        LDRH     R0,[R4, #+24]
        LDR.W    R1,??DataTable11_2
        STRH     R0,[R1, #+24]
        LDRB     R0,[R4, #+32]
        LDR.W    R1,??DataTable11_2
        STRB     R0,[R1, #+32]
        LDR      R0,[R4, #+40]
        LDR.W    R1,??DataTable11_2
        STR      R0,[R1, #+40]
        BL       SysCtrlClockGet
        MOVS     R1,R0
        MOVS     R3,#+96
        LDR.W    R0,??DataTable11_6
        LDR.W    R2,??DataTable11_2
        LDRB     R2,[R2, #+1]
        LDR      R2,[R0, R2, LSL #+2]
        LDR.W    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTConfigSetExpClk
        MOVS     R2,#+0
        MOVS     R1,#+0
        LDR.W    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTFIFOLevelSet
        LDR.W    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTFIFOEnable
        MOVS     R1,#+114
        LDR.W    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTIntClear
        MOVS     R1,#+114
        LDR.W    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTIntEnable
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??HalUARTOpenIsr_9
        LDR.W    R0,??DataTable11_8  ;; 0x4000d030
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0xC000
        LDR.W    R1,??DataTable11_8  ;; 0x4000d030
        STR      R0,[R1, #+0]
??HalUARTOpenIsr_9:
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTEnable
        MOVS     R0,#+0
??HalUARTOpenIsr_2:
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp void HalUARTPollIsr(void)
HalUARTPollIsr:
        PUSH     {R4-R6,LR}
        LDR.N    R0,??DataTable11_2
        LDRH     R4,[R0, #+20]
        LDR.N    R0,??DataTable11_2
        LDRH     R5,[R0, #+22]
        LDR.N    R0,??DataTable11_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??HalUARTPollIsr_0
??HalUARTPollIsr_1:
        BL       IntMasterDisable
        ANDS     R0,R0,#0x1
        EORS     R6,R0,#0x1
        BL       procRx
        BL       procTx
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??HalUARTPollIsr_2
        BL       IntMasterEnable
??HalUARTPollIsr_2:
        MOVS     R6,#+0
        MOVS     R0,#+0
        BL       Hal_UART_RxBufLen
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable11_2
        LDRH     R1,[R1, #+12]
        CMP      R0,R1
        BLT.N    ??HalUARTPollIsr_3
        MOVS     R6,#+1
??HalUARTPollIsr_3:
        LDR.N    R0,??DataTable11_2
        LDR      R0,[R0, #+36]
        CMP      R0,#+0
        BEQ.N    ??HalUARTPollIsr_4
        BL       osal_GetSystemClock
        LDR.N    R1,??DataTable11_2
        LDRB     R1,[R1, #+6]
        LDR.N    R2,??DataTable11_2
        LDR      R2,[R2, #+36]
        SUBS     R0,R0,R2
        CMP      R1,R0
        BCS.N    ??HalUARTPollIsr_4
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STR      R0,[R1, #+36]
        ORRS     R6,R6,#0x4
??HalUARTPollIsr_4:
        MOVS     R0,#+0
        BL       Hal_UART_RxBufLen
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LDR.N    R1,??DataTable11_2
        LDRH     R1,[R1, #+12]
        LDR.N    R2,??DataTable11_2
        LDRH     R2,[R2, #+4]
        SUBS     R1,R1,R2
        CMP      R0,R1
        BLT.N    ??HalUARTPollIsr_5
        ORRS     R6,R6,#0x2
??HalUARTPollIsr_5:
        LDR.N    R0,??DataTable11_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??HalUARTPollIsr_6
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R4,R5
        BNE.N    ??HalUARTPollIsr_6
        MOVS     R0,#+1
        LDR.N    R1,??DataTable11_9
        STRB     R0,[R1, #+0]
        ORRS     R6,R6,#0x10
??HalUARTPollIsr_6:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??HalUARTPollIsr_7
        LDR.N    R0,??DataTable11_2
        LDR      R0,[R0, #+40]
        CMP      R0,#+0
        BEQ.N    ??HalUARTPollIsr_7
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,#+0
        LDR.N    R2,??DataTable11_2
        LDR      R2,[R2, #+40]
        BLX      R2
??HalUARTPollIsr_7:
??HalUARTPollIsr_0:
        POP      {R4-R6,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp void HalUARTCloseIsr(uint8)
HalUARTCloseIsr:
        PUSH     {R7,LR}
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTDisable
        LDR.N    R0,??DataTable11_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??HalUARTCloseIsr_0
        LDR.N    R0,??DataTable11_2
        LDR      R0,[R0, #+16]
        BL       osal_mem_free
        LDR.N    R0,??DataTable11_2
        LDR      R0,[R0, #+28]
        BL       osal_mem_free
        BL       recRst
??HalUARTCloseIsr_0:
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp uint16 HalUARTReadIsr(uint8, unsigned char *, uint16)
HalUARTReadIsr:
        PUSH     {R3-R5,LR}
        MOVS     R4,R1
        MOVS     R5,R2
        LDR.N    R0,??DataTable11_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??HalUARTReadIsr_0
        MOVS     R0,#+0
        B.N      ??HalUARTReadIsr_1
??HalUARTReadIsr_0:
        MOVS     R0,#+0
        BL       Hal_UART_RxBufLen
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R0,R5
        BCS.N    ??HalUARTReadIsr_2
        MOVS     R5,R0
??HalUARTReadIsr_2:
        LDR.N    R0,??DataTable11_2
        LDRH     R1,[R0, #+8]
        MOVS     R0,#+0
        B.N      ??HalUARTReadIsr_3
??HalUARTReadIsr_4:
        LDR.N    R2,??DataTable11_2
        LDR      R2,[R2, #+16]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LDRB     R2,[R1, R2]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STRB     R2,[R0, R4]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable11_2
        LDRH     R2,[R2, #+12]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R1,R2
        BCC.N    ??HalUARTReadIsr_5
        MOVS     R1,#+0
??HalUARTReadIsr_5:
        ADDS     R0,R0,#+1
??HalUARTReadIsr_3:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R0,R5
        BCC.N    ??HalUARTReadIsr_4
        LDR.N    R0,??DataTable11_2
        STRH     R1,[R0, #+8]
        MOVS     R0,R5
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
??HalUARTReadIsr_1:
        POP      {R1,R4,R5,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp uint16 HalUARTWriteIsr(uint8, unsigned char *, uint16)
HalUARTWriteIsr:
        PUSH     {R4-R6,LR}
        MOVS     R4,R2
        LDR.N    R0,??DataTable11_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??HalUARTWriteIsr_0
        MOVS     R0,#+0
        B.N      ??HalUARTWriteIsr_1
??HalUARTWriteIsr_0:
        LDR.N    R0,??DataTable11_2
        LDRH     R5,[R0, #+20]
        LDR.N    R0,??DataTable11_2
        LDRH     R0,[R0, #+22]
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R0,R5
        BNE.N    ??HalUARTWriteIsr_2
        LDR.N    R0,??DataTable11_2
        LDRH     R0,[R0, #+24]
        B.N      ??HalUARTWriteIsr_3
??HalUARTWriteIsr_2:
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R5,R0
        BCS.N    ??HalUARTWriteIsr_4
        LDR.N    R2,??DataTable11_2
        LDRH     R2,[R2, #+24]
        SUBS     R0,R2,R0
        ADDS     R0,R5,R0
        B.N      ??HalUARTWriteIsr_3
??HalUARTWriteIsr_4:
        SUBS     R0,R5,R0
??HalUARTWriteIsr_3:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R0,R4
        BCS.N    ??HalUARTWriteIsr_5
        MOVS     R0,#+0
        B.N      ??HalUARTWriteIsr_1
??HalUARTWriteIsr_5:
        MOVS     R0,#+0
        LDR.N    R2,??DataTable11_9
        STRB     R0,[R2, #+0]
        LDR.N    R0,??DataTable11_2
        LDRH     R5,[R0, #+22]
        MOVS     R0,#+0
        B.N      ??HalUARTWriteIsr_6
??HalUARTWriteIsr_7:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        LDRB     R2,[R0, R1]
        LDR.N    R3,??DataTable11_2
        LDR      R3,[R3, #+28]
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        STRB     R2,[R5, R3]
        ADDS     R5,R5,#+1
        LDR.N    R2,??DataTable11_2
        LDRH     R2,[R2, #+24]
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R5,R2
        BCC.N    ??HalUARTWriteIsr_8
        MOVS     R5,#+0
??HalUARTWriteIsr_8:
        ADDS     R0,R0,#+1
??HalUARTWriteIsr_6:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R0,R4
        BCC.N    ??HalUARTWriteIsr_7
        BL       IntMasterDisable
        ANDS     R0,R0,#0x1
        EORS     R6,R0,#0x1
        LDR.N    R0,??DataTable11_2
        STRH     R5,[R0, #+22]
        BL       procTx
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??HalUARTWriteIsr_9
        BL       IntMasterEnable
??HalUARTWriteIsr_9:
        MOVS     R0,R4
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
??HalUARTWriteIsr_1:
        POP      {R4-R6,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp uint16 Hal_UART_RxBufLenIsr(uint8)
Hal_UART_RxBufLenIsr:
        LDR.N    R0,??DataTable11_2
        LDRSH    R0,[R0, #+10]
        LDR.N    R1,??DataTable11_2
        LDRSH    R1,[R1, #+8]
        SUBS     R0,R0,R1
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+0
        BPL.N    ??Hal_UART_RxBufLenIsr_0
        LDR.N    R1,??DataTable11_2
        LDRSH    R1,[R1, #+12]
        ADDS     R0,R1,R0
??Hal_UART_RxBufLenIsr_0:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp uint16 Hal_UART_TxBufLen(uint8)
Hal_UART_TxBufLen:
        LDR.N    R0,??DataTable11_2
        LDRSH    R0,[R0, #+22]
        LDR.N    R1,??DataTable11_2
        LDRSH    R1,[R1, #+20]
        SUBS     R0,R0,R1
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+0
        BPL.N    ??Hal_UART_TxBufLen_0
        LDR.N    R1,??DataTable11_2
        LDRSH    R1,[R1, #+24]
        ADDS     R0,R1,R0
??Hal_UART_TxBufLen_0:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// static __interwork __softfp void recRst(void)
recRst:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STRH     R0,[R1, #+8]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STRH     R0,[R1, #+10]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STR      R0,[R1, #+16]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STRH     R0,[R1, #+20]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STRH     R0,[R1, #+22]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STR      R0,[R1, #+28]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STR      R0,[R1, #+36]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable11_2
        STRB     R0,[R1, #+32]
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// static __interwork __softfp void procRx(void)
procRx:
        PUSH     {R4,LR}
        LDR.N    R0,??DataTable11_2
        LDRH     R4,[R0, #+10]
        B.N      ??procRx_0
??procRx_1:
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTCharGetNonBlocking
        LDR.N    R1,??DataTable11_2
        LDR      R1,[R1, #+16]
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        STRB     R0,[R4, R1]
        ADDS     R4,R4,#+1
        LDR.N    R0,??DataTable11_2
        LDRH     R0,[R0, #+12]
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R4,R0
        BCC.N    ??procRx_0
        MOVS     R4,#+0
??procRx_0:
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTCharsAvail
        CMP      R0,#+0
        BNE.N    ??procRx_1
        LDR.N    R0,??DataTable11_2
        LDRH     R0,[R0, #+10]
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R0,R4
        BEQ.N    ??procRx_2
        LDR.N    R0,??DataTable11_2
        STRH     R4,[R0, #+10]
        BL       osal_GetSystemClock
        LDR.N    R1,??DataTable11_2
        STR      R0,[R1, #+36]
??procRx_2:
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// static __interwork __softfp void procTx(void)
procTx:
        PUSH     {R3-R5,LR}
        LDR.N    R0,??DataTable11_2
        LDRH     R4,[R0, #+20]
        LDR.N    R0,??DataTable11_2
        LDRH     R5,[R0, #+22]
        B.N      ??procTx_0
??procTx_1:
        ADDS     R4,R4,#+1
        LDR.N    R0,??DataTable11_2
        LDRH     R0,[R0, #+24]
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R4,R0
        BCC.N    ??procTx_0
        MOVS     R4,#+0
??procTx_0:
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R4,R5
        BEQ.N    ??procTx_2
        LDR.N    R0,??DataTable11_2
        LDR      R0,[R0, #+28]
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        LDRB     R1,[R4, R0]
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTCharPutNonBlocking
        CMP      R0,#+0
        BNE.N    ??procTx_1
??procTx_2:
        LDR.N    R0,??DataTable11_2
        STRH     R4,[R0, #+20]
        POP      {R0,R4,R5,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __interwork __softfp void interrupt_uart1(void)
interrupt_uart1:
        PUSH     {R7,LR}
        MOVS     R1,#+80
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTIntClear
        BL       procRx
        MOVS     R1,#+34
        LDR.N    R0,??DataTable11_7  ;; 0x4000d000
        BL       UARTIntClear
        BL       procTx
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11:
        DC32     0x400d9000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_1:
        DC32     0x400d4108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_2:
        DC32     uartRecord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_3:
        DC32     0x400dc000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_4:
        DC32     0x400d4104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_5:
        DC32     0x400da000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_6:
        DC32     UBRRTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_7:
        DC32     0x4000d000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_8:
        DC32     0x4000d030

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_9:
        DC32     txMT
//   49 #endif
//   50 
//   51 /* ------------------------------------------------------------------------------------------------
//   52  *                                           Global Functions
//   53  * ------------------------------------------------------------------------------------------------
//   54  */
//   55 
//   56 /*************************************************************************************************
//   57  * @fn      HalUARTInit()
//   58  *
//   59  * @brief   Initialize the UART
//   60  *
//   61  * @param   none
//   62  *
//   63  * @return  none
//   64  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   65 void HalUARTInit(void)
//   66 {
HalUARTInit:
        PUSH     {R7,LR}
//   67 #if HAL_UART_USB
//   68   HalUARTInitUSB();
//   69 #else
//   70   HalUARTInitIsr();
        BL       HalUARTInitIsr
//   71 #endif
//   72 }
        POP      {R0,PC}          ;; return
//   73 
//   74 /*************************************************************************************************
//   75  * @fn      HalUARTOpen()
//   76  *
//   77  * @brief   Open a port based on the configuration
//   78  *
//   79  * @param   port   - UART port
//   80  *          config - contains configuration information
//   81  *          cBack  - Call back function where events will be reported back
//   82  *
//   83  * @return  Status of the function call
//   84  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   85 uint8 HalUARTOpen(uint8 port, halUARTCfg_t *config)
//   86 {
HalUARTOpen:
        PUSH     {R7,LR}
//   87 #if HAL_UART_USB
//   88   (void)port;
//   89   HalUARTOpenUSB(config);
//   90   return HAL_UART_SUCCESS;
//   91 #else
//   92   return(HalUARTOpenIsr(port, config));
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       HalUARTOpenIsr
        POP      {R1,PC}          ;; return
//   93 #endif
//   94 }
//   95 
//   96 /*************************************************************************************************
//   97  * @fn      Hal_UARTPoll
//   98  *
//   99  * @brief   This routine simulate polling and has to be called by the main loop
//  100  *
//  101  * @param   void
//  102  *
//  103  * @return  void
//  104  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  105 void HalUARTPoll(void)
//  106 {
HalUARTPoll:
        PUSH     {R7,LR}
//  107 #ifdef HAL_UART_USB
//  108   HalUARTPollUSB();
//  109 #else
//  110   HalUARTPollIsr();
        BL       HalUARTPollIsr
//  111 #endif
//  112 }
        POP      {R0,PC}          ;; return
//  113 
//  114 /*************************************************************************************************
//  115  * @fn      HalUARTClose()
//  116  *
//  117  * @brief   Close the UART
//  118  *
//  119  * @param   port - UART port (not used.)
//  120  *
//  121  * @return  none
//  122  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  123 void HalUARTClose(uint8 port)
//  124 {
HalUARTClose:
        PUSH     {R7,LR}
//  125 #ifdef HAL_UART_USB
//  126   
//  127 #else   
//  128  HalUARTCloseIsr(port);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       HalUARTCloseIsr
//  129 #endif
//  130 }
        POP      {R0,PC}          ;; return
//  131 
//  132 /*************************************************************************************************
//  133  * @fn      HalUARTRead()
//  134  *
//  135  * @brief   Read a buffer from the UART
//  136  *
//  137  * @param   port - UART port (not used.)
//  138  *          ppBuffer - pointer to a pointer that points to the data that will be read
//  139  *          length - length of the requested buffer
//  140  *
//  141  * @return  length of buffer that was read
//  142  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  143 uint16 HalUARTRead ( uint8 port, uint8 *pBuffer, uint16 length )
//  144 {
HalUARTRead:
        PUSH     {R7,LR}
//  145 #if HAL_UART_USB
//  146   return HalUARTRx(pBuffer, length);
//  147 #else
//  148   return (HalUARTReadIsr( port, pBuffer, length ));
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       HalUARTReadIsr
        POP      {R1,PC}          ;; return
//  149 #endif
//  150 }
//  151 
//  152 /*************************************************************************************************
//  153  * @fn      HalUARTWrite()
//  154  *
//  155  * @brief   Write a buffer to the UART
//  156  *
//  157  * @param   port    - UART port (not used.)
//  158  *          pBuffer - pointer to the buffer that will be written
//  159  *          length  - length of
//  160  *
//  161  * @return  length of the buffer that was sent
//  162  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  163 uint16 HalUARTWrite(uint8 port, uint8 *pBuffer, uint16 length)
//  164 {
HalUARTWrite:
        PUSH     {R7,LR}
//  165 #if HAL_UART_USB
//  166   return HalUARTTx(pBuffer, length);
//  167 #else
//  168   return (HalUARTWriteIsr( port, pBuffer, length ));
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       HalUARTWriteIsr
        POP      {R1,PC}          ;; return
//  169 #endif
//  170 }
//  171 
//  172 /*************************************************************************************************
//  173  * @fn      Hal_UART_RxBufLen()
//  174  *
//  175  * @brief   Calculate Rx Buffer length of a port
//  176  *
//  177  * @param   port - UART port (not used.)
//  178  *
//  179  * @return  length of current Rx Buffer
//  180  *************************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  181 uint16 Hal_UART_RxBufLen (uint8 port)
//  182 {
Hal_UART_RxBufLen:
        PUSH     {R7,LR}
//  183 #if HAL_UART_USB
//  184   return HalUARTRxAvailUSB();
//  185 #else
//  186   return (Hal_UART_RxBufLenIsr(port));
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       Hal_UART_RxBufLenIsr
        POP      {R1,PC}          ;; return
//  187 #endif
//  188 }

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  189 
//  190 /**************************************************************************************************
//  191 */
//  192 
//  193 
//  194 
// 
//    45 bytes in section .bss
//    20 bytes in section .rodata
// 1 278 bytes in section .text
// 
// 1 278 bytes of CODE  memory
//    20 bytes of CONST memory
//    45 bytes of DATA  memory
//
//Errors: none
//Warnings: none
