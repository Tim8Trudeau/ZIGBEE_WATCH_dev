###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        11/Apr/2015  21:30:15
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\AF.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\AF.c" -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=YES
#        -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1 --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\AF.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\AF.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\AF.c
      1          /**************************************************************************************************
      2            Filename:       AF.c
      3            Revised:        $Date: 2014-06-30 16:29:17 -0700 (Mon, 30 Jun 2014) $
      4            Revision:       $Revision: 39295 $
      5          
      6            Description:    Application Framework - Device Description helper functions
      7          
      8          
      9            Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "OSAL.h"
     45          #include "AF.h"
     46          #include "nwk_globals.h"
     47          #include "nwk_util.h"
     48          #include "aps_groups.h"
     49          #include "ZDProfile.h"
     50          #include "aps_frag.h"
     51          #include "rtg.h"
     52          
     53          #if defined ( MT_AF_CB_FUNC )
     54            #include "MT_AF.h"
     55          #endif
     56          
     57          #if defined ( INTER_PAN )
     58            #include "stub_aps.h"
     59          #endif
     60          
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          
     65          /*********************************************************************
     66           * @fn      afSend
     67           *
     68           * @brief   Helper macro for V1 API to invoke V2 API.
     69           *
     70           * input parameters
     71           *
     72           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
     73           * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
     74           * @param   cID - A valid cluster ID as specified by the Profile.
     75           * @param   len - Number of bytes of data pointed to by next param.
     76           * @param  *buf - A pointer to the data bytes to send.
     77           * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
     78           * @param  *transID - A pointer to a byte which can be modified and which will
     79           *                    be used as the transaction sequence number of the msg.
     80           *
     81           * output parameters
     82           *
     83           * @param  *transID - Incremented by one if the return value is success.
     84           *
     85           * @return  afStatus_t - See previous definition of afStatus_... types.
     86           */
     87          #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \
     88                  AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \
     89                                    (cID), (len), (buf), (transID), (options), (radius) )
     90          
     91          /*********************************************************************
     92           * GLOBAL VARIABLES
     93           */
     94          

   \                                 In section .bss, align 4
     95          epList_t *epList;
   \                     epList:
   \   00000000                      DS8 4
     96          
     97          /*********************************************************************
     98           * LOCAL FUNCTIONS
     99           */
    100          
    101          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    102                          zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
    103                          uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp, uint8 radius );
    104          
    105          static epList_t *afFindEndPointDescList( uint8 EndPoint );
    106          
    107          static pDescCB afGetDescCB( endPointDesc_t *epDesc );
    108          
    109          /*********************************************************************
    110           * PUBLIC FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * @fn      afInit
    115           *
    116           * @brief   Initialization function for the AF.
    117           *
    118           * @param   none
    119           *
    120           * @return  none
    121          void afInit( void )
    122          {
    123          }
    124           */
    125          
    126          /*********************************************************************
    127           * @fn      afRegisterExtended
    128           *
    129           * @brief   Register an Application's EndPoint description.
    130           *
    131           * @param   epDesc - pointer to the Application's endpoint descriptor.
    132           * @param   descFn - pointer to descriptor callback function
    133           * @param   applFn - pointer to the Application callback function
    134           *
    135           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    136           *
    137           * @return  Pointer to epList_t on success, NULL otherwise.
    138           */

   \                                 In section .text, align 2, keep-with-next
    139          epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn, pApplCB applFn )
    140          {
   \                     afRegisterExtended: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    141            epList_t *ep = osal_mem_alloc(sizeof(epList_t));
   \   00000008   0x2014             MOVS     R0,#+20
   \   0000000A   0x.... 0x....      BL       osal_mem_alloc
    142          
    143            if (ep != NULL)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00F             BEQ.N    ??afRegisterExtended_0
    144            {
    145              ep->nextDesc = epList;
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x6001             STR      R1,[R0, #+0]
    146              epList = ep;
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable7
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    147              ep->epDesc = epDesc;
   \   00000020   0x6045             STR      R5,[R0, #+4]
    148              ep->pfnDescCB = descFn;
   \   00000022   0x6086             STR      R6,[R0, #+8]
    149              ep->apsfCfg.frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
   \   00000024   0x2132             MOVS     R1,#+50
   \   00000026   0x7301             STRB     R1,[R0, #+12]
    150              ep->apsfCfg.windowSize = APSF_DEFAULT_WINDOW_SIZE;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x7341             STRB     R1,[R0, #+13]
    151              ep->flags = eEP_AllowMatch;  // Default to allow Match Descriptor.
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x7381             STRB     R1,[R0, #+14]
    152              ep->pfnApplCB = applFn;
   \   00000030   0x6104             STR      R4,[R0, #+16]
    153            }
    154          
    155            return ep;
   \                     ??afRegisterExtended_0: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    156          }
    157          
    158          /*********************************************************************
    159           * @fn      afRegister
    160           *
    161           * @brief   Register an Application's EndPoint description.
    162           *
    163           * @param   epDesc - pointer to the Application's endpoint descriptor.
    164           *
    165           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    166           *
    167           * @return  afStatus_SUCCESS - Registered
    168           *          afStatus_MEM_FAIL - not enough memory to add descriptor
    169           *          afStatus_INVALID_PARAMETER - duplicate endpoint
    170           */

   \                                 In section .text, align 2, keep-with-next
    171          afStatus_t afRegister( endPointDesc_t *epDesc )
    172          {
   \                     afRegister: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    173            if (afFindEndPointDescList(epDesc->endPoint))  // Look for duplicate endpoint.
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??afRegister_0
    174            {
    175              return afStatus_INVALID_PARAMETER;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE00A             B.N      ??afRegister_1
    176            }
    177          
    178            return ((NULL == afRegisterExtended(epDesc, NULL, NULL)) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
   \                     ??afRegister_0: (+1)
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       afRegisterExtended
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE.N    ??afRegister_2
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0xE000             B.N      ??afRegister_3
   \                     ??afRegister_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??afRegister_3: (+1)
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??afRegister_1: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    179          }
    180          
    181          /*********************************************************************
    182           * @fn      afDelete
    183           *
    184           * @brief   Delete an Application's EndPoint descriptor and frees the memory
    185           *
    186           * @param   EndPoint - Application Endpoint to delete
    187           *
    188           * @return  afStatus_SUCCESS - endpoint deleted
    189           *          afStatus_INVALID_PARAMETER - endpoint not found
    190           *          afStatus_FAILED - endpoint list empty
    191           */

   \                                 In section .text, align 2, keep-with-next
    192          afStatus_t afDelete( uint8 EndPoint )
    193          {
   \                     afDelete: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    194            epList_t *epCurrent;
    195            epList_t *epPrevious;
    196          
    197            if ( epList != NULL )
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD025             BEQ.N    ??afDelete_0
    198            {
    199              epPrevious = epCurrent = epList;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x000A             MOVS     R2,R1
    200          
    201              // first element of the list matches
    202              if ( epCurrent->epDesc->endPoint == EndPoint )
   \   00000014   0x684B             LDR      R3,[R1, #+4]
   \   00000016   0x781B             LDRB     R3,[R3, #+0]
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4283             CMP      R3,R0
   \   0000001C   0xD108             BNE.N    ??afDelete_1
    203              {
    204                epList = epCurrent->nextDesc;
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000024   0x6010             STR      R0,[R2, #+0]
    205                osal_mem_free( epCurrent );
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0x.... 0x....      BL       osal_mem_free
    206          
    207                return ( afStatus_SUCCESS );
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE014             B.N      ??afDelete_2
    208              }
    209              else
    210              {
    211                // search the list
    212                for ( epCurrent = epPrevious->nextDesc;
   \                     ??afDelete_1: (+1)
   \   00000030   0x6811             LDR      R1,[R2, #+0]
   \   00000032   0xE001             B.N      ??afDelete_3
    213                      epCurrent != NULL;
    214                      epCurrent = epCurrent->nextDesc )
    215                {
    216                  if ( epCurrent->epDesc->endPoint == EndPoint )
    217                  {
    218                    epPrevious->nextDesc = epCurrent->nextDesc;
    219                    osal_mem_free( epCurrent );
    220          
    221                    // delete the entry and free the memory
    222                    return ( afStatus_SUCCESS );
    223                  }
    224                  epPrevious = epCurrent;
   \                     ??afDelete_4: (+1)
   \   00000034   0x000A             MOVS     R2,R1
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \                     ??afDelete_3: (+1)
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD00B             BEQ.N    ??afDelete_5
   \   0000003C   0x684B             LDR      R3,[R1, #+4]
   \   0000003E   0x781B             LDRB     R3,[R3, #+0]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4283             CMP      R3,R0
   \   00000044   0xD1F6             BNE.N    ??afDelete_4
   \   00000046   0x6808             LDR      R0,[R1, #+0]
   \   00000048   0x6010             STR      R0,[R2, #+0]
   \   0000004A   0x0008             MOVS     R0,R1
   \   0000004C   0x.... 0x....      BL       osal_mem_free
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE002             B.N      ??afDelete_2
    225                }
    226              }
    227          
    228              // no endpoint found
    229              return ( afStatus_INVALID_PARAMETER );
   \                     ??afDelete_5: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0xE000             B.N      ??afDelete_2
    230            }
    231            else
    232            {
    233              // epList is empty
    234              return ( afStatus_FAILED );
   \                     ??afDelete_0: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??afDelete_2: (+1)
   \   0000005A   0xBD02             POP      {R1,PC}          ;; return
    235            }
    236          }
    237          
    238          /*********************************************************************
    239           * @fn          afDataConfirm
    240           *
    241           * @brief       This function will generate the Data Confirm back to
    242           *              the application.
    243           *
    244           * @param       endPoint - confirm end point
    245           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    246           * @param       status - status of APSDE_DATA_REQUEST
    247           *
    248           * @return      none
    249           */

   \                                 In section .text, align 2, keep-with-next
    250          void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
    251          {
   \                     afDataConfirm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    252            endPointDesc_t *epDesc;
    253            afDataConfirm_t *msgPtr;
    254          
    255            // Find the endpoint description
    256            epDesc = afFindEndPointDesc( endPoint );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       afFindEndPointDesc
   \   00000010   0x0007             MOVS     R7,R0
    257            if ( epDesc == NULL )
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD00E             BEQ.N    ??afDataConfirm_0
    258              return;
    259          
    260            // Determine the incoming command type
    261            msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
   \                     ??afDataConfirm_1: (+1)
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       osal_msg_allocate
    262            if ( msgPtr )
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD009             BEQ.N    ??afDataConfirm_2
    263            {
    264              // Build the Data Confirm message
    265              msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
   \   00000020   0x21FD             MOVS     R1,#+253
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    266              msgPtr->hdr.status = status;
   \   00000024   0x7046             STRB     R6,[R0, #+1]
    267              msgPtr->endpoint = endPoint;
   \   00000026   0x7084             STRB     R4,[R0, #+2]
    268              msgPtr->transID = transID;
   \   00000028   0x70C5             STRB     R5,[R0, #+3]
    269          
    270          #if defined ( MT_AF_CB_FUNC )
    271              /* If MT has subscribed for this callback, don't send as a message. */
    272              if ( AFCB_CHECK(CB_ID_AF_DATA_CNF,*(epDesc->task_id)) )
    273              {
    274                /* Send callback if it's subscribed */
    275                MT_AfDataConfirm ((void *)msgPtr);
    276                /* Release the memory. */
    277                osal_msg_deallocate( (void *)msgPtr );
    278              }
    279              else
    280          #endif
    281              {
    282                /* send message through task message */
    283                osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0x6878             LDR      R0,[R7, #+4]
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x.... 0x....      BL       osal_msg_send
    284              }
    285            }
    286          }
   \                     ??afDataConfirm_2: (+1)
   \                     ??afDataConfirm_0: (+1)
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    287          
    288          /*********************************************************************
    289           * @fn          afReflectError
    290           *
    291           * @brief       This function will generate the Reflect Error message to
    292           *              the application.
    293           *
    294           * @param       dstAddrMode - mode of dstAdd - 0 - normal short addr, 1 - group Address
    295           * @param       dstAddr - intended destination
    296           * @param       endPoint - confirm end point
    297           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    298           * @param       status - status of APSDE_DATA_REQUEST
    299           *
    300           * @return      none
    301           */

   \                                 In section .text, align 2, keep-with-next
    302          void afReflectError( uint8 dstAddrMode, uint16 dstAddr, uint8 endPoint, uint8 transID, ZStatus_t status )
    303          {
   \                     afReflectError: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    304            endPointDesc_t *epDesc;
    305            afReflectError_t *msgPtr;
    306          
    307            // Find the endpoint description
    308            epDesc = afFindEndPointDesc( endPoint );
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       afFindEndPointDesc
   \   00000014   0x4680             MOV      R8,R0
    309            if ( epDesc == NULL )
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xD012             BEQ.N    ??afReflectError_0
    310              return;
    311          
    312            // Determine the incoming command type
    313            msgPtr = (afReflectError_t *)osal_msg_allocate( sizeof(afReflectError_t) );
   \                     ??afReflectError_1: (+1)
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0x.... 0x....      BL       osal_msg_allocate
    314            if ( msgPtr )
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD00D             BEQ.N    ??afReflectError_2
    315            {
    316              // Build the Data Confirm message
    317              msgPtr->hdr.event = AF_REFLECT_ERROR_CMD;
   \   00000026   0x21FE             MOVS     R1,#+254
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    318              msgPtr->hdr.status = status;
   \   0000002A   0x9906             LDR      R1,[SP, #+24]
   \   0000002C   0x7041             STRB     R1,[R0, #+1]
    319              msgPtr->endpoint = endPoint;
   \   0000002E   0x7086             STRB     R6,[R0, #+2]
    320              msgPtr->transID = transID;
   \   00000030   0x70C7             STRB     R7,[R0, #+3]
    321              msgPtr->dstAddrMode = dstAddrMode;
   \   00000032   0x7104             STRB     R4,[R0, #+4]
    322              msgPtr->dstAddr = dstAddr;
   \   00000034   0x80C5             STRH     R5,[R0, #+6]
    323          
    324          #if defined ( MT_AF_CB_FUNC )
    325              /* If MT has subscribed for this callback, don't send as a message. */
    326              if ( AFCB_CHECK( CB_ID_AF_REFLECT_ERROR, *(epDesc->task_id) ) )
    327              {
    328                /* Send callback if it's subscribed */
    329                MT_AfReflectError( (void *)msgPtr );
    330                /* Release the memory. */
    331                osal_msg_deallocate( (void *)msgPtr );
    332              }
    333              else
    334          #endif
    335              {
    336                /* send message through task message */
    337                osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       osal_msg_send
    338              }
    339            }
    340          }
   \                     ??afReflectError_2: (+1)
   \                     ??afReflectError_0: (+1)
   \   00000042   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    341          
    342          /*********************************************************************
    343           * @fn          afIncomingData
    344           *
    345           * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
    346           *
    347           * @param       aff  - pointer to APS frame format
    348           * @param       SrcAddress  - Source address
    349           * @param       SrcPanId  - Source PAN ID
    350           * @param       sig - incoming message's link quality
    351           * @param       nwkSeqNum - incoming network sequence number (from nwk header frame)
    352           * @param       SecurityUse - Security enable/disable
    353           * @param       timestamp - the MAC Timer2 timestamp at Rx.
    354           * @param       radius - incoming messages received radius
    355           *
    356           * @return      none
    357           */

   \                                 In section .text, align 2, keep-with-next
    358          void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress, uint16 SrcPanId,
    359                               NLDE_Signal_t *sig, uint8 nwkSeqNum, uint8 SecurityUse,
    360                               uint32 timestamp, uint8 radius )
    361          {
   \                     afIncomingData: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0007             MOVS     R7,R0
    362            endPointDesc_t *epDesc = NULL;
   \   00000008   0x2400             MOVS     R4,#+0
    363            epList_t *pList = epList;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7
   \   0000000E   0xF8D0 0x9000      LDR      R9,[R0, #+0]
    364          #if !defined ( APS_NO_GROUPS )
    365            uint8 grpEp = APS_GROUPS_EP_NOT_FOUND;
   \   00000012   0xF05F 0x08FE      MOVS     R8,#+254
    366          #endif
    367          
    368            if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
   \   00000016   0x7838             LDRB     R0,[R7, #+0]
   \   00000018   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000001C   0x280C             CMP      R0,#+12
   \   0000001E   0xD11B             BNE.N    ??afIncomingData_0
    369            {
    370          #if !defined ( APS_NO_GROUPS )
    371              // Find the first endpoint for this group
    372              grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
   \   00000020   0x21FE             MOVS     R1,#+254
   \   00000022   0x88B8             LDRH     R0,[R7, #+4]
   \   00000024   0x.... 0x....      BL       aps_FindGroupForEndpoint
   \   00000028   0x4680             MOV      R8,R0
    373              if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
   \   0000002A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002E   0xF1B8 0x0FFE      CMP      R8,#+254
   \   00000032   0xF000 0x8097      BEQ.W    ??afIncomingData_1
    374                return;   // No endpoint found
    375          
    376              epDesc = afFindEndPointDesc( grpEp );
   \                     ??afIncomingData_2: (+1)
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       afFindEndPointDesc
   \   0000003E   0x0004             MOVS     R4,R0
    377              if ( epDesc == NULL )
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xF000 0x808F      BEQ.W    ??afIncomingData_1
    378                return;   // Endpoint descriptor not found
    379          
    380              pList = afFindEndPointDescList( epDesc->endPoint );
   \                     ??afIncomingData_3: (+1)
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       afFindEndPointDescList
   \   0000004C   0x4681             MOV      R9,R0
   \                     ??afIncomingData_4: (+1)
   \   0000004E   0x9D13             LDR      R5,[SP, #+76]
   \   00000050   0xF8DD 0xA050      LDR      R10,[SP, #+80]
   \   00000054   0x9E15             LDR      R6,[SP, #+84]
   \   00000056   0xE017             B.N      ??afIncomingData_5
    381          #else
    382              return; // Not supported
    383          #endif
    384            }
    385            else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_0: (+1)
   \   00000058   0x78B8             LDRB     R0,[R7, #+2]
   \   0000005A   0x28FF             CMP      R0,#+255
   \   0000005C   0xD105             BNE.N    ??afIncomingData_6
    386            {
    387              // Set the list
    388              if ( pList != NULL )
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD0F4             BEQ.N    ??afIncomingData_4
    389              {
    390                epDesc = pList->epDesc;
   \   00000064   0xF8D9 0x4004      LDR      R4,[R9, #+4]
   \   00000068   0xE7F1             B.N      ??afIncomingData_4
    391              }
    392            }
    393            else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
   \                     ??afIncomingData_6: (+1)
   \   0000006A   0x78B8             LDRB     R0,[R7, #+2]
   \   0000006C   0x.... 0x....      BL       afFindEndPointDesc
   \   00000070   0x0004             MOVS     R4,R0
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0EB             BEQ.N    ??afIncomingData_4
    394            {
    395              pList = afFindEndPointDescList( epDesc->endPoint );
   \   00000076   0x7820             LDRB     R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       afFindEndPointDescList
   \   0000007C   0x4681             MOV      R9,R0
   \   0000007E   0xE7E6             B.N      ??afIncomingData_4
    396            }
    397          
    398            while ( epDesc )
    399            {
    400              uint16 epProfileID = 0xFFFE;  // Invalid Profile ID
    401          
    402              if ( pList->pfnDescCB )
    403              {
    404                uint16 *pID = (uint16 *)(pList->pfnDescCB(
    405                                           AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
    406                if ( pID )
    407                {
    408                  epProfileID = *pID;
    409                  osal_mem_free( pID );
    410                }
    411              }
    412              else if ( epDesc->simpleDesc )
    413              {
    414                epProfileID = epDesc->simpleDesc->AppProfId;
    415              }
    416          
    417              // First part of verification is to make sure that:
    418              // the local Endpoint ProfileID matches the received ProfileID OR
    419              // the message is specifically send to ZDO (this excludes the broadcast endpoint) OR
    420              // if the Wildcard ProfileID is received the message should not be sent to ZDO endpoint
    421              if ( (aff->ProfileID == epProfileID) ||
    422                   ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) ||
    423                   ((epDesc->endPoint != ZDO_EP) && ( aff->ProfileID == ZDO_WILDCARD_PROFILE_ID )) )
    424              {
    425                // Save original endpoint
    426                uint8 endpoint = aff->DstEndPoint;
    427          
    428                // overwrite with descriptor's endpoint
    429                aff->DstEndPoint = epDesc->endPoint;
    430          
    431                afBuildMSGIncoming( aff, epDesc, SrcAddress, SrcPanId, sig,
    432                                   nwkSeqNum, SecurityUse, timestamp, radius );
    433          
    434                // Restore with original endpoint
    435                aff->DstEndPoint = endpoint;
    436              }
    437          
    438              if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
    439              {
    440          #if !defined ( APS_NO_GROUPS )
    441                // Find the next endpoint for this group
    442                grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
    443                if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
    444                  return;   // No endpoint found
    445          
    446                epDesc = afFindEndPointDesc( grpEp );
    447                if ( epDesc == NULL )
    448                  return;   // Endpoint descriptor not found
    449          
    450                pList = afFindEndPointDescList( epDesc->endPoint );
   \                     ??afIncomingData_7: (+1)
   \   00000080   0x7820             LDRB     R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       afFindEndPointDescList
   \   00000086   0x4681             MOV      R9,R0
   \                     ??afIncomingData_5: (+1)
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD06B             BEQ.N    ??afIncomingData_8
   \   0000008C   0xF64F 0x7BFE      MOVW     R11,#+65534
   \   00000090   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00B             BEQ.N    ??afIncomingData_9
   \   00000098   0x7821             LDRB     R1,[R4, #+0]
   \   0000009A   0x2002             MOVS     R0,#+2
   \   0000009C   0xF8D9 0x2008      LDR      R2,[R9, #+8]
   \   000000A0   0x4790             BLX      R2
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD00A             BEQ.N    ??afIncomingData_10
   \   000000A6   0xF8B0 0xB000      LDRH     R11,[R0, #+0]
   \   000000AA   0x.... 0x....      BL       osal_mem_free
   \   000000AE   0xE005             B.N      ??afIncomingData_10
   \                     ??afIncomingData_9: (+1)
   \   000000B0   0x68A0             LDR      R0,[R4, #+8]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD002             BEQ.N    ??afIncomingData_10
   \   000000B6   0x68A0             LDR      R0,[R4, #+8]
   \   000000B8   0xF8B0 0xB002      LDRH     R11,[R0, #+2]
   \                     ??afIncomingData_10: (+1)
   \   000000BC   0x8938             LDRH     R0,[R7, #+8]
   \   000000BE   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000C2   0x4558             CMP      R0,R11
   \   000000C4   0xD00D             BEQ.N    ??afIncomingData_11
   \   000000C6   0x7820             LDRB     R0,[R4, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD102             BNE.N    ??afIncomingData_12
   \   000000CC   0x8938             LDRH     R0,[R7, #+8]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD007             BEQ.N    ??afIncomingData_11
   \                     ??afIncomingData_12: (+1)
   \   000000D2   0x7820             LDRB     R0,[R4, #+0]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD01E             BEQ.N    ??afIncomingData_13
   \   000000D8   0x8938             LDRH     R0,[R7, #+8]
   \   000000DA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD119             BNE.N    ??afIncomingData_13
   \                     ??afIncomingData_11: (+1)
   \   000000E2   0xF897 0xB002      LDRB     R11,[R7, #+2]
   \   000000E6   0x7820             LDRB     R0,[R4, #+0]
   \   000000E8   0x70B8             STRB     R0,[R7, #+2]
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EE   0x9004             STR      R0,[SP, #+16]
   \   000000F0   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   000000F4   0x0028             MOVS     R0,R5
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0x9002             STR      R0,[SP, #+8]
   \   000000FA   0xF89D 0x0048      LDRB     R0,[SP, #+72]
   \   000000FE   0x9001             STR      R0,[SP, #+4]
   \   00000100   0x9808             LDR      R0,[SP, #+32]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0xF8BD 0x301C      LDRH     R3,[SP, #+28]
   \   00000108   0x9A06             LDR      R2,[SP, #+24]
   \   0000010A   0x0021             MOVS     R1,R4
   \   0000010C   0x0038             MOVS     R0,R7
   \   0000010E   0x.... 0x....      BL       afBuildMSGIncoming
   \   00000112   0xF887 0xB002      STRB     R11,[R7, #+2]
   \                     ??afIncomingData_13: (+1)
   \   00000116   0x7838             LDRB     R0,[R7, #+0]
   \   00000118   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000011C   0x280C             CMP      R0,#+12
   \   0000011E   0xD112             BNE.N    ??afIncomingData_14
   \   00000120   0x4641             MOV      R1,R8
   \   00000122   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000124   0x88B8             LDRH     R0,[R7, #+4]
   \   00000126   0x.... 0x....      BL       aps_FindGroupForEndpoint
   \   0000012A   0x4680             MOV      R8,R0
   \   0000012C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000130   0xF1B8 0x0FFE      CMP      R8,#+254
   \   00000134   0xD016             BEQ.N    ??afIncomingData_1
   \                     ??afIncomingData_15: (+1)
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013A   0x.... 0x....      BL       afFindEndPointDesc
   \   0000013E   0x0004             MOVS     R4,R0
   \   00000140   0x2C00             CMP      R4,#+0
   \   00000142   0xD19D             BNE.N    ??afIncomingData_7
   \   00000144   0xE00E             B.N      ??afIncomingData_1
    451          #else
    452                return;
    453          #endif
    454              }
    455              else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_14: (+1)
   \   00000146   0x78B8             LDRB     R0,[R7, #+2]
   \   00000148   0x28FF             CMP      R0,#+255
   \   0000014A   0xD109             BNE.N    ??afIncomingData_16
    456              {
    457                pList = pList->nextDesc;
   \   0000014C   0xF8D9 0x9000      LDR      R9,[R9, #+0]
    458                if ( pList )
   \   00000150   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000154   0xD002             BEQ.N    ??afIncomingData_17
    459                  epDesc = pList->epDesc;
   \   00000156   0xF8D9 0x4004      LDR      R4,[R9, #+4]
   \   0000015A   0xE795             B.N      ??afIncomingData_5
    460                else
    461                  epDesc = NULL;
   \                     ??afIncomingData_17: (+1)
   \   0000015C   0x2400             MOVS     R4,#+0
   \   0000015E   0xE793             B.N      ??afIncomingData_5
    462              }
    463              else
    464                epDesc = NULL;
   \                     ??afIncomingData_16: (+1)
   \   00000160   0x2400             MOVS     R4,#+0
   \   00000162   0xE791             B.N      ??afIncomingData_5
    465            }
    466          }
   \                     ??afIncomingData_8: (+1)
   \                     ??afIncomingData_1: (+1)
   \   00000164   0xB009             ADD      SP,SP,#+36
   \   00000166   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    467          
    468          /*********************************************************************
    469           * @fn          afBuildMSGIncoming
    470           *
    471           * @brief       Build the message for the app
    472           *
    473           * @param
    474           *
    475           * @return      pointer to next in data buffer
    476           */

   \                                 In section .text, align 2, keep-with-next
    477          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    478                           zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
    479                           uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp, uint8 radius )
    480          {
   \                     afBuildMSGIncoming: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x4698             MOV      R8,R3
    481            afIncomingMSGPacket_t *MSGpkt;
    482            const uint8 len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
   \   0000000C   0x7D38             LDRB     R0,[R7, #+20]
   \   0000000E   0x3030             ADDS     R0,R0,#+48
    483            uint8 *asdu = aff->asdu;
   \   00000010   0x693D             LDR      R5,[R7, #+16]
    484            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x.... 0x....      BL       osal_msg_allocate
   \   0000001A   0x0006             MOVS     R6,R0
    485          
    486            if ( MSGpkt == NULL )
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD03E             BEQ.N    ??afBuildMSGIncoming_0
    487            {
    488              return;
    489            }
    490          
    491            MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
   \                     ??afBuildMSGIncoming_1: (+1)
   \   00000020   0x201A             MOVS     R0,#+26
   \   00000022   0x7030             STRB     R0,[R6, #+0]
    492            MSGpkt->groupId = aff->GroupID;
   \   00000024   0x88B8             LDRH     R0,[R7, #+4]
   \   00000026   0x8070             STRH     R0,[R6, #+2]
    493            MSGpkt->clusterId = aff->ClusterID;
   \   00000028   0x88F8             LDRH     R0,[R7, #+6]
   \   0000002A   0x80B0             STRH     R0,[R6, #+4]
    494            afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
   \   0000002C   0x4649             MOV      R1,R9
   \   0000002E   0x1DB0             ADDS     R0,R6,#+6
   \   00000030   0x.... 0x....      BL       afCopyAddress
    495            MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
   \   00000034   0x78F8             LDRB     R0,[R7, #+3]
   \   00000036   0x73F0             STRB     R0,[R6, #+15]
    496            MSGpkt->endPoint = epDesc->endPoint;
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x7530             STRB     R0,[R6, #+20]
    497            MSGpkt->wasBroadcast = aff->wasBroadcast;
   \   0000003C   0x7B38             LDRB     R0,[R7, #+12]
   \   0000003E   0x7570             STRB     R0,[R6, #+21]
   \   00000040   0x9808             LDR      R0,[SP, #+32]
    498            MSGpkt->LinkQuality = sig->LinkQuality;
   \   00000042   0x7801             LDRB     R1,[R0, #+0]
   \   00000044   0x75B1             STRB     R1,[R6, #+22]
    499            MSGpkt->correlation = sig->correlation;
   \   00000046   0x7841             LDRB     R1,[R0, #+1]
   \   00000048   0x75F1             STRB     R1,[R6, #+23]
    500            MSGpkt->rssi = sig->rssi;
   \   0000004A   0x7880             LDRB     R0,[R0, #+2]
   \   0000004C   0x7630             STRB     R0,[R6, #+24]
    501            MSGpkt->SecurityUse = SecurityUse;
   \   0000004E   0x980A             LDR      R0,[SP, #+40]
   \   00000050   0x7670             STRB     R0,[R6, #+25]
    502            MSGpkt->timestamp = timestamp;
   \   00000052   0x980B             LDR      R0,[SP, #+44]
   \   00000054   0x61F0             STR      R0,[R6, #+28]
    503            MSGpkt->nwkSeqNum = nwkSeqNum;
   \   00000056   0x9809             LDR      R0,[SP, #+36]
   \   00000058   0xF886 0x0020      STRB     R0,[R6, #+32]
    504            MSGpkt->macSrcAddr = aff->macSrcAddr;
   \   0000005C   0x8B78             LDRH     R0,[R7, #+26]
   \   0000005E   0x85B0             STRH     R0,[R6, #+44]
    505            MSGpkt->macDestAddr = aff->macDestAddr;
   \   00000060   0x8978             LDRH     R0,[R7, #+10]
   \   00000062   0x8270             STRH     R0,[R6, #+18]
    506            MSGpkt->srcAddr.panId = SrcPanId;
   \   00000064   0xF8A6 0x8010      STRH     R8,[R6, #+16]
    507            MSGpkt->cmd.TransSeqNumber = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF886 0x0024      STRB     R0,[R6, #+36]
    508            MSGpkt->cmd.DataLength = aff->asduLength;
   \   0000006E   0x7D38             LDRB     R0,[R7, #+20]
   \   00000070   0x84F0             STRH     R0,[R6, #+38]
    509            MSGpkt->radius = radius;
   \   00000072   0x980C             LDR      R0,[SP, #+48]
   \   00000074   0xF886 0x002E      STRB     R0,[R6, #+46]
    510          
    511            if ( MSGpkt->cmd.DataLength )
   \   00000078   0x8CF0             LDRH     R0,[R6, #+38]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD008             BEQ.N    ??afBuildMSGIncoming_2
    512            {
    513              MSGpkt->cmd.Data = (uint8 *)(MSGpkt + 1);
   \   0000007E   0xF116 0x0030      ADDS     R0,R6,#+48
   \   00000082   0x62B0             STR      R0,[R6, #+40]
    514              osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
   \   00000084   0x8CF2             LDRH     R2,[R6, #+38]
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0x6AB0             LDR      R0,[R6, #+40]
   \   0000008A   0x.... 0x....      BL       osal_memcpy
   \   0000008E   0xE001             B.N      ??afBuildMSGIncoming_3
    515            }
    516            else
    517            {
    518              MSGpkt->cmd.Data = NULL;
   \                     ??afBuildMSGIncoming_2: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x62B0             STR      R0,[R6, #+40]
    519            }
    520          
    521          #if defined ( MT_AF_CB_FUNC )
    522            // If ZDO or SAPI have registered for this endpoint, dont intercept it here
    523            if (AFCB_CHECK(CB_ID_AF_DATA_IND, *(epDesc->task_id)))
    524            {
    525              MT_AfIncomingMsg( (void *)MSGpkt );
    526              // Release the memory.
    527              osal_msg_deallocate( (void *)MSGpkt );
    528            }
    529            else
    530          #endif
    531            {
    532              // Send message through task message.
    533              osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
   \                     ??afBuildMSGIncoming_3: (+1)
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0x6860             LDR      R0,[R4, #+4]
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x.... 0x....      BL       osal_msg_send
    534            }
    535          }
   \                     ??afBuildMSGIncoming_0: (+1)
   \   0000009E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    536          
    537          /*********************************************************************
    538           * @fn      AF_DataRequest
    539           *
    540           * @brief   Common functionality for invoking APSDE_DataReq() for both
    541           *          SendMulti and MSG-Send.
    542           *
    543           * input parameters
    544           *
    545           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    546           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    547           * @param   cID - A valid cluster ID as specified by the Profile.
    548           * @param   len - Number of bytes of data pointed to by next param.
    549           * @param  *buf - A pointer to the data bytes to send.
    550           * @param  *transID - A pointer to a byte which can be modified and which will
    551           *                    be used as the transaction sequence number of the msg.
    552           * @param   options - Valid bit mask of Tx options.
    553           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    554           *
    555           * output parameters
    556           *
    557           * @param  *transID - Incremented by one if the return value is success.
    558           *
    559           * @return  afStatus_t - See previous definition of afStatus_... types.
    560           */

   \                                 In section .data, align 1
    561          uint8 AF_DataRequestDiscoverRoute = DISC_ROUTE_NETWORK;
   \                     AF_DataRequestDiscoverRoute:
   \   00000000   0x01               DC8 1

   \                                 In section .text, align 2, keep-with-next
    562          afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    563                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    564                                     uint8 options, uint8 radius )
    565          {
   \                     AF_DataRequest: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
    566            pDescCB pfnDescCB;
    567            ZStatus_t stat;
    568            APSDE_DataReq_t req;
    569            afDataReqMTU_t mtu;
    570            epList_t *pList;
    571          
    572            // Verify source end point
    573            if ( srcEP == NULL )
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE.N    ??AF_DataRequest_0
    574            {
    575              return afStatus_INVALID_PARAMETER;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE0F3             B.N      ??AF_DataRequest_1
    576            }
   \                     ??AF_DataRequest_0: (+1)
   \   00000016   0x9C12             LDR      R4,[SP, #+72]
    577          
    578          #if !defined( REFLECTOR )
    579            if ( dstAddr->addrMode == afAddrNotPresent )
    580            {
    581              return afStatus_INVALID_PARAMETER;
    582            }
    583          #endif
    584          
    585            // Check if route is available before sending data
    586            if ( options & AF_LIMIT_CONCENTRATOR  )
   \   00000018   0x0720             LSLS     R0,R4,#+28
   \   0000001A   0xD513             BPL.N    ??AF_DataRequest_2
    587            {
    588              if ( dstAddr->addrMode != afAddr16Bit )
   \   0000001C   0x7A28             LDRB     R0,[R5, #+8]
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD001             BEQ.N    ??AF_DataRequest_3
    589              {
    590                return ( afStatus_INVALID_PARAMETER );
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE0EB             B.N      ??AF_DataRequest_1
    591              }
    592          
    593              // First, make sure the destination is not its self, then check for an existing route.
    594              if ( (dstAddr->addr.shortAddr != NLME_GetShortAddr())
    595                  && (RTG_CheckRtStatus( dstAddr->addr.shortAddr, RT_ACTIVE, (MTO_ROUTE | NO_ROUTE_CACHE) ) != RTG_SUCCESS) )
   \                     ??AF_DataRequest_3: (+1)
   \   00000026   0x.... 0x....      BL       NLME_GetShortAddr
   \   0000002A   0x8829             LDRH     R1,[R5, #+0]
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x4281             CMP      R1,R0
   \   00000030   0xD008             BEQ.N    ??AF_DataRequest_2
   \   00000032   0x2203             MOVS     R2,#+3
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x8828             LDRH     R0,[R5, #+0]
   \   00000038   0x.... 0x....      BL       RTG_CheckRtStatus
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??AF_DataRequest_2
    596              {
    597                // A valid route to a concentrator wasn't found
    598                return ( afStatus_NO_ROUTE );
   \   00000040   0x20CD             MOVS     R0,#+205
   \   00000042   0xE0DC             B.N      ??AF_DataRequest_1
    599              }
    600            }
    601          
    602            // Validate broadcasting
    603            if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
    604                 ( dstAddr->addrMode == afAddrBroadcast )    )
   \                     ??AF_DataRequest_2: (+1)
   \   00000044   0x7A28             LDRB     R0,[R5, #+8]
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD002             BEQ.N    ??AF_DataRequest_4
   \   0000004A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000004C   0x280F             CMP      R0,#+15
   \   0000004E   0xD116             BNE.N    ??AF_DataRequest_5
    605            {
    606              // Check for valid broadcast values
    607              if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
   \                     ??AF_DataRequest_4: (+1)
   \   00000050   0x8828             LDRH     R0,[R5, #+0]
   \   00000052   0x.... 0x....      BL       NLME_IsAddressBroadcast
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00C             BEQ.N    ??AF_DataRequest_6
    608              {
    609                // Force mode to broadcast
    610                dstAddr->addrMode = afAddrBroadcast;
   \   0000005A   0x200F             MOVS     R0,#+15
   \   0000005C   0x7228             STRB     R0,[R5, #+8]
    611              }
    612              else
    613              {
    614                // Address is not a valid broadcast type
    615                if ( dstAddr->addrMode == afAddrBroadcast )
    616                {
    617                  return afStatus_INVALID_PARAMETER;
    618                }
    619              }
    620            }
    621            else if ( dstAddr->addrMode != afAddr64Bit &&
    622                      dstAddr->addrMode != afAddrGroup &&
    623                      dstAddr->addrMode != afAddrNotPresent )
    624            {
    625              return afStatus_INVALID_PARAMETER;
    626            }
    627          
    628            // Set destination address
    629            req.dstAddr.addrMode = dstAddr->addrMode;
   \                     ??AF_DataRequest_7: (+1)
   \   0000005E   0x7A28             LDRB     R0,[R5, #+8]
   \   00000060   0xF88D 0x000C      STRB     R0,[SP, #+12]
    630            if ( dstAddr->addrMode == afAddr64Bit )
   \   00000064   0x7A28             LDRB     R0,[R5, #+8]
   \   00000066   0x2803             CMP      R0,#+3
   \   00000068   0xD114             BNE.N    ??AF_DataRequest_8
    631            {
    632              osal_cpyExtAddr( req.dstAddr.addr.extAddr, dstAddr->addr.extAddr );
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0xA801             ADD      R0,SP,#+4
   \   0000006E   0x.... 0x....      BL       sAddrExtCpy
   \   00000072   0xE012             B.N      ??AF_DataRequest_9
    633            }
   \                     ??AF_DataRequest_6: (+1)
   \   00000074   0x7A28             LDRB     R0,[R5, #+8]
   \   00000076   0x280F             CMP      R0,#+15
   \   00000078   0xD1F1             BNE.N    ??AF_DataRequest_7
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xE0BF             B.N      ??AF_DataRequest_1
   \                     ??AF_DataRequest_5: (+1)
   \   0000007E   0x7A28             LDRB     R0,[R5, #+8]
   \   00000080   0x2803             CMP      R0,#+3
   \   00000082   0xD0EC             BEQ.N    ??AF_DataRequest_7
   \   00000084   0x7A28             LDRB     R0,[R5, #+8]
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD0E9             BEQ.N    ??AF_DataRequest_7
   \   0000008A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD0E6             BEQ.N    ??AF_DataRequest_7
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xE0B4             B.N      ??AF_DataRequest_1
    634            else
    635            {
    636              req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
   \                     ??AF_DataRequest_8: (+1)
   \   00000094   0x8828             LDRH     R0,[R5, #+0]
   \   00000096   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    637            }
    638          
    639            // This option is to use Wildcard ProfileID in outgoing packets
    640            if ( options & AF_WILDCARD_PROFILEID )
   \                     ??AF_DataRequest_9: (+1)
   \   0000009A   0x07A0             LSLS     R0,R4,#+30
   \   0000009C   0xD504             BPL.N    ??AF_DataRequest_10
    641            {
    642              req.profileID = ZDO_WILDCARD_PROFILE_ID;
   \   0000009E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000A2   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   \   000000A6   0xE01B             B.N      ??AF_DataRequest_11
    643            }
    644            else
    645            {
    646              req.profileID = ZDO_PROFILE_ID;
   \                     ??AF_DataRequest_10: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    647          
    648              if ( (pfnDescCB = afGetDescCB( srcEP )) )
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0x.... 0x....      BL       afGetDescCB
   \   000000B4   0x0002             MOVS     R2,R0
   \   000000B6   0x0010             MOVS     R0,R2
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD00A             BEQ.N    ??AF_DataRequest_12
    649              {
    650                uint16 *pID = (uint16 *)(pfnDescCB(
    651                                             AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
   \   000000BC   0x7831             LDRB     R1,[R6, #+0]
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x4790             BLX      R2
    652                if ( pID )
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00C             BEQ.N    ??AF_DataRequest_11
    653                {
    654                  req.profileID = *pID;
   \   000000C6   0x8801             LDRH     R1,[R0, #+0]
   \   000000C8   0xF8AD 0x1014      STRH     R1,[SP, #+20]
    655                  osal_mem_free( pID );
   \   000000CC   0x.... 0x....      BL       osal_mem_free
   \   000000D0   0xE006             B.N      ??AF_DataRequest_11
    656                }
    657              }
    658              else if ( srcEP->simpleDesc )
   \                     ??AF_DataRequest_12: (+1)
   \   000000D2   0x68B0             LDR      R0,[R6, #+8]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD003             BEQ.N    ??AF_DataRequest_11
    659              {
    660                req.profileID = srcEP->simpleDesc->AppProfId;
   \   000000D8   0x68B0             LDR      R0,[R6, #+8]
   \   000000DA   0x8840             LDRH     R0,[R0, #+2]
   \   000000DC   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    661              }
    662            }
    663          
    664            req.txOptions = 0;
   \                     ??AF_DataRequest_11: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    665          
    666            if ( ( options & AF_ACK_REQUEST              ) &&
    667                 ( req.dstAddr.addrMode != AddrBroadcast ) &&
    668                 ( req.dstAddr.addrMode != AddrGroup     )    )
   \   000000E6   0x06E0             LSLS     R0,R4,#+27
   \   000000E8   0xD50D             BPL.N    ??AF_DataRequest_13
   \   000000EA   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000EE   0x280F             CMP      R0,#+15
   \   000000F0   0xD009             BEQ.N    ??AF_DataRequest_13
   \   000000F2   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xD005             BEQ.N    ??AF_DataRequest_13
    669            {
    670              req.txOptions |=  APS_TX_OPTIONS_ACK;
   \   000000FA   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   000000FE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000102   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    671            }
    672          
    673            if ( options & AF_SKIP_ROUTING )
   \                     ??AF_DataRequest_13: (+1)
   \   00000106   0x0620             LSLS     R0,R4,#+24
   \   00000108   0xD505             BPL.N    ??AF_DataRequest_14
    674            {
    675              req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
   \   0000010A   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   0000010E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000112   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    676            }
    677          
    678            if ( options & AF_EN_SECURITY )
   \                     ??AF_DataRequest_14: (+1)
   \   00000116   0x0660             LSLS     R0,R4,#+25
   \   00000118   0xD509             BPL.N    ??AF_DataRequest_15
    679            {
    680              req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
   \   0000011A   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   0000011E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000122   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    681              mtu.aps.secure = TRUE;
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000012C   0xE002             B.N      ??AF_DataRequest_16
    682            }
    683            else
    684            {
    685              mtu.aps.secure = FALSE;
   \                     ??AF_DataRequest_15: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF88D 0x0001      STRB     R0,[SP, #+1]
    686            }
    687          
    688            if ( options & AF_PREPROCESS )
   \                     ??AF_DataRequest_16: (+1)
   \   00000134   0x0760             LSLS     R0,R4,#+29
   \   00000136   0xD505             BPL.N    ??AF_DataRequest_17
    689            {
    690              req.txOptions |=  APS_TX_OPTIONS_PREPROCESS;
   \   00000138   0xF8BD 0x001C      LDRH     R0,[SP, #+28]
   \   0000013C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000140   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    691            }
    692          
    693            mtu.kvp = FALSE;
   \                     ??AF_DataRequest_17: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xF88D 0x0000      STRB     R0,[SP, #+0]
    694          
    695            if ( options & AF_SUPRESS_ROUTE_DISC_NETWORK )
   \   0000014A   0x06A0             LSLS     R0,R4,#+26
   \   0000014C   0xD503             BPL.N    ??AF_DataRequest_18
    696            {
    697              req.discoverRoute = DISC_ROUTE_INITIATE;
   \   0000014E   0x2004             MOVS     R0,#+4
   \   00000150   0xF88D 0x001F      STRB     R0,[SP, #+31]
   \   00000154   0xE003             B.N      ??AF_DataRequest_19
    698            }
    699            else
    700            {
    701              req.discoverRoute = AF_DataRequestDiscoverRoute;
   \                     ??AF_DataRequest_18: (+1)
   \   00000156   0x....             LDR.N    R0,??DataTable7_1
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0xF88D 0x001F      STRB     R0,[SP, #+31]
   \                     ??AF_DataRequest_19: (+1)
   \   0000015E   0x9C11             LDR      R4,[SP, #+68]
    702            }
    703          
    704            req.transID       = *transID;
   \   00000160   0x7820             LDRB     R0,[R4, #+0]
   \   00000162   0xF88D 0x001E      STRB     R0,[SP, #+30]
    705            req.srcEP         = srcEP->endPoint;
   \   00000166   0x7830             LDRB     R0,[R6, #+0]
   \   00000168   0xF88D 0x000E      STRB     R0,[SP, #+14]
    706            req.dstEP         = dstAddr->endPoint;
   \   0000016C   0x7A68             LDRB     R0,[R5, #+9]
   \   0000016E   0xF88D 0x000F      STRB     R0,[SP, #+15]
    707            req.clusterID     = cID;
   \   00000172   0xF8AD 0x7012      STRH     R7,[SP, #+18]
    708            req.asduLen       = len;
   \   00000176   0xF8AD 0x8016      STRH     R8,[SP, #+22]
    709            req.asdu          = buf;
   \   0000017A   0x9810             LDR      R0,[SP, #+64]
   \   0000017C   0x9006             STR      R0,[SP, #+24]
    710            req.radiusCounter = radius;
   \   0000017E   0x9813             LDR      R0,[SP, #+76]
   \   00000180   0xF88D 0x0020      STRB     R0,[SP, #+32]
    711          #if defined ( INTER_PAN )
    712            req.dstPanId      = dstAddr->panId;
    713          #endif // INTER_PAN
    714          
    715            // Look if there is a Callback function registered for this endpoint
    716            // The callback is used to control the AF Transaction ID used when sending messages
    717            pList = afFindEndPointDescList( srcEP->endPoint );
   \   00000184   0x7830             LDRB     R0,[R6, #+0]
   \   00000186   0x.... 0x....      BL       afFindEndPointDescList
   \   0000018A   0x0001             MOVS     R1,R0
    718          
    719            if ( ( pList != NULL ) && ( pList->pfnApplCB != NULL ) )
   \   0000018C   0x2900             CMP      R1,#+0
   \   0000018E   0xD005             BEQ.N    ??AF_DataRequest_20
   \   00000190   0x6908             LDR      R0,[R1, #+16]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD002             BEQ.N    ??AF_DataRequest_20
    720            {
    721              pList->pfnApplCB( &req );
   \   00000196   0xA801             ADD      R0,SP,#+4
   \   00000198   0x6909             LDR      R1,[R1, #+16]
   \   0000019A   0x4788             BLX      R1
    722            }
    723          
    724          #if defined ( INTER_PAN )
    725            if ( StubAPS_InterPan( dstAddr->panId, dstAddr->endPoint ) )
    726            {
    727              if ( len > INTERP_DataReqMTU() )
    728              {
    729                stat = afStatus_INVALID_PARAMETER;
    730              }
    731              else
    732              {
    733                stat = INTERP_DataReq( &req );
    734              }
    735            }
    736            else
    737          #endif // INTER_PAN
    738            {
    739              if (len > afDataReqMTU( &mtu ) )
   \                     ??AF_DataRequest_20: (+1)
   \   0000019C   0xA800             ADD      R0,SP,#+0
   \   0000019E   0x.... 0x....      BL       afDataReqMTU
   \   000001A2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001A4   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000001A8   0x4540             CMP      R0,R8
   \   000001AA   0xD20B             BCS.N    ??AF_DataRequest_21
    740              {
    741                if (apsfSendFragmented)
   \   000001AC   0x....             LDR.N    R0,??DataTable7_2
   \   000001AE   0x6800             LDR      R0,[R0, #+0]
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD005             BEQ.N    ??AF_DataRequest_22
    742                {
    743                  stat = (*apsfSendFragmented)( &req );
   \   000001B4   0xA801             ADD      R0,SP,#+4
   \   000001B6   0x....             LDR.N    R1,??DataTable7_2
   \   000001B8   0x6809             LDR      R1,[R1, #+0]
   \   000001BA   0x4788             BLX      R1
   \   000001BC   0x0005             MOVS     R5,R0
   \   000001BE   0xE005             B.N      ??AF_DataRequest_23
    744                }
    745                else
    746                {
    747                  stat = afStatus_INVALID_PARAMETER;
   \                     ??AF_DataRequest_22: (+1)
   \   000001C0   0x2502             MOVS     R5,#+2
   \   000001C2   0xE003             B.N      ??AF_DataRequest_23
    748                }
    749              }
    750              else
    751              {
    752                stat = APSDE_DataReq( &req );
   \                     ??AF_DataRequest_21: (+1)
   \   000001C4   0xA801             ADD      R0,SP,#+4
   \   000001C6   0x.... 0x....      BL       APSDE_DataReq
   \   000001CA   0x0005             MOVS     R5,R0
    753              }
    754            }
    755          
    756            /*
    757             * If this is an EndPoint-to-EndPoint message on the same device, it will not
    758             * get added to the NWK databufs. So it will not go OTA and it will not get
    759             * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
    760             * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
    761             * message with the first in line TransSeqNumber, even on a multi message.
    762             * Also note that a reflected msg will not have its confirmation generated
    763             * here.
    764             */
    765            if ( (req.dstAddr.addrMode == Addr16Bit) &&
    766                 (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
   \                     ??AF_DataRequest_23: (+1)
   \   000001CC   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000001D0   0x2802             CMP      R0,#+2
   \   000001D2   0xD10C             BNE.N    ??AF_DataRequest_24
   \   000001D4   0x.... 0x....      BL       NLME_GetShortAddr
   \   000001D8   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000001DC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001DE   0x4281             CMP      R1,R0
   \   000001E0   0xD105             BNE.N    ??AF_DataRequest_24
    767            {
    768              afDataConfirm( srcEP->endPoint, *transID, stat );
   \   000001E2   0x002A             MOVS     R2,R5
   \   000001E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001E6   0x7821             LDRB     R1,[R4, #+0]
   \   000001E8   0x7830             LDRB     R0,[R6, #+0]
   \   000001EA   0x.... 0x....      BL       afDataConfirm
    769            }
    770          
    771            if ( stat == afStatus_SUCCESS )
   \                     ??AF_DataRequest_24: (+1)
   \   000001EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001F0   0x2D00             CMP      R5,#+0
   \   000001F2   0xD102             BNE.N    ??AF_DataRequest_25
    772            {
    773              (*transID)++;
   \   000001F4   0x7820             LDRB     R0,[R4, #+0]
   \   000001F6   0x1C40             ADDS     R0,R0,#+1
   \   000001F8   0x7020             STRB     R0,[R4, #+0]
    774            }
    775          
    776            return (afStatus_t)stat;
   \                     ??AF_DataRequest_25: (+1)
   \   000001FA   0x0028             MOVS     R0,R5
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??AF_DataRequest_1: (+1)
   \   000001FE   0xB00A             ADD      SP,SP,#+40
   \   00000200   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    777          }
    778          
    779          #if defined ( ZIGBEE_SOURCE_ROUTING )
    780          /*********************************************************************
    781           * @fn      AF_DataRequestSrcRtg
    782           *
    783           * @brief   Common functionality for invoking APSDE_DataReq() for both
    784           *          SendMulti and MSG-Send.
    785           *
    786           * input parameters
    787           *
    788           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    789           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    790           * @param   cID - A valid cluster ID as specified by the Profile.
    791           * @param   len - Number of bytes of data pointed to by next param.
    792           * @param  *buf - A pointer to the data bytes to send.
    793           * @param  *transID - A pointer to a byte which can be modified and which will
    794           *                    be used as the transaction sequence number of the msg.
    795           * @param   options - Valid bit mask of Tx options.
    796           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    797           * @param   relayCnt - Number of devices in the relay list
    798           * @param   pRelayList - Pointer to the relay list
    799           *
    800           * output parameters
    801           *
    802           * @param  *transID - Incremented by one if the return value is success.
    803           *
    804           * @return  afStatus_t - See previous definition of afStatus_... types.
    805           */
    806          

   \                                 In section .text, align 2, keep-with-next
    807          afStatus_t AF_DataRequestSrcRtg( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    808                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    809                                     uint8 options, uint8 radius, uint8 relayCnt, uint16* pRelayList )
    810          {
   \                     AF_DataRequestSrcRtg: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    811            uint8 status;
    812          
    813            /* Add the source route to the source routing table */
    814            status = RTG_AddSrcRtgEntry_Guaranteed( dstAddr->addr.shortAddr, relayCnt,
    815                                                   pRelayList );
   \   0000000C   0x9A0F             LDR      R2,[SP, #+60]
   \   0000000E   0x990E             LDR      R1,[SP, #+56]
   \   00000010   0x8820             LDRH     R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       RTG_AddSrcRtgEntry_Guaranteed
    816          
    817            if( status == RTG_SUCCESS)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD110             BNE.N    ??AF_DataRequestSrcRtg_0
    818            {
    819              /* Call AF_DataRequest to send the data */
    820              status = AF_DataRequest( dstAddr, srcEP, cID, len, buf, transID, options, radius );
   \   0000001C   0x980D             LDR      R0,[SP, #+52]
   \   0000001E   0x9003             STR      R0,[SP, #+12]
   \   00000020   0x980C             LDR      R0,[SP, #+48]
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0x980B             LDR      R0,[SP, #+44]
   \   00000026   0x9001             STR      R0,[SP, #+4]
   \   00000028   0x980A             LDR      R0,[SP, #+40]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x003B             MOVS     R3,R7
   \   0000002E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000030   0x0032             MOVS     R2,R6
   \   00000032   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       AF_DataRequest
   \   0000003C   0xE005             B.N      ??AF_DataRequestSrcRtg_1
    821            }
    822            else if( status == RTG_INVALID_PATH )
   \                     ??AF_DataRequestSrcRtg_0: (+1)
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x2805             CMP      R0,#+5
   \   00000042   0xD101             BNE.N    ??AF_DataRequestSrcRtg_2
    823            {
    824              /* The source route relay count is exceeding the network limit */
    825              status = afStatus_INVALID_PARAMETER;
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xE000             B.N      ??AF_DataRequestSrcRtg_1
    826            }
    827            else
    828            {
    829              /* The guaranteed adding entry fails due to memory failure */
    830              status = afStatus_MEM_FAIL;
   \                     ??AF_DataRequestSrcRtg_2: (+1)
   \   00000048   0x2010             MOVS     R0,#+16
    831            }
    832            return status;
   \                     ??AF_DataRequestSrcRtg_1: (+1)
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xB005             ADD      SP,SP,#+20
   \   0000004E   0xBDF0             POP      {R4-R7,PC}       ;; return
    833          }
    834          
    835          #endif
    836          
    837          /*********************************************************************
    838           * @fn      afFindEndPointDescList
    839           *
    840           * @brief   Find the endpoint description entry from the endpoint
    841           *          number.
    842           *
    843           * @param   EndPoint - Application Endpoint to look for
    844           *
    845           * @return  the address to the endpoint/interface description entry
    846           */

   \                                 In section .text, align 2, keep-with-next
    847          static epList_t *afFindEndPointDescList( uint8 EndPoint )
    848          {
    849            epList_t *epSearch;
    850          
    851            for (epSearch = epList; epSearch != NULL; epSearch = epSearch->nextDesc)
   \                     afFindEndPointDescList: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xE000             B.N      ??afFindEndPointDescList_0
   \                     ??afFindEndPointDescList_1: (+1)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \                     ??afFindEndPointDescList_0: (+1)
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??afFindEndPointDescList_2
    852            {
    853              if (epSearch->epDesc->endPoint == EndPoint)
   \   0000000C   0x684A             LDR      R2,[R1, #+4]
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4282             CMP      R2,R0
   \   00000014   0xD1F7             BNE.N    ??afFindEndPointDescList_1
    854              {
    855                break;
    856              }
    857            }
    858          
    859            return epSearch;
   \                     ??afFindEndPointDescList_2: (+1)
   \   00000016   0x0008             MOVS     R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    860          }
    861          
    862          /*********************************************************************
    863           * @fn      afFindEndPointDesc
    864           *
    865           * @brief   Find the endpoint description entry from the endpoint
    866           *          number.
    867           *
    868           * @param   EndPoint - Application Endpoint to look for
    869           *
    870           * @return  the address to the endpoint/interface description entry
    871           */

   \                                 In section .text, align 2, keep-with-next
    872          endPointDesc_t *afFindEndPointDesc( uint8 EndPoint )
    873          {
   \                     afFindEndPointDesc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    874            epList_t *epSearch;
    875          
    876            // Look for the endpoint
    877            epSearch = afFindEndPointDescList( EndPoint );
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x.... 0x....      BL       afFindEndPointDescList
    878          
    879            if ( epSearch )
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??afFindEndPointDesc_0
    880              return ( epSearch->epDesc );
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0xE000             B.N      ??afFindEndPointDesc_1
    881            else
    882              return ( (endPointDesc_t *)NULL );
   \                     ??afFindEndPointDesc_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??afFindEndPointDesc_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    883          }
    884          
    885          /*********************************************************************
    886           * @fn      afFindSimpleDesc
    887           *
    888           * @brief   Find the Simple Descriptor from the endpoint number.
    889           *
    890           * @param   EP - Application Endpoint to look for.
    891           *
    892           * @return  Non-zero to indicate that the descriptor memory must be freed.
    893           */

   \                                 In section .text, align 2, keep-with-next
    894          uint8 afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, uint8 EP )
    895          {
   \                     afFindSimpleDesc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    896            epList_t *epItem = afFindEndPointDescList( EP );
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       afFindEndPointDescList
   \   0000000E   0x0002             MOVS     R2,R0
    897            uint8 rtrn = FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
    898          
    899            if ( epItem )
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD00E             BEQ.N    ??afFindSimpleDesc_0
    900            {
    901              if ( epItem->pfnDescCB )
   \   00000016   0x6891             LDR      R1,[R2, #+8]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD007             BEQ.N    ??afFindSimpleDesc_1
    902              {
    903                *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x6892             LDR      R2,[R2, #+8]
   \   00000024   0x4790             BLX      R2
   \   00000026   0x6020             STR      R0,[R4, #+0]
    904                rtrn = TRUE;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE005             B.N      ??afFindSimpleDesc_2
    905              }
    906              else
    907              {
    908                *ppDesc = epItem->epDesc->simpleDesc;
   \                     ??afFindSimpleDesc_1: (+1)
   \   0000002C   0x6851             LDR      R1,[R2, #+4]
   \   0000002E   0x6889             LDR      R1,[R1, #+8]
   \   00000030   0x6021             STR      R1,[R4, #+0]
   \   00000032   0xE001             B.N      ??afFindSimpleDesc_2
    909              }
    910            }
    911            else
    912            {
    913              *ppDesc = NULL;
   \                     ??afFindSimpleDesc_0: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6021             STR      R1,[R4, #+0]
    914            }
    915          
    916            return rtrn;
   \                     ??afFindSimpleDesc_2: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    917          }
    918          
    919          /*********************************************************************
    920           * @fn      afGetDescCB
    921           *
    922           * @brief   Get the Descriptor callback function.
    923           *
    924           * @param   epDesc - pointer to the endpoint descriptor
    925           *
    926           * @return  function pointer or NULL
    927           */

   \                                 In section .text, align 2, keep-with-next
    928          static pDescCB afGetDescCB( endPointDesc_t *epDesc )
    929          {
    930            epList_t *epSearch;
    931          
    932            // Start at the beginning
    933            epSearch = epList;
   \                     afGetDescCB: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xE000             B.N      ??afGetDescCB_0
    934          
    935            // Look through the list until the end
    936            while ( epSearch )
    937            {
    938              // Is there a match?
    939              if ( epSearch->epDesc == epDesc )
    940              {
    941                return ( epSearch->pfnDescCB );
    942              }
    943              else
    944                epSearch = epSearch->nextDesc;  // Next entry
   \                     ??afGetDescCB_1: (+1)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \                     ??afGetDescCB_0: (+1)
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??afGetDescCB_2
   \   0000000C   0x684A             LDR      R2,[R1, #+4]
   \   0000000E   0x4282             CMP      R2,R0
   \   00000010   0xD1F9             BNE.N    ??afGetDescCB_1
   \   00000012   0x6888             LDR      R0,[R1, #+8]
   \   00000014   0xE000             B.N      ??afGetDescCB_3
    945            }
    946          
    947            return ( (pDescCB)NULL );
   \                     ??afGetDescCB_2: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??afGetDescCB_3: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    948          }
    949          
    950          /*********************************************************************
    951           * @fn      afDataReqMTU
    952           *
    953           * @brief   Get the Data Request MTU(Max Transport Unit).
    954           *
    955           * @param   fields - afDataReqMTU_t
    956           *
    957           * @return  uint8(MTU)
    958           */

   \                                 In section .text, align 2, keep-with-next
    959          uint8 afDataReqMTU( afDataReqMTU_t* fields )
    960          {
   \                     afDataReqMTU: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    961            uint8 len;
    962            uint8 hdr;
    963          
    964            if ( fields->kvp == TRUE )
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??afDataReqMTU_0
    965            {
    966              hdr = AF_HDR_KVP_MAX_LEN;
   \   00000008   0x2408             MOVS     R4,#+8
   \   0000000A   0xE000             B.N      ??afDataReqMTU_1
    967            }
    968            else
    969            {
    970              hdr = AF_HDR_V1_1_MAX_LEN;
   \                     ??afDataReqMTU_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
    971            }
    972          
    973            len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
   \                     ??afDataReqMTU_1: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x.... 0x....      BL       APSDE_DataReqMTU
   \   00000014   0x1B00             SUBS     R0,R0,R4
    974          
    975            return len;
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    976          }
    977          
    978          /*********************************************************************
    979           * @fn      afGetMatch
    980           *
    981           * @brief   Set the allow response flag.
    982           *
    983           * @param   ep - Application Endpoint to look for
    984           * @param   action - true - allow response, false - no response
    985           *
    986           * @return  TRUE allow responses, FALSE no response
    987           */

   \                                 In section .text, align 2, keep-with-next
    988          uint8 afGetMatch( uint8 ep )
    989          {
   \                     afGetMatch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    990            epList_t *epSearch;
    991          
    992            // Look for the endpoint
    993            epSearch = afFindEndPointDescList( ep );
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x.... 0x....      BL       afFindEndPointDescList
    994          
    995            if ( epSearch )
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??afGetMatch_0
    996            {
    997              if ( epSearch->flags & eEP_AllowMatch )
   \   0000000C   0x7B80             LDRB     R0,[R0, #+14]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD501             BPL.N    ??afGetMatch_1
    998                return ( TRUE );
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE002             B.N      ??afGetMatch_2
    999              else
   1000                return ( FALSE );
   \                     ??afGetMatch_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B.N      ??afGetMatch_2
   1001            }
   1002            else
   1003              return ( FALSE );
   \                     ??afGetMatch_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??afGetMatch_2: (+1)
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   1004          }
   1005          
   1006          /*********************************************************************
   1007           * @fn      afSetMatch
   1008           *
   1009           * @brief   Set the allow response flag.
   1010           *
   1011           * @param   ep - Application Endpoint to look for
   1012           * @param   action - true - allow response, false - no response
   1013           *
   1014           * @return  TRUE if success, FALSE if endpoint not found
   1015           */

   \                                 In section .text, align 2, keep-with-next
   1016          uint8 afSetMatch( uint8 ep, uint8 action )
   1017          {
   \                     afSetMatch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1018            epList_t *epSearch;
   1019          
   1020            // Look for the endpoint
   1021            epSearch = afFindEndPointDescList( ep );
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   1022          
   1023            if ( epSearch )
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00D             BEQ.N    ??afSetMatch_0
   1024            {
   1025              if ( action )
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??afSetMatch_1
   1026              {
   1027                epSearch->flags |= eEP_AllowMatch;
   \   00000014   0x7B81             LDRB     R1,[R0, #+14]
   \   00000016   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000001A   0x7381             STRB     R1,[R0, #+14]
   \   0000001C   0xE003             B.N      ??afSetMatch_2
   1028              }
   1029              else
   1030              {
   1031                epSearch->flags &= (eEP_AllowMatch ^ 0xFFFF);
   \                     ??afSetMatch_1: (+1)
   \   0000001E   0x7B81             LDRB     R1,[R0, #+14]
   \   00000020   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \   00000024   0x7381             STRB     R1,[R0, #+14]
   1032              }
   1033              return ( TRUE );
   \                     ??afSetMatch_2: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE000             B.N      ??afSetMatch_3
   1034            }
   1035            else
   1036              return ( FALSE );
   \                     ??afSetMatch_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??afSetMatch_3: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1037          }
   1038          
   1039          /*********************************************************************
   1040           * @fn      afNumEndPoints
   1041           *
   1042           * @brief   Returns the number of endpoints defined (including 0)
   1043           *
   1044           * @param   none
   1045           *
   1046           * @return  number of endpoints
   1047           */

   \                                 In section .text, align 2, keep-with-next
   1048          uint8 afNumEndPoints( void )
   1049          {
   1050            epList_t *epSearch;
   1051            uint8 endpoints;
   1052          
   1053            // Start at the beginning
   1054            epSearch = epList;
   \                     afNumEndPoints: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   1055            endpoints = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xE001             B.N      ??afNumEndPoints_0
   1056          
   1057            while ( epSearch )
   1058            {
   1059              endpoints++;
   \                     ??afNumEndPoints_1: (+1)
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   1060              epSearch = epSearch->nextDesc;
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   1061            }
   \                     ??afNumEndPoints_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD1FB             BNE.N    ??afNumEndPoints_1
   1062          
   1063            return ( endpoints );
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
   1064          }
   1065          
   1066          /*********************************************************************
   1067           * @fn      afEndPoints
   1068           *
   1069           * @brief   Fills in the passed in buffer with the endpoint (numbers).
   1070           *          Use afNumEndPoints to find out how big a buffer to supply.
   1071           *
   1072           * @param   epBuf - pointer to mem used
   1073           *
   1074           * @return  void
   1075           */

   \                                 In section .text, align 2, keep-with-next
   1076          void afEndPoints( uint8 *epBuf, uint8 skipZDO )
   1077          {
   1078            epList_t *epSearch;
   1079            uint8 endPoint;
   1080          
   1081            // Start at the beginning
   1082            epSearch = epList;
   \                     afEndPoints: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xE00A             B.N      ??afEndPoints_0
   1083          
   1084            while ( epSearch )
   1085            {
   1086              endPoint = epSearch->epDesc->endPoint;
   \                     ??afEndPoints_1: (+1)
   \   00000006   0x6853             LDR      R3,[R2, #+4]
   \   00000008   0x781B             LDRB     R3,[R3, #+0]
   1087          
   1088              if ( !skipZDO || endPoint != 0 )
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD002             BEQ.N    ??afEndPoints_2
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD001             BEQ.N    ??afEndPoints_3
   1089                *epBuf++ = endPoint;
   \                     ??afEndPoints_2: (+1)
   \   00000016   0x7003             STRB     R3,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   1090          
   1091              epSearch = epSearch->nextDesc;
   \                     ??afEndPoints_3: (+1)
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   1092            }
   \                     ??afEndPoints_0: (+1)
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD1F2             BNE.N    ??afEndPoints_1
   1093          }
   \   00000020   0x4770             BX       LR               ;; return
   1094          
   1095          /*********************************************************************
   1096           * @fn      afCopyAddress
   1097           *
   1098           * @brief   Fills in the passed in afAddrType_t parameter with the corresponding information
   1099           *          from the zAddrType_t parameter.
   1100           *
   1101           * @param   epBuf - pointer to mem used
   1102           *
   1103           * @return  void
   1104           */

   \                                 In section .text, align 2, keep-with-next
   1105          void afCopyAddress( afAddrType_t *afAddr, zAddrType_t *zAddr )
   1106          {
   \                     afCopyAddress: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1107            afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
   \   00000004   0x7A08             LDRB     R0,[R1, #+8]
   \   00000006   0x7220             STRB     R0,[R4, #+8]
   1108            if ( zAddr->addrMode == Addr64Bit )
   \   00000008   0x7A08             LDRB     R0,[R1, #+8]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD103             BNE.N    ??afCopyAddress_0
   1109            {
   1110              (void)osal_cpyExtAddr( afAddr->addr.extAddr, zAddr->addr.extAddr );
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       sAddrExtCpy
   \   00000014   0xE001             B.N      ??afCopyAddress_1
   1111            }
   1112            else
   1113            {
   1114              afAddr->addr.shortAddr = zAddr->addr.shortAddr;
   \                     ??afCopyAddress_0: (+1)
   \   00000016   0x8808             LDRH     R0,[R1, #+0]
   \   00000018   0x8020             STRH     R0,[R4, #+0]
   1115            }
   1116          
   1117            // Since zAddrType_t has no INTER-PAN information, set the panId member to zero.
   1118            afAddr->panId = 0;
   \                     ??afCopyAddress_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x8160             STRH     R0,[R4, #+10]
   1119          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1120          
   1121          /**************************************************************************************************
   1122           * @fn          afAPSF_ConfigGet
   1123           *
   1124           * @brief       This function ascertains the fragmentation configuration that corresponds to
   1125           *              the specified EndPoint.
   1126           *
   1127           * input parameters
   1128           *
   1129           * @param       endPoint - The source EP of a Tx or destination EP of a Rx fragmented message.
   1130           *
   1131           * output parameters
   1132           *
   1133           * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
   1134           *
   1135           * @return      None.
   1136           */

   \                                 In section .text, align 2, keep-with-next
   1137          void afAPSF_ConfigGet(uint8 endPoint, afAPSF_Config_t *pCfg)
   1138          {
   \                     afAPSF_ConfigGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1139            epList_t *pList = afFindEndPointDescList(endPoint);
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   1140          
   1141            if (pList == NULL)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??afAPSF_ConfigGet_0
   1142            {
   1143              pCfg->frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
   \   0000000E   0x2032             MOVS     R0,#+50
   \   00000010   0x7020             STRB     R0,[R4, #+0]
   1144              pCfg->windowSize = APSF_DEFAULT_WINDOW_SIZE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7060             STRB     R0,[R4, #+1]
   \   00000016   0xE005             B.N      ??afAPSF_ConfigGet_1
   1145            }
   1146            else
   1147            {
   1148              (void)osal_memcpy(pCfg, &pList->apsfCfg, sizeof(afAPSF_Config_t));
   \                     ??afAPSF_ConfigGet_0: (+1)
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0xF110 0x010C      ADDS     R1,R0,#+12
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       osal_memcpy
   1149            }
   1150          }
   \                     ??afAPSF_ConfigGet_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1151          
   1152          /**************************************************************************************************
   1153           * @fn          afAPSF_ConfigSet
   1154           *
   1155           * @brief       This function attempts to set the fragmentation configuration that corresponds to
   1156           *              the specified EndPoint.
   1157           *
   1158           * input parameters
   1159           *
   1160           * @param       endPoint - The specific EndPoint for which to set the fragmentation configuration.
   1161           * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
   1162           *
   1163           * output parameters
   1164           *
   1165           * None.
   1166           *
   1167           * @return      afStatus_SUCCESS for success.
   1168           *              afStatus_INVALID_PARAMETER if the specified EndPoint is not registered.
   1169           */

   \                                 In section .text, align 2, keep-with-next
   1170          afStatus_t afAPSF_ConfigSet(uint8 endPoint, afAPSF_Config_t *pCfg)
   1171          {
   \                     afAPSF_ConfigSet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1172            epList_t *pList = afFindEndPointDescList(endPoint);
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       afFindEndPointDescList
   1173          
   1174            if (pList == NULL)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??afAPSF_ConfigSet_0
   1175            {
   1176              return afStatus_INVALID_PARAMETER;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE005             B.N      ??afAPSF_ConfigSet_1
   1177            }
   1178          
   1179            (void)osal_memcpy(&pList->apsfCfg, pCfg, sizeof(afAPSF_Config_t));
   \                     ??afAPSF_ConfigSet_0: (+1)
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x300C             ADDS     R0,R0,#+12
   \   00000018   0x.... 0x....      BL       osal_memcpy
   1180            return afStatus_SUCCESS;
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??afAPSF_ConfigSet_1: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1181          }
   1182          
   1183          /**************************************************************************************************
   1184           * @fn          afSetApplCB
   1185           *
   1186           * @brief       Sets the pointer to the Application Callback function for a
   1187           *              specific EndPoint.
   1188           *
   1189           * input parameters
   1190           *
   1191           * @param       endPoint - The specific EndPoint for which to set Application Callback.
   1192           * @param       pApplFn - A pointer to the Application Callback function.
   1193           *
   1194           * output parameters
   1195           *
   1196           * None.
   1197           *
   1198           * @return      TRUE if success, FALSE if endpoint not found
   1199           */

   \                                 In section .text, align 2, keep-with-next
   1200          uint8 afSetApplCB( uint8 endPoint, pApplCB pApplFn )
   1201          {
   \                     afSetApplCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1202            if ( pApplFn != NULL )
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD007             BEQ.N    ??afSetApplCB_0
   1203            {
   1204              epList_t *epSearch;
   1205          
   1206              // Look for the endpoint
   1207              epSearch = afFindEndPointDescList( endPoint );
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       afFindEndPointDescList
   1208          
   1209              if ( epSearch )
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??afSetApplCB_0
   1210              {
   1211                epSearch->pfnApplCB = pApplFn;
   \   00000014   0x6104             STR      R4,[R0, #+16]
   1212          
   1213                return ( TRUE );
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??afSetApplCB_1
   1214              }
   1215            }
   1216          
   1217            return ( FALSE );
   \                     ??afSetApplCB_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??afSetApplCB_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1218          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     epList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     AF_DataRequestDiscoverRoute

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     apsfSendFragmented
   1219          
   1220          /**************************************************************************************************
   1221          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   AF_DataRequest
        64   -- Indirect call
        64   -> APSDE_DataReq
        64   -> NLME_GetShortAddr
        64   -> NLME_IsAddressBroadcast
        64   -> RTG_CheckRtStatus
        64   -> afDataConfirm
        64   -> afDataReqMTU
        64   -> afFindEndPointDescList
        64   -> afGetDescCB
        64   -> osal_mem_free
        64   -> sAddrExtCpy
      40   AF_DataRequestSrcRtg
        40   -> AF_DataRequest
        40   -> RTG_AddSrcRtgEntry_Guaranteed
       8   afAPSF_ConfigGet
         8   -> afFindEndPointDescList
         8   -> osal_memcpy
       8   afAPSF_ConfigSet
         8   -> afFindEndPointDescList
         8   -> osal_memcpy
      32   afBuildMSGIncoming
        32   -> afCopyAddress
        32   -> osal_memcpy
        32   -> osal_msg_allocate
        32   -> osal_msg_send
       8   afCopyAddress
         8   -> sAddrExtCpy
      24   afDataConfirm
        24   -> afFindEndPointDesc
        24   -> osal_msg_allocate
        24   -> osal_msg_send
       8   afDataReqMTU
         8   -> APSDE_DataReqMTU
       8   afDelete
         8   -> osal_mem_free
       0   afEndPoints
       8   afFindEndPointDesc
         8   -> afFindEndPointDescList
       0   afFindEndPointDescList
      16   afFindSimpleDesc
        16   -- Indirect call
        16   -> afFindEndPointDescList
       0   afGetDescCB
       8   afGetMatch
         8   -> afFindEndPointDescList
      72   afIncomingData
        72   -- Indirect call
        72   -> afBuildMSGIncoming
        72   -> afFindEndPointDesc
        72   -> afFindEndPointDescList
        72   -> aps_FindGroupForEndpoint
        72   -> osal_mem_free
       0   afNumEndPoints
      24   afReflectError
        24   -> afFindEndPointDesc
        24   -> osal_msg_allocate
        24   -> osal_msg_send
       8   afRegister
         8   -> afFindEndPointDescList
         8   -> afRegisterExtended
      16   afRegisterExtended
        16   -> osal_mem_alloc
       8   afSetApplCB
         8   -> afFindEndPointDescList
       8   afSetMatch
         8   -> afFindEndPointDescList


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
     516  AF_DataRequest
       1  AF_DataRequestDiscoverRoute
      80  AF_DataRequestSrcRtg
      38  afAPSF_ConfigGet
      32  afAPSF_ConfigSet
     162  afBuildMSGIncoming
      32  afCopyAddress
      54  afDataConfirm
      26  afDataReqMTU
      92  afDelete
      34  afEndPoints
      20  afFindEndPointDesc
      26  afFindEndPointDescList
      60  afFindSimpleDesc
      26  afGetDescCB
      30  afGetMatch
     362  afIncomingData
      20  afNumEndPoints
      70  afReflectError
      42  afRegister
      52  afRegisterExtended
      30  afSetApplCB
      46  afSetMatch
       4  epList

 
     4 bytes in section .bss
     1 byte  in section .data
 1 862 bytes in section .text
 
 1 862 bytes of CODE memory
     5 bytes of DATA memory

Errors: none
Warnings: none
