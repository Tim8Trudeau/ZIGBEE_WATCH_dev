###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        12/Apr/2015  15:43:32
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\MT_SYS.c
#    Command line =  
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\MT_SYS.c" -D
#        FEATURE_RESET_MACRO -D ewarm -D NWK_AUTO_POLL -D xPOWER_SAVING -D
#        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=YES
#        -D CC2538_USE_ALTERNATE_INTERRUPT_MAP=1 --preprocess=cl
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lC
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\ -lB
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\
#        --diag_suppress Pa082 -o
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100
#        -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440) -f
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\f8wEndev.cfg
#        (-DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -e
#        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\..\Source\ -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\ZMain\TI2538DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\hal\target\CC2538\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\driverlib\cc2538\inc\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\driverlib\cc2538\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\bsp\srf06eb_cc2538\drivers\source\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\high_level\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf05\single_chip\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf05\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\osal\include\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0\Components\services\sdata\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\af\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\nwk\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sapi\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sec\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\sys\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\stack\zdo\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\zmac\f8w\" -Ol
#    List file    =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\List\MT_SYS.lst
#    Object file  =  
#        C:\Users\TimT\Documents\SandBox\ZIGBEE_WATCH_dev\Debug\Obj\MT_SYS.o
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Components\mt\MT_SYS.c
      1          /******************************************************************************
      2            Filename:       MT_SYS.c
      3            Revised:        $Date: 2014-08-04 15:38:03 -0700 (Mon, 04 Aug 2014) $
      4            Revision:       $Revision: 39653 $
      5          
      6            Description:   MonitorTest functions for SYS commands.
      7          
      8            Copyright 2007-2014 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License"). You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product. Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38           *****************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "MT.h"
     45          #include "MT_SYS.h"
     46          #include "MT_VERSION.h"
     47          #include "OSAL.h"
     48          #include "OSAL_NV.h"
     49          #include "Onboard.h"  /* This is here because RAM read/write macros need it */
     50          #include "hal_adc.h"
     51          #include "OSAL_Clock.h"
     52          #include "mac_low_level.h"
     53          #include "ZMAC.h"
     54          #include "mac_radio_defs.h"
     55          #if defined ( MT_SYS_JAMMER_FEATURE )
     56            #include "mac_rx.h"
     57          #endif
     58          #if !defined(CC253X_MACNP)
     59            #include "ZGlobals.h"
     60          #endif
     61          #if (defined INCLUDE_REVISION_INFORMATION) && ((defined MAKE_CRC_SHDW) || (defined FAKE_CRC_SHDW)) //built for bootloader
     62            #include "hal_flash.h"
     63            #include "sb_shared.h"
     64          #endif
     65          #include "ZDiags.h"
     66          #include "MT_UART.h"
     67          
     68          /***************************************************************************************************
     69           * MACROS
     70           ***************************************************************************************************/
     71          
     72          /* Max possible MT response length, limited by TX buffer size and sizeof uint8 */
     73          #define MT_MAX_RSP_LEN  ( MIN( MT_UART_DEFAULT_MAX_TX_BUFF, 255 ) )
     74          
     75          /* Max possible MT response data length, MT protocol overhead */
     76          #define MT_MAX_RSP_DATA_LEN  ( (MT_MAX_RSP_LEN - 1) - SPI_0DATA_MSG_LEN )
     77            
     78          #define MT_SYS_DEVICE_INFO_RESPONSE_LEN 14
     79          
     80          #if !defined HAL_GPIO || !HAL_GPIO
     81          #define GPIO_DIR_IN(IDX)
     82          #define GPIO_DIR_OUT(IDX)
     83          #define GPIO_TRI(IDX)
     84          #define GPIO_PULL_UP(IDX)
     85          #define GPIO_PULL_DN(IDX)
     86          #define GPIO_SET(IDX)
     87          #define GPIO_CLR(IDX)
     88          #define GPIO_TOG(IDX)
     89          #define GPIO_GET(IDX) 0
     90          #define GPIO_HiD_SET() (val = 0)
     91          #define GPIO_HiD_CLR() (val = 0)
     92          #endif
     93          
     94          #if defined ( MT_SYS_SNIFFER_FEATURE )
     95          #if defined ( HAL_MCU_CC2530 ) && !defined ( HAL_BOARD_CC2530USB )
     96            // This only work with the CC253x chips
     97            #define HAL_BOARD_ENABLE_INTEGRATED_SNIFFER() st         \
     98            (                                                                                                                                                                                                                                   \
     99              OBSSEL3 = 0xFD;                                        \
    100              OBSSEL4 = 0xFC;                                        \
    101              RFC_OBS_CTRL1 = 0x09; /* 9 - sniff clk */              \
    102              RFC_OBS_CTRL2 = 0x08; /* 8 - sniff data */             \
    103              MDMTEST1 |= 0x04;                                      \
    104            )
    105          
    106            // This only work with the CC253x chips
    107            #define HAL_BOARD_DISABLE_INTEGRATED_SNIFFER() st        \
    108            (                                                                                                                                                                                                                                   \
    109              OBSSEL3 &= ~0x80;                                                                                                                                                                             \
    110              OBSSEL4 &= ~0x80;                                                                                                                                                                             \
    111              RFC_OBS_CTRL1 = 0x00; /* 0 - constant value 0 to rfc_obs_sigs[1] */                                                                                   \
    112              RFC_OBS_CTRL2 = 0x00; /* 0 - constant value 0 to rfc_obs_sigs[2] */                                                                                   \
    113              MDMTEST1 &= ~0x04;                                                                                                                                                         \
    114            )
    115          #else
    116            #define HAL_BOARD_ENABLE_INTEGRATED_SNIFFER() { status = FAILURE; }
    117            #define HAL_BOARD_DISABLE_INTEGRATED_SNIFFER() { status = FAILURE; }
    118          #endif
    119          #endif // MT_SYS_SNIFFER_FEATURE
    120          
    121          #define RESET_HARD     0
    122          #define RESET_SOFT     1
    123          #define RESET_SHUTDOWN 2
    124          
    125          /***************************************************************************************************
    126           * CONSTANTS
    127           ***************************************************************************************************/
    128          
    129          #if !defined MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA
    130          #define MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA  FALSE
    131          #endif
    132          

   \                                 In section .rodata, align 4
    133          const uint16 MT_SysOsalEventId [] = {
   \                     MT_SysOsalEventId:
   \   00000000   0x0800 0x0400      DC16 2048, 1024, 512, 256
   \              0x0200 0x0100
    134                                                MT_SYS_OSAL_EVENT_0,
    135                                                MT_SYS_OSAL_EVENT_1,
    136                                                MT_SYS_OSAL_EVENT_2,
    137                                                MT_SYS_OSAL_EVENT_3
    138                                              };
    139          
    140          typedef enum {
    141            GPIO_DIR,
    142            GPIO_TRI,
    143            GPIO_SET,
    144            GPIO_CLR,
    145            GPIO_TOG,
    146            GPIO_GET,
    147            GPIO_HiD = 0x12
    148          } GPIO_Op_t;
    149          
    150          #if defined ( MT_SYS_JAMMER_FEATURE )
    151            #define JAMMER_CHECK_EVT                           0x0001
    152          
    153            #if !defined ( JAMMER_DETECT_CONTINUOUS_EVENTS )
    154              #define JAMMER_DETECT_CONTINUOUS_EVENTS          150
    155            #endif
    156            #if !defined ( JAMMER_DETECT_PERIOD_TIME )
    157              #define JAMMER_DETECT_PERIOD_TIME                100  // In milliseconds
    158            #endif
    159            #if !defined ( JAMMER_HIGH_NOISE_LEVEL )
    160              #define JAMMER_HIGH_NOISE_LEVEL                  -65
    161            #endif
    162          #endif // MT_SYS_JAMMER_FEATURE
    163          
    164          /***************************************************************************************************
    165           * LOCAL VARIABLES
    166           ***************************************************************************************************/
    167          #if defined ( MT_SYS_JAMMER_FEATURE )
    168            static uint8 jammerTaskID;
    169            static uint16 jammerContinuousEvents = JAMMER_DETECT_CONTINUOUS_EVENTS;
    170            static uint16 jammerDetections = JAMMER_DETECT_CONTINUOUS_EVENTS;
    171            static int8 jammerHighNoiseLevel = JAMMER_HIGH_NOISE_LEVEL;
    172            static uint32 jammerDetectPeriodTime = JAMMER_DETECT_PERIOD_TIME;
    173          #endif 
    174            
    175          #if defined ( MT_SYS_SNIFFER_FEATURE )
    176          static uint8 sniffer = FALSE;
    177          #endif
    178          
    179          /***************************************************************************************************
    180           * LOCAL FUNCTIONS
    181           ***************************************************************************************************/
    182          #if defined (MT_SYS_FUNC)
    183          void MT_SysReset(uint8 *pBuf);
    184          void MT_SysPing(void);
    185          void MT_SysVersion(void);
    186          void MT_SysSetExtAddr(uint8 *pBuf);
    187          void MT_SysGetExtAddr(void);
    188          void MT_SysOsalNVItemInit(uint8 *pBuf);
    189          void MT_SysOsalNVDelete(uint8 *pBuf);
    190          void MT_SysOsalNVLength(uint8 *pBuf);
    191          void MT_SysOsalNVRead(uint8 *pBuf);
    192          void MT_SysOsalNVWrite(uint8 *pBuf);
    193          void MT_SysOsalStartTimer(uint8 *pBuf);
    194          void MT_SysOsalStopTimer(uint8 *pBuf);
    195          void MT_SysRandom(void);
    196          void MT_SysAdcRead(uint8 *pBuf);
    197          void MT_SysGpio(uint8 *pBuf);
    198          void MT_SysStackTune(uint8 *pBuf);
    199          void MT_SysSetUtcTime(uint8 *pBuf);
    200          void MT_SysGetUtcTime(void);
    201          void MT_SysSetTxPower(uint8 *pBuf);
    202          #if defined ( MT_SYS_JAMMER_FEATURE )
    203            void MT_SysJammerParameters( uint8 *pBuf );
    204          #endif /* MT_SYS_JAMMER_FEATURE */
    205          #if defined ( MT_SYS_SNIFFER_FEATURE )
    206          void MT_SysSnifferParameters( uint8 *pBuf );
    207          #endif /* MT_SYS_SNIFFER_FEATURE */
    208          #if defined ( FEATURE_SYSTEM_STATS )
    209          void MT_SysZDiagsInitStats(void);
    210          void MT_SysZDiagsClearStats(uint8 *pBuf);
    211          void MT_SysZDiagsGetStatsAttr(uint8 *pBuf);
    212          void MT_SysZDiagsRestoreStatsFromNV(void);
    213          void MT_SysZDiagsSaveStatsToNV(void);
    214          #endif /* FEATURE_SYSTEM_STATS */
    215          #endif /* MT_SYS_FUNC */
    216          void powerOffSoc(void);
    217          
    218          #if defined (MT_SYS_FUNC)
    219          /***************************************************************************************************
    220           * @fn      MT_SysProcessing
    221           *
    222           * @brief   Process all the SYS commands that are issued by test tool
    223           *
    224           * @param   pBuf - pointer to the msg buffer
    225           *
    226           *          | LEN  | CMD0  | CMD1  |  DATA  |
    227           *          |  1   |   1   |   1   |  0-255 |
    228           *
    229           * @return  status
    230           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    231          uint8 MT_SysCommandProcessing(uint8 *pBuf)
    232          {
   \                     MT_SysCommandProcessing: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    233            uint8 status = MT_RPC_SUCCESS;
   \   00000002   0x2400             MOVS     R4,#+0
    234          
    235            switch (pBuf[MT_RPC_POS_CMD1])
   \   00000004   0x7881             LDRB     R1,[R0, #+2]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD028             BEQ.N    ??MT_SysCommandProcessing_0
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD029             BEQ.N    ??MT_SysCommandProcessing_1
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD02A             BEQ.N    ??MT_SysCommandProcessing_2
   \   00000012   0x2903             CMP      R1,#+3
   \   00000014   0xD02B             BEQ.N    ??MT_SysCommandProcessing_3
   \   00000016   0x2904             CMP      R1,#+4
   \   00000018   0xD02C             BEQ.N    ??MT_SysCommandProcessing_4
   \   0000001A   0x2907             CMP      R1,#+7
   \   0000001C   0xD030             BEQ.N    ??MT_SysCommandProcessing_5
   \   0000001E   0x2908             CMP      R1,#+8
   \   00000020   0xD034             BEQ.N    ??MT_SysCommandProcessing_6
   \   00000022   0x2909             CMP      R1,#+9
   \   00000024   0xD035             BEQ.N    ??MT_SysCommandProcessing_7
   \   00000026   0x290A             CMP      R1,#+10
   \   00000028   0xD03C             BEQ.N    ??MT_SysCommandProcessing_8
   \   0000002A   0x290B             CMP      R1,#+11
   \   0000002C   0xD03D             BEQ.N    ??MT_SysCommandProcessing_9
   \   0000002E   0x290C             CMP      R1,#+12
   \   00000030   0xD03E             BEQ.N    ??MT_SysCommandProcessing_10
   \   00000032   0x290D             CMP      R1,#+13
   \   00000034   0xD03F             BEQ.N    ??MT_SysCommandProcessing_11
   \   00000036   0x290E             CMP      R1,#+14
   \   00000038   0xD040             BEQ.N    ??MT_SysCommandProcessing_12
   \   0000003A   0x290F             CMP      R1,#+15
   \   0000003C   0xD041             BEQ.N    ??MT_SysCommandProcessing_13
   \   0000003E   0x2910             CMP      R1,#+16
   \   00000040   0xD042             BEQ.N    ??MT_SysCommandProcessing_14
   \   00000042   0x2911             CMP      R1,#+17
   \   00000044   0xD043             BEQ.N    ??MT_SysCommandProcessing_15
   \   00000046   0x2912             CMP      R1,#+18
   \   00000048   0xD017             BEQ.N    ??MT_SysCommandProcessing_16
   \   0000004A   0x2913             CMP      R1,#+19
   \   0000004C   0xD01B             BEQ.N    ??MT_SysCommandProcessing_17
   \   0000004E   0x2914             CMP      R1,#+20
   \   00000050   0xD040             BEQ.N    ??MT_SysCommandProcessing_18
   \   00000052   0x291C             CMP      R1,#+28
   \   00000054   0xD020             BEQ.N    ??MT_SysCommandProcessing_19
   \   00000056   0x291D             CMP      R1,#+29
   \   00000058   0xD021             BEQ.N    ??MT_SysCommandProcessing_20
   \   0000005A   0xE03E             B.N      ??MT_SysCommandProcessing_21
    236            {
    237              case MT_SYS_RESET_REQ:
    238                MT_SysReset(pBuf);
   \                     ??MT_SysCommandProcessing_0: (+1)
   \   0000005C   0x.... 0x....      BL       MT_SysReset
    239                break;
   \   00000060   0xE03C             B.N      ??MT_SysCommandProcessing_22
    240          
    241              case MT_SYS_PING:
    242                MT_SysPing();
   \                     ??MT_SysCommandProcessing_1: (+1)
   \   00000062   0x.... 0x....      BL       MT_SysPing
    243                break;
   \   00000066   0xE039             B.N      ??MT_SysCommandProcessing_22
    244          
    245              case MT_SYS_VERSION:
    246                MT_SysVersion();
   \                     ??MT_SysCommandProcessing_2: (+1)
   \   00000068   0x.... 0x....      BL       MT_SysVersion
    247                break;
   \   0000006C   0xE036             B.N      ??MT_SysCommandProcessing_22
    248          
    249              case MT_SYS_SET_EXTADDR:
    250                MT_SysSetExtAddr(pBuf);
   \                     ??MT_SysCommandProcessing_3: (+1)
   \   0000006E   0x.... 0x....      BL       MT_SysSetExtAddr
    251                break;
   \   00000072   0xE033             B.N      ??MT_SysCommandProcessing_22
    252          
    253              case MT_SYS_GET_EXTADDR:
    254                MT_SysGetExtAddr();
   \                     ??MT_SysCommandProcessing_4: (+1)
   \   00000074   0x.... 0x....      BL       MT_SysGetExtAddr
    255                break;
   \   00000078   0xE030             B.N      ??MT_SysCommandProcessing_22
    256          
    257          // CC253X MAC Network Processor does not have NV support
    258          #if !defined(CC253X_MACNP)
    259              case MT_SYS_OSAL_NV_DELETE:
    260                MT_SysOsalNVDelete(pBuf);
   \                     ??MT_SysCommandProcessing_16: (+1)
   \   0000007A   0x.... 0x....      BL       MT_SysOsalNVDelete
    261                break;
   \   0000007E   0xE02D             B.N      ??MT_SysCommandProcessing_22
    262          
    263              case MT_SYS_OSAL_NV_ITEM_INIT:
    264                MT_SysOsalNVItemInit(pBuf);
   \                     ??MT_SysCommandProcessing_5: (+1)
   \   00000080   0x.... 0x....      BL       MT_SysOsalNVItemInit
    265                break;
   \   00000084   0xE02A             B.N      ??MT_SysCommandProcessing_22
    266          
    267              case MT_SYS_OSAL_NV_LENGTH:
    268                MT_SysOsalNVLength(pBuf);
   \                     ??MT_SysCommandProcessing_17: (+1)
   \   00000086   0x.... 0x....      BL       MT_SysOsalNVLength
    269                break;
   \   0000008A   0xE027             B.N      ??MT_SysCommandProcessing_22
    270          
    271              case MT_SYS_OSAL_NV_READ:
    272                MT_SysOsalNVRead(pBuf);
   \                     ??MT_SysCommandProcessing_6: (+1)
   \   0000008C   0x.... 0x....      BL       MT_SysOsalNVRead
    273                break;
   \   00000090   0xE024             B.N      ??MT_SysCommandProcessing_22
    274          
    275              case MT_SYS_OSAL_NV_WRITE:
    276                MT_SysOsalNVWrite(pBuf);
   \                     ??MT_SysCommandProcessing_7: (+1)
   \   00000092   0x.... 0x....      BL       MT_SysOsalNVWrite
    277                break;
   \   00000096   0xE021             B.N      ??MT_SysCommandProcessing_22
    278          
    279              case MT_SYS_OSAL_NV_READ_EXT:
    280                MT_SysOsalNVRead(pBuf);
   \                     ??MT_SysCommandProcessing_19: (+1)
   \   00000098   0x.... 0x....      BL       MT_SysOsalNVRead
    281                break;
   \   0000009C   0xE01E             B.N      ??MT_SysCommandProcessing_22
    282                
    283              case MT_SYS_OSAL_NV_WRITE_EXT:
    284                MT_SysOsalNVWrite(pBuf);
   \                     ??MT_SysCommandProcessing_20: (+1)
   \   0000009E   0x.... 0x....      BL       MT_SysOsalNVWrite
    285                break;
   \   000000A2   0xE01B             B.N      ??MT_SysCommandProcessing_22
    286          #endif
    287          
    288              case MT_SYS_OSAL_START_TIMER:
    289                MT_SysOsalStartTimer(pBuf);
   \                     ??MT_SysCommandProcessing_8: (+1)
   \   000000A4   0x.... 0x....      BL       MT_SysOsalStartTimer
    290                break;
   \   000000A8   0xE018             B.N      ??MT_SysCommandProcessing_22
    291          
    292              case MT_SYS_OSAL_STOP_TIMER:
    293                MT_SysOsalStopTimer(pBuf);
   \                     ??MT_SysCommandProcessing_9: (+1)
   \   000000AA   0x.... 0x....      BL       MT_SysOsalStopTimer
    294                break;
   \   000000AE   0xE015             B.N      ??MT_SysCommandProcessing_22
    295          
    296              case MT_SYS_RANDOM:
    297                MT_SysRandom();
   \                     ??MT_SysCommandProcessing_10: (+1)
   \   000000B0   0x.... 0x....      BL       MT_SysRandom
    298                break;
   \   000000B4   0xE012             B.N      ??MT_SysCommandProcessing_22
    299          
    300              case MT_SYS_ADC_READ:
    301                MT_SysAdcRead(pBuf);
   \                     ??MT_SysCommandProcessing_11: (+1)
   \   000000B6   0x.... 0x....      BL       MT_SysAdcRead
    302                break;
   \   000000BA   0xE00F             B.N      ??MT_SysCommandProcessing_22
    303          
    304              case MT_SYS_GPIO:
    305                MT_SysGpio(pBuf);
   \                     ??MT_SysCommandProcessing_12: (+1)
   \   000000BC   0x.... 0x....      BL       MT_SysGpio
    306                break;
   \   000000C0   0xE00C             B.N      ??MT_SysCommandProcessing_22
    307          
    308              case MT_SYS_STACK_TUNE:
    309                MT_SysStackTune(pBuf);
   \                     ??MT_SysCommandProcessing_13: (+1)
   \   000000C2   0x.... 0x....      BL       MT_SysStackTune
    310                break;
   \   000000C6   0xE009             B.N      ??MT_SysCommandProcessing_22
    311          
    312              case MT_SYS_SET_TIME:
    313                MT_SysSetUtcTime(pBuf);
   \                     ??MT_SysCommandProcessing_14: (+1)
   \   000000C8   0x.... 0x....      BL       MT_SysSetUtcTime
    314                break;
   \   000000CC   0xE006             B.N      ??MT_SysCommandProcessing_22
    315          
    316              case MT_SYS_GET_TIME:
    317                MT_SysGetUtcTime();
   \                     ??MT_SysCommandProcessing_15: (+1)
   \   000000CE   0x.... 0x....      BL       MT_SysGetUtcTime
    318                break;
   \   000000D2   0xE003             B.N      ??MT_SysCommandProcessing_22
    319          
    320              case MT_SYS_SET_TX_POWER:
    321                MT_SysSetTxPower(pBuf);
   \                     ??MT_SysCommandProcessing_18: (+1)
   \   000000D4   0x.... 0x....      BL       MT_SysSetTxPower
    322                break;
   \   000000D8   0xE000             B.N      ??MT_SysCommandProcessing_22
    323                
    324          #if defined ( MT_SYS_JAMMER_FEATURE )
    325              case MT_SYS_JAMMER_PARAMETERS:
    326                MT_SysJammerParameters( pBuf );
    327                break;
    328          #endif      
    329          
    330          #if defined ( MT_SYS_SNIFFER_FEATURE )
    331              case MT_SYS_SNIFFER_PARAMETERS:
    332                MT_SysSnifferParameters( pBuf );
    333                break;
    334          #endif      
    335          
    336          #if defined ( FEATURE_SYSTEM_STATS )
    337              case MT_SYS_ZDIAGS_INIT_STATS:
    338                MT_SysZDiagsInitStats();
    339                break;
    340          
    341              case MT_SYS_ZDIAGS_CLEAR_STATS:
    342                MT_SysZDiagsClearStats(pBuf);
    343                break;
    344          
    345              case MT_SYS_ZDIAGS_GET_STATS:
    346                MT_SysZDiagsGetStatsAttr(pBuf);
    347                 break;
    348          
    349              case MT_SYS_ZDIAGS_RESTORE_STATS_NV:
    350                MT_SysZDiagsRestoreStatsFromNV();
    351                break;
    352          
    353              case MT_SYS_ZDIAGS_SAVE_STATS_TO_NV:
    354                MT_SysZDiagsSaveStatsToNV();
    355                break;
    356          #endif /* FEATURE_SYSTEM_STATS */
    357          
    358              default:
    359                status = MT_RPC_ERR_COMMAND_ID;
   \                     ??MT_SysCommandProcessing_21: (+1)
   \   000000DA   0x2402             MOVS     R4,#+2
    360                break;
    361            }
    362          
    363            return status;
   \                     ??MT_SysCommandProcessing_22: (+1)
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xBD10             POP      {R4,PC}          ;; return
    364          }
    365          
    366          /**************************************************************************************************
    367           * @fn      MT_SysReset
    368           *
    369           * @brief   Reset the device.
    370           * @param   typID: 0=reset, 1=serial bootloader, 
    371           *
    372           * @return  None
    373           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    374          void MT_SysReset( uint8 *pBuf )
    375          {
   \                     MT_SysReset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    376            switch( pBuf[MT_RPC_POS_DAT0] )
   \   00000002   0x78C0             LDRB     R0,[R0, #+3]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??MT_SysReset_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD007             BEQ.N    ??MT_SysReset_1
   \   0000000C   0xD303             BCC.N    ??MT_SysReset_2
   \   0000000E   0xE007             B.N      ??MT_SysReset_3
    377            {
    378              case MT_SYS_RESET_HARD:
    379                SystemReset();
   \                     ??MT_SysReset_0: (+1)
   \   00000010   0x.... 0x....      BL       SysCtrlReset
    380                break;
   \   00000014   0xE004             B.N      ??MT_SysReset_3
    381                
    382              case MT_SYS_RESET_SOFT:
    383          #if !(defined(HAL_BOARD_F2618) || defined(HAL_BOARD_F5438) || defined(HAL_BOARD_LM3S))
    384                SystemResetSoft();  // Especially useful for CC2531 to not break comm with USB Host.
   \                     ??MT_SysReset_2: (+1)
   \   00000016   0x.... 0x....      BL       SysCtrlReset
    385          #endif
    386                break;
   \   0000001A   0xE001             B.N      ??MT_SysReset_3
    387                
    388              case MT_SYS_RESET_SHUTDOWN:
    389                {
    390                  // Disable interrupts and put into deep sleep, use hardware reset to wakeup
    391                  powerOffSoc();
   \                     ??MT_SysReset_1: (+1)
   \   0000001C   0x.... 0x....      BL       powerOffSoc
    392                }
    393                break;
    394            }
    395          }
   \                     ??MT_SysReset_3: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    396          
    397          /***************************************************************************************************
    398           * @fn      MT_SysPing
    399           *
    400           * @brief   Process the Ping command
    401           *
    402           * @param   None
    403           *
    404           * @return  None
    405           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    406          void MT_SysPing(void)
    407          {
   \                     MT_SysPing: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    408            uint16 tmp16;
    409            uint8 retArray[2];
    410          
    411            /* Build Capabilities */
    412            tmp16 = MT_CAP_SYS | MT_CAP_MAC | MT_CAP_NWK | MT_CAP_AF | MT_CAP_ZDO |
    413                    MT_CAP_SAPI | MT_CAP_UTIL | MT_CAP_DEBUG | MT_CAP_APP | MT_CAP_GP | MT_CAP_ZOAD;
   \   00000002   0x2011             MOVS     R0,#+17
    414          
    415            /* Convert to high byte first into temp buffer */
    416            retArray[0] = LO_UINT16( tmp16 );
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
    417            retArray[1] = HI_UINT16( tmp16 );
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x0A00             LSRS     R0,R0,#+8
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    418          
    419            /* Build and send back the response */
    420            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_PING,
    421                                          sizeof (tmp16), retArray );
   \   00000012   0xAB00             ADD      R3,SP,#+0
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2061             MOVS     R0,#+97
   \   0000001A   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    422          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    423          
    424          /***************************************************************************************************
    425           * @fn      MT_SysVersion
    426           *
    427           * @brief   Process the Version command
    428           *
    429           * @param   None
    430           *
    431           * @return  None
    432           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    433          void MT_SysVersion(void)
    434          {
   \                     MT_SysVersion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    435          #if !defined INCLUDE_REVISION_INFORMATION
    436            /* Build and send back the response */
    437            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_VERSION,
    438                                         sizeof(MTVersionString), (uint8 *)MTVersionString);
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable3
   \   00000006   0x2205             MOVS     R2,#+5
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x2061             MOVS     R0,#+97
   \   0000000C   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    439          
    440          #else
    441            uint8 verStr[sizeof(MTVersionString) + 4];
    442            uint8 *pBuf = &verStr[sizeof(MTVersionString)];
    443            
    444          #if (defined MAKE_CRC_SHDW) || (defined FAKE_CRC_SHDW)  //built for bootloader
    445            uint32 sblSig;
    446            uint32 sblRev;
    447          #endif
    448          
    449            osal_memcpy(verStr, (uint8 *)MTVersionString, sizeof(MTVersionString));
    450          
    451          #if (defined MAKE_CRC_SHDW) || (defined FAKE_CRC_SHDW)  //built for bootloader
    452            HalFlashRead(SBL_SIG_ADDR / HAL_FLASH_PAGE_SIZE,
    453                         SBL_SIG_ADDR % HAL_FLASH_PAGE_SIZE,
    454                         (uint8 *)&sblSig, sizeof(sblSig));
    455          
    456            if (sblSig == SBL_SIGNATURE)
    457            {
    458              // SBL is supported and its revision is provided (in a known flash location)
    459              HalFlashRead(SBL_REV_ADDR / HAL_FLASH_PAGE_SIZE,
    460                           SBL_REV_ADDR % HAL_FLASH_PAGE_SIZE,
    461                           (uint8 *)&sblRev, sizeof(sblRev));
    462            }
    463            else
    464            {
    465              //  SBL is supported but its revision is not provided
    466              sblRev = 0x00000000;
    467            }
    468          #else
    469            // SBL is NOT supported
    470            sblRev = 0xFFFFFFFF;
    471          #endif
    472          
    473            // Plug the SBL revision indication
    474            UINT32_TO_BUF_LITTLE_ENDIAN(pBuf,sblRev);
    475          
    476            /* Build and send back the response */
    477            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_VERSION,
    478                                         sizeof(verStr), verStr);
    479          
    480          #endif
    481          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    482          
    483          /***************************************************************************************************
    484           * @fn      MT_SysSetExtAddr
    485           *
    486           * @brief   Set the Extended Address
    487           *
    488           * @param   pBuf
    489           *
    490           * @return  None
    491           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    492          void MT_SysSetExtAddr(uint8 *pBuf)
    493          {
   \                     MT_SysSetExtAddr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    494            uint8 retValue = ZFailure;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    495            uint8 cmdId;
    496          
    497            /* parse header */
    498            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   0000000A   0x78A5             LDRB     R5,[R4, #+2]
    499            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   0000000C   0x1CE4             ADDS     R4,R4,#+3
    500          
    501            if ( ZMacSetReq(ZMacExtAddr, pBuf) == ZMacSuccess )
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x20E2             MOVS     R0,#+226
   \   00000012   0x.... 0x....      BL       ZMacSetReq
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD107             BNE.N    ??MT_SysSetExtAddr_0
    502            {
    503          // CC253X MAC Network Processor does not have NV support
    504          #if !defined(CC253X_MACNP)
    505              retValue = osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf);
   \   0000001A   0x0023             MOVS     R3,R4
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       osal_nv_write
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
    506          #endif
    507            }
    508          
    509            /* Build and send back the response */
    510            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 1, &retValue);
   \                     ??MT_SysSetExtAddr_0: (+1)
   \   0000002A   0xAB00             ADD      R3,SP,#+0
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x2061             MOVS     R0,#+97
   \   00000034   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    511          
    512          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    513          
    514          /***************************************************************************************************
    515           * @fn      MT_SysGetExtAddr
    516           *
    517           * @brief   Get the Extended Address
    518           *
    519           * @param   None
    520           *
    521           * @return  None
    522           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    523          void MT_SysGetExtAddr(void)
    524          {
   \                     MT_SysGetExtAddr: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    525            uint8 extAddr[Z_EXTADDR_LEN];
    526          
    527            ZMacGetReq( ZMacExtAddr, extAddr );
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x20E2             MOVS     R0,#+226
   \   00000008   0x.... 0x....      BL       ZMacGetReq
    528          
    529            /* Build and send back the response */
    530            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_GET_EXTADDR,
    531                                         Z_EXTADDR_LEN, extAddr);
   \   0000000C   0xAB00             ADD      R3,SP,#+0
   \   0000000E   0x2208             MOVS     R2,#+8
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x2061             MOVS     R0,#+97
   \   00000014   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    532          }
   \   00000018   0xBD07             POP      {R0-R2,PC}       ;; return
    533          
    534          #if !defined(CC253X_MACNP)
    535          /***************************************************************************************************
    536           * @fn      MT_SysOsalNVRead
    537           *
    538           * @brief   Attempt to read an NV value
    539           *
    540           * @param   pBuf - pointer to the data
    541           *
    542           * @return  None
    543           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    544          void MT_SysOsalNVRead(uint8 *pBuf)
    545          {
   \                     MT_SysOsalNVRead: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0007             MOVS     R7,R0
    546            uint8 cmdId;
    547            uint16 nvId;
    548            uint16 dataLen;
    549            uint16 dataOfs;
    550            uint16 nvItemLen;
    551            uint8 error = ZSuccess;
   \   00000008   0x2500             MOVS     R5,#+0
    552          
    553            /* MT command ID */
    554            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   0000000A   0x78BC             LDRB     R4,[R7, #+2]
    555            /* Skip over RPC header */
    556            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   0000000C   0x1CFF             ADDS     R7,R7,#+3
    557          
    558            /* NV item ID */
    559            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   0000000E   0x7838             LDRB     R0,[R7, #+0]
   \   00000010   0x7879             LDRB     R1,[R7, #+1]
   \   00000012   0xEB10 0x2601      ADDS     R6,R0,R1, LSL #+8
    560            /* Length of entire NV item data */
    561            nvItemLen = osal_nv_item_len(nvId);
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x.... 0x....      BL       osal_nv_item_len
    562          
    563          #if !MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA
    564            if ((ZCD_NV_IMPLICIT_CERTIFICATE == nvId) ||
    565                (ZCD_NV_CA_PUBLIC_KEY == nvId)        ||
    566                (ZCD_NV_DEVICE_PRIVATE_KEY == nvId))
   \   0000001E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000020   0x2E69             CMP      R6,#+105
   \   00000022   0xD005             BEQ.N    ??MT_SysOsalNVRead_0
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x2E6B             CMP      R6,#+107
   \   00000028   0xD002             BEQ.N    ??MT_SysOsalNVRead_0
   \   0000002A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002C   0x2E6A             CMP      R6,#+106
   \   0000002E   0xD100             BNE.N    ??MT_SysOsalNVRead_1
    567            {
    568              /* Access to Security Certificate Data is denied */
    569              error = ZInvalidParameter;
   \                     ??MT_SysOsalNVRead_0: (+1)
   \   00000030   0x2502             MOVS     R5,#+2
    570            }
    571          #endif
    572          
    573          #if !MT_SYS_KEY_MANAGEMENT
    574            if ( (nvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
    575                 (nvId == ZCD_NV_NWK_ALTERN_KEY_INFO) ||
    576                ((nvId >= ZCD_NV_TCLK_TABLE_START) && (nvId <= ZCD_NV_TCLK_TABLE_END)) ||
    577                ((nvId >= ZCD_NV_APS_LINK_KEY_DATA_START) && (nvId <= ZCD_NV_APS_LINK_KEY_DATA_END)) ||
    578                 (nvId == ZCD_NV_PRECFGKEY) )
   \                     ??MT_SysOsalNVRead_1: (+1)
   \   00000032   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000034   0x2E3A             CMP      R6,#+58
   \   00000036   0xD00F             BEQ.N    ??MT_SysOsalNVRead_2
   \   00000038   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003A   0x2E3B             CMP      R6,#+59
   \   0000003C   0xD00C             BEQ.N    ??MT_SysOsalNVRead_2
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0xF2A6 0x1101      SUBW     R1,R6,#+257
   \   00000044   0x29FF             CMP      R1,#+255
   \   00000046   0xD307             BCC.N    ??MT_SysOsalNVRead_2
   \   00000048   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004A   0xF2A6 0x2101      SUBW     R1,R6,#+513
   \   0000004E   0x29FF             CMP      R1,#+255
   \   00000050   0xD302             BCC.N    ??MT_SysOsalNVRead_2
   \   00000052   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000054   0x2E62             CMP      R6,#+98
   \   00000056   0xD100             BNE.N    ??MT_SysOsalNVRead_3
    579            {
    580              /* Access to Security Key Data is denied */
    581              error = ZInvalidParameter;
   \                     ??MT_SysOsalNVRead_2: (+1)
   \   00000058   0x2502             MOVS     R5,#+2
    582            }
    583          #endif //!MT_SYS_KEY_MANAGEMENT
    584            
    585            /* Get NV data offset */
    586            if (cmdId == MT_SYS_OSAL_NV_READ)
   \                     ??MT_SysOsalNVRead_3: (+1)
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x2C08             CMP      R4,#+8
   \   0000005E   0xD102             BNE.N    ??MT_SysOsalNVRead_4
    587            {
    588              /* MT_SYS_OSAL_NV_READ has 1-byte offset */
    589              dataOfs = (uint16)pBuf[2];
   \   00000060   0xF897 0x9002      LDRB     R9,[R7, #+2]
   \   00000064   0xE003             B.N      ??MT_SysOsalNVRead_5
    590            }
    591            else
    592            {
    593              /* MT_SYS_OSAL_NV_READ_EXT has 2-byte offset */
    594              dataOfs = BUILD_UINT16(pBuf[2], pBuf[3]);
   \                     ??MT_SysOsalNVRead_4: (+1)
   \   00000066   0x78B9             LDRB     R1,[R7, #+2]
   \   00000068   0x78FA             LDRB     R2,[R7, #+3]
   \   0000006A   0xEB11 0x2902      ADDS     R9,R1,R2, LSL #+8
    595            }
    596            if (nvItemLen <= dataOfs)
   \                     ??MT_SysOsalNVRead_5: (+1)
   \   0000006E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000072   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000074   0x4581             CMP      R9,R0
   \   00000076   0xD300             BCC.N    ??MT_SysOsalNVRead_6
    597            {
    598              /* Offset is past end of data */
    599              error = ZInvalidParameter;
   \   00000078   0x2502             MOVS     R5,#+2
    600            }
    601          
    602            if (error == ZSuccess)
   \                     ??MT_SysOsalNVRead_6: (+1)
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD142             BNE.N    ??MT_SysOsalNVRead_7
    603            {
    604              uint8 *pRetBuf;
    605              uint8 respLen = 2;  /* Response header: [0]=status,[1]=length */
   \   00000080   0xF05F 0x0802      MOVS     R8,#+2
    606          
    607              dataLen = nvItemLen - dataOfs;
   \   00000084   0xEBB0 0x0709      SUBS     R7,R0,R9
    608              if (dataLen > (uint16)(MT_MAX_RSP_DATA_LEN - respLen))
   \   00000088   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008C   0xF1D8 0x00A4      RSBS     R0,R8,#+164
   \   00000090   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000092   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000094   0x42B8             CMP      R0,R7
   \   00000096   0xD203             BCS.N    ??MT_SysOsalNVRead_8
    609              {
    610                /* Data length is limited by TX buffer size and MT protocol */
    611                dataLen = (MT_MAX_RSP_DATA_LEN - respLen);
   \   00000098   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009C   0xF1D8 0x07A4      RSBS     R7,R8,#+164
    612              }
    613              respLen += dataLen;
   \                     ??MT_SysOsalNVRead_8: (+1)
   \   000000A0   0xEB17 0x0808      ADDS     R8,R7,R8
    614          
    615              pRetBuf = osal_mem_alloc(respLen);
   \   000000A4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AC   0x.... 0x....      BL       osal_mem_alloc
   \   000000B0   0x4682             MOV      R10,R0
    616              if (pRetBuf != NULL)
   \   000000B2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000B6   0xD025             BEQ.N    ??MT_SysOsalNVRead_9
    617              {
    618                osal_memset(&pRetBuf[2], 0, dataLen);
   \   000000B8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000BA   0x003A             MOVS     R2,R7
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0xF11A 0x0002      ADDS     R0,R10,#+2
   \   000000C2   0x.... 0x....      BL       osal_memset
    619                if (((osal_nv_read( nvId, dataOfs, dataLen, &pRetBuf[2])) == ZSUCCESS))
   \   000000C6   0xF11A 0x0302      ADDS     R3,R10,#+2
   \   000000CA   0x003A             MOVS     R2,R7
   \   000000CC   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000CE   0x4649             MOV      R1,R9
   \   000000D0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D6   0x.... 0x....      BL       osal_nv_read
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD10D             BNE.N    ??MT_SysOsalNVRead_10
    620                {
    621                  pRetBuf[0] = ZSuccess;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF88A 0x0000      STRB     R0,[R10, #+0]
    622                  pRetBuf[1] = dataLen;
   \   000000E4   0xF88A 0x7001      STRB     R7,[R10, #+1]
    623                  MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    624                                                 cmdId, respLen, pRetBuf );
   \   000000E8   0x4653             MOV      R3,R10
   \   000000EA   0x4642             MOV      R2,R8
   \   000000EC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000EE   0x0021             MOVS     R1,R4
   \   000000F0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F2   0x2061             MOVS     R0,#+97
   \   000000F4   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   \   000000F8   0xE000             B.N      ??MT_SysOsalNVRead_11
    625                }
    626                else
    627                {
    628                  error = NV_OPER_FAILED;
   \                     ??MT_SysOsalNVRead_10: (+1)
   \   000000FA   0x250A             MOVS     R5,#+10
    629                }
    630                osal_mem_free(pRetBuf);
   \                     ??MT_SysOsalNVRead_11: (+1)
   \   000000FC   0x4650             MOV      R0,R10
   \   000000FE   0x.... 0x....      BL       osal_mem_free
   \   00000102   0xE000             B.N      ??MT_SysOsalNVRead_7
    631              }
    632              else
    633              {
    634                /* Could not get buffer for NV data */
    635                error = ZMemError;
   \                     ??MT_SysOsalNVRead_9: (+1)
   \   00000104   0x2510             MOVS     R5,#+16
    636              }
    637            }
    638            
    639            if (error != ZSuccess)
   \                     ??MT_SysOsalNVRead_7: (+1)
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x2D00             CMP      R5,#+0
   \   0000010A   0xD00B             BEQ.N    ??MT_SysOsalNVRead_12
    640            {
    641              uint8 tmp[2] = { error, 0 };
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000112   0xF88D 0x5000      STRB     R5,[SP, #+0]
    642              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    643                                             cmdId, 2, tmp);
   \   00000116   0xAB00             ADD      R3,SP,#+0
   \   00000118   0x2202             MOVS     R2,#+2
   \   0000011A   0x0021             MOVS     R1,R4
   \   0000011C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011E   0x2061             MOVS     R0,#+97
   \   00000120   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    644            }
    645          }
   \                     ??MT_SysOsalNVRead_12: (+1)
   \   00000124   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0
    646          
    647          /***************************************************************************************************
    648           * @fn      MT_SysOsalNVWrite
    649           *
    650           * @brief   Attempt to write an NV item
    651           *
    652           * @param   pBuf - pointer to the data
    653           *
    654           * @return  None
    655           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    656          void MT_SysOsalNVWrite(uint8 *pBuf)
    657          {
   \                     MT_SysOsalNVWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0005             MOVS     R5,R0
    658            uint8 cmdId;
    659            uint16 nvId;
    660            uint16 dataLen;
    661            uint16 dataOfs;
    662            uint16 nvItemLen;
    663            uint8 rtrn = ZSuccess;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    664          
    665            /* MT command ID */
    666            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   0000000E   0x78AC             LDRB     R4,[R5, #+2]
    667            /* Skip over RPC header */
    668            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000010   0x1CED             ADDS     R5,R5,#+3
    669          
    670            /* NV item ID */
    671            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   00000012   0x7828             LDRB     R0,[R5, #+0]
   \   00000014   0x7869             LDRB     R1,[R5, #+1]
   \   00000016   0xEB10 0x2601      ADDS     R6,R0,R1, LSL #+8
    672            
    673            /* Get NV data offset & length */
    674            if ( cmdId == MT_SYS_OSAL_NV_WRITE )
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C09             CMP      R4,#+9
   \   0000001E   0xD104             BNE.N    ??MT_SysOsalNVWrite_0
    675            {
    676              /* MT_SYS_OSAL_NV_WRITE has 1-byte offset & length */
    677              dataOfs = (uint16)pBuf[2];
   \   00000020   0xF895 0x8002      LDRB     R8,[R5, #+2]
    678              dataLen = (uint16)pBuf[3];
   \   00000024   0x78EF             LDRB     R7,[R5, #+3]
    679              pBuf += 4;
   \   00000026   0x1D2D             ADDS     R5,R5,#+4
   \   00000028   0xE008             B.N      ??MT_SysOsalNVWrite_1
    680            }
    681            else
    682            {
    683              /* MT_SYS_OSAL_NV_WRITE_EXT has 2-byte offset & length */
    684              dataOfs = BUILD_UINT16(pBuf[2], pBuf[3]);
   \                     ??MT_SysOsalNVWrite_0: (+1)
   \   0000002A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000002C   0x78E9             LDRB     R1,[R5, #+3]
   \   0000002E   0xEB10 0x2801      ADDS     R8,R0,R1, LSL #+8
    685              dataLen = BUILD_UINT16(pBuf[4], pBuf[5]);
   \   00000032   0x7928             LDRB     R0,[R5, #+4]
   \   00000034   0x7969             LDRB     R1,[R5, #+5]
   \   00000036   0xEB10 0x2701      ADDS     R7,R0,R1, LSL #+8
    686              pBuf += 6;
   \   0000003A   0x1DAD             ADDS     R5,R5,#+6
    687            }
    688          
    689            /* Length of entire NV item data */
    690            nvItemLen = osal_nv_item_len(nvId);
   \                     ??MT_SysOsalNVWrite_1: (+1)
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000040   0x.... 0x....      BL       osal_nv_item_len
    691            if ((dataOfs + dataLen) <= nvItemLen)
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000004A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004C   0xEB17 0x0108      ADDS     R1,R7,R8
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xDB24             BLT.N    ??MT_SysOsalNVWrite_2
    692            {
    693              if (dataOfs == 0)
   \   00000054   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000058   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005C   0xD106             BNE.N    ??MT_SysOsalNVWrite_3
    694              {
    695                /* Set the Z-Globals value of this NV item */
    696                zgSetItem( nvId, dataLen, pBuf );
   \   0000005E   0x002A             MOVS     R2,R5
   \   00000060   0x0039             MOVS     R1,R7
   \   00000062   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000068   0x.... 0x....      BL       zgSetItem
    697              }
    698              
    699              if ((osal_nv_write(nvId, dataOfs, dataLen, pBuf)) == ZSUCCESS)
   \                     ??MT_SysOsalNVWrite_3: (+1)
   \   0000006C   0x002B             MOVS     R3,R5
   \   0000006E   0x003A             MOVS     R2,R7
   \   00000070   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000072   0x4641             MOV      R1,R8
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007A   0x.... 0x....      BL       osal_nv_write
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD109             BNE.N    ??MT_SysOsalNVWrite_4
    700              {
    701                if (nvId == ZCD_NV_EXTADDR)
   \   00000082   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000084   0x2E01             CMP      R6,#+1
   \   00000086   0xD10D             BNE.N    ??MT_SysOsalNVWrite_5
    702                {
    703                  rtrn = ZMacSetReq(ZMacExtAddr, pBuf);
   \   00000088   0x0029             MOVS     R1,R5
   \   0000008A   0x20E2             MOVS     R0,#+226
   \   0000008C   0x.... 0x....      BL       ZMacSetReq
   \   00000090   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000094   0xE006             B.N      ??MT_SysOsalNVWrite_5
    704                }
    705              }
    706              else
    707              {
    708                rtrn = NV_OPER_FAILED;
   \                     ??MT_SysOsalNVWrite_4: (+1)
   \   00000096   0x200A             MOVS     R0,#+10
   \   00000098   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000009C   0xE002             B.N      ??MT_SysOsalNVWrite_5
    709              }
    710            }
    711            else
    712            {
    713              /* Bad length or/and offset */
    714              rtrn = ZInvalidParameter;
   \                     ??MT_SysOsalNVWrite_2: (+1)
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    715            }
    716          
    717            /* Build and send back the response */
    718            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    719                                           cmdId, 1, &rtrn);
   \                     ??MT_SysOsalNVWrite_5: (+1)
   \   000000A4   0xAB00             ADD      R3,SP,#+0
   \   000000A6   0x2201             MOVS     R2,#+1
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AC   0x2061             MOVS     R0,#+97
   \   000000AE   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    720          }
   \   000000B2   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    721          
    722          /***************************************************************************************************
    723           * @fn      MT_SysOsalNVItemInit
    724           *
    725           * @brief   Attempt to create an NV item
    726           *
    727           * @param   pBuf - pointer to the data
    728           *
    729           * @return  None
    730           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    731          void MT_SysOsalNVItemInit(uint8 *pBuf)
    732          {
   \                     MT_SysOsalNVItemInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    733            uint8 ret;
    734            uint8 idLen;
    735            uint16 nvId;
    736            uint16 nvLen;
    737          
    738            /* Skip over RPC header */
    739            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000006   0x1CE4             ADDS     R4,R4,#+3
    740          
    741            /* NV item ID */
    742            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x7861             LDRB     R1,[R4, #+1]
   \   0000000C   0xEB10 0x2601      ADDS     R6,R0,R1, LSL #+8
    743            /* NV item length */
    744            nvLen = BUILD_UINT16(pBuf[2], pBuf[3]);
   \   00000010   0x78A0             LDRB     R0,[R4, #+2]
   \   00000012   0x78E1             LDRB     R1,[R4, #+3]
   \   00000014   0xEB10 0x2101      ADDS     R1,R0,R1, LSL #+8
    745            /* Initialization data length */
    746            idLen = pBuf[4];
   \   00000018   0x7925             LDRB     R5,[R4, #+4]
    747            pBuf += 5;
   \   0000001A   0x1D64             ADDS     R4,R4,#+5
    748          
    749            if ( idLen < nvLen )
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD218             BCS.N    ??MT_SysOsalNVItemInit_0
    750            {
    751              /* Attempt to create a new NV item */
    752              ret = osal_nv_item_init( nvId, nvLen, NULL );
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0x.... 0x....      BL       osal_nv_item_init
   \   00000034   0xF88D 0x0000      STRB     R0,[SP, #+0]
    753              if ( (ret == NV_ITEM_UNINIT) && (idLen > 0) )
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2809             CMP      R0,#+9
   \   0000003E   0xD114             BNE.N    ??MT_SysOsalNVItemInit_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD011             BEQ.N    ??MT_SysOsalNVItemInit_1
    754              {
    755                /* Write initialization data to first part of new item */
    756                (void) osal_nv_write( nvId, 0, (uint16)idLen, pBuf );
   \   00000046   0x0023             MOVS     R3,R4
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x002A             MOVS     R2,R5
   \   0000004C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000054   0x.... 0x....      BL       osal_nv_write
   \   00000058   0xE007             B.N      ??MT_SysOsalNVItemInit_1
    757              }
    758            }
    759            else
    760            {
    761              /* Attempt to create/initialize a new NV item */
    762              ret = osal_nv_item_init( nvId, nvLen, pBuf );
   \                     ??MT_SysOsalNVItemInit_0: (+1)
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000062   0x.... 0x....      BL       osal_nv_item_init
   \   00000066   0xF88D 0x0000      STRB     R0,[SP, #+0]
    763            }
    764          
    765            /* Build and send back the response */
    766            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    767                                           MT_SYS_OSAL_NV_ITEM_INIT, 1, &ret);
   \                     ??MT_SysOsalNVItemInit_1: (+1)
   \   0000006A   0xAB00             ADD      R3,SP,#+0
   \   0000006C   0x2201             MOVS     R2,#+1
   \   0000006E   0x2107             MOVS     R1,#+7
   \   00000070   0x2061             MOVS     R0,#+97
   \   00000072   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    768          }
   \   00000076   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    769          
    770          /***************************************************************************************************
    771           * @fn      MT_SysOsalNVDelete
    772           *
    773           * @brief   Attempt to delete an NV item
    774           *
    775           * @param   pBuf - pointer to the data
    776           *
    777           * @return  None
    778           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    779          void MT_SysOsalNVDelete(uint8 *pBuf)
    780          {
   \                     MT_SysOsalNVDelete: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    781            uint16 nvId;
    782            uint16 nvLen;
    783            uint8 ret;
    784          
    785            /* Skip over RPC header */
    786            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000002   0x1CC0             ADDS     R0,R0,#+3
    787          
    788            /* Get the ID */
    789            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x7842             LDRB     R2,[R0, #+1]
   \   00000008   0xEB11 0x2202      ADDS     R2,R1,R2, LSL #+8
    790            /* Get the length */
    791            nvLen = BUILD_UINT16(pBuf[2], pBuf[3]);
   \   0000000C   0x7881             LDRB     R1,[R0, #+2]
   \   0000000E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000010   0xEB11 0x2100      ADDS     R1,R1,R0, LSL #+8
    792          
    793            /* Attempt to delete the NV item */
    794            ret = osal_nv_delete( nvId, nvLen );
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x0010             MOVS     R0,R2
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x.... 0x....      BL       osal_nv_delete
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    795          
    796            /* Build and send back the response */
    797            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    798                                           MT_SYS_OSAL_NV_DELETE, 1, &ret);
   \   00000022   0xAB00             ADD      R3,SP,#+0
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2112             MOVS     R1,#+18
   \   00000028   0x2061             MOVS     R0,#+97
   \   0000002A   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    799          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    800          
    801          /***************************************************************************************************
    802           * @fn      MT_SysOsalNVLength
    803           *
    804           * @brief   Attempt to get the length to an NV item
    805           *
    806           * @param   pBuf - pointer to the data
    807           *
    808           * @return  None
    809           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    810          void MT_SysOsalNVLength(uint8 *pBuf)
    811          {
   \                     MT_SysOsalNVLength: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    812            uint16 nvId;
    813            uint16 nvLen;
    814            uint8 rsp[2];
    815          
    816            /* Skip over RPC header */
    817            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000002   0x1CC0             ADDS     R0,R0,#+3
    818          
    819            /* Get the ID */
    820            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x7840             LDRB     R0,[R0, #+1]
   \   00000008   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
    821          
    822            /* Attempt to get NV item length */
    823            nvLen = osal_nv_item_len( nvId );
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x.... 0x....      BL       osal_nv_item_len
    824            rsp[0] = LO_UINT16( nvLen );
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xF88D 0x1000      STRB     R1,[SP, #+0]
    825            rsp[1] = HI_UINT16( nvLen );
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x0A00             LSRS     R0,R0,#+8
   \   0000001C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    826          
    827            /* Build and send back the response */
    828            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    829                                           MT_SYS_OSAL_NV_LENGTH, 2, rsp);
   \   00000020   0xAB00             ADD      R3,SP,#+0
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x2113             MOVS     R1,#+19
   \   00000026   0x2061             MOVS     R0,#+97
   \   00000028   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    830          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
    831          #endif // !defined(CC253X_MACNP)
    832          
    833          /***************************************************************************************************
    834           * @fn      MT_SysOsalStartTimer
    835           *
    836           * @brief
    837           *
    838           * @param   uint8 pBuf - pointer to the data
    839           *
    840           * @return  None
    841           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    842          void MT_SysOsalStartTimer(uint8 *pBuf)
    843          {
   \                     MT_SysOsalStartTimer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    844            uint16 eventId;
    845            uint8 retValue = ZFailure;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
    846            uint8 cmdId;
    847          
    848            /* parse header */
    849            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   0000000A   0x7884             LDRB     R4,[R0, #+2]
    850            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
    851          
    852            if (*pBuf <= 3)
   \   0000000E   0x7801             LDRB     R1,[R0, #+0]
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xDA12             BGE.N    ??MT_SysOsalStartTimer_0
    853            {
    854              eventId = (uint16) MT_SysOsalEventId[*pBuf];
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \   00000018   0x7802             LDRB     R2,[R0, #+0]
   \   0000001A   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
    855              retValue = osal_start_timerEx(MT_TaskID, eventId, BUILD_UINT16(pBuf[1], pBuf[2]));
   \   0000001E   0x7842             LDRB     R2,[R0, #+1]
   \   00000020   0x7880             LDRB     R0,[R0, #+2]
   \   00000022   0xEB12 0x2200      ADDS     R2,R2,R0, LSL #+8
   \   00000026   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000028   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x.... 0x....      BL       osal_start_timerEx
   \   00000034   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000038   0xE002             B.N      ??MT_SysOsalStartTimer_1
    856            }
    857            else
    858            {
    859              retValue = ZInvalidParameter;
   \                     ??MT_SysOsalStartTimer_0: (+1)
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    860            }
    861          
    862            /* Build and send back the response */
    863            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 1, &retValue);
   \                     ??MT_SysOsalStartTimer_1: (+1)
   \   00000040   0xAB00             ADD      R3,SP,#+0
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x2061             MOVS     R0,#+97
   \   0000004A   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    864          }
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    865          
    866          /***************************************************************************************************
    867           * @fn      MT_SysOsalStopTimer
    868           *
    869           * @brief
    870           *
    871           * @param   uint8 pBuf - pointer to the data
    872           *
    873           * @return  None
    874           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    875          void MT_SysOsalStopTimer(uint8 *pBuf)
    876          {
   \                     MT_SysOsalStopTimer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    877            uint16 eventId;
    878            uint8 retValue = ZFailure;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
    879            uint8 cmdId;
    880          
    881            /* parse header */
    882            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   0000000A   0x7884             LDRB     R4,[R0, #+2]
    883            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
    884          
    885            if (*pBuf <= 3)
   \   0000000E   0x7801             LDRB     R1,[R0, #+0]
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xDA0D             BGE.N    ??MT_SysOsalStopTimer_0
    886            {
    887              eventId = (uint16) MT_SysOsalEventId[*pBuf];
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
    888              retValue = osal_stop_timerEx(MT_TaskID, eventId);
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable3_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       osal_stop_timerEx
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000002E   0xE002             B.N      ??MT_SysOsalStopTimer_1
    889            }
    890            else
    891            {
    892              retValue = ZInvalidParameter;
   \                     ??MT_SysOsalStopTimer_0: (+1)
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
    893            }
    894          
    895            /* Build and send back the response */
    896            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 1, &retValue );
   \                     ??MT_SysOsalStopTimer_1: (+1)
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x2061             MOVS     R0,#+97
   \   00000040   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    897          }
   \   00000044   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    898          
    899          /***************************************************************************************************
    900           * @fn      MT_SysRandom
    901           *
    902           * @brief
    903           *
    904           * @param   uint8 pData - pointer to the data
    905           *
    906           * @return  None
    907           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    908          void MT_SysRandom()
    909          {
   \                     MT_SysRandom: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    910            uint16 randValue = Onboard_rand();
   \   00000002   0x.... 0x....      BL       Onboard_rand
    911            uint8 retArray[2];
    912          
    913            retArray[0] = LO_UINT16(randValue);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xF88D 0x1000      STRB     R1,[SP, #+0]
    914            retArray[1] = HI_UINT16(randValue);
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x0A00             LSRS     R0,R0,#+8
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
    915          
    916            /* Build and send back the response */
    917            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_RANDOM, 2, retArray );
   \   00000014   0xAB00             ADD      R3,SP,#+0
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0x210C             MOVS     R1,#+12
   \   0000001A   0x2061             MOVS     R0,#+97
   \   0000001C   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    918          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    919          
    920          /***************************************************************************************************
    921           * @fn      MT_SysAdcRead
    922           *
    923           * @brief   Reading ADC value, temperature sensor and voltage
    924           *
    925           * @param   uint8 pBuf - pointer to the data
    926           *
    927           * @return  None
    928           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    929          void MT_SysAdcRead(uint8 *pBuf)
    930          {
   \                     MT_SysAdcRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    931          #ifndef HAL_BOARD_LM3S
    932            uint8 channel, resolution;
    933            uint16 tempValue;
    934            uint8 retArray[2];
    935            uint8 cmdId;
    936          
    937            /* parse header */
    938            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000004   0x7884             LDRB     R4,[R0, #+2]
    939            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000006   0x1CC0             ADDS     R0,R0,#+3
    940          
    941            /* Channel */
    942            channel = *pBuf++;
   \   00000008   0x7802             LDRB     R2,[R0, #+0]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
    943          
    944            /* Resolution */
    945            resolution = *pBuf++;
   \   0000000C   0x7801             LDRB     R1,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
    946          
    947            /* Voltage reading */
    948            switch (channel)
   \   00000010   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   0x0010             MOVS     R0,R2
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD904             BLS.N    ??MT_SysAdcRead_0
   \   0000001A   0x380E             SUBS     R0,R0,#+14
   \   0000001C   0xD008             BEQ.N    ??MT_SysAdcRead_1
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0xD00B             BEQ.N    ??MT_SysAdcRead_2
   \   00000022   0xE00F             B.N      ??MT_SysAdcRead_3
    949            {
    950              /* Analog input channel */
    951              case HAL_ADC_CHANNEL_0:
    952              case HAL_ADC_CHANNEL_1:
    953              case HAL_ADC_CHANNEL_2:
    954              case HAL_ADC_CHANNEL_3:
    955              case HAL_ADC_CHANNEL_4:
    956              case HAL_ADC_CHANNEL_5:
    957              case HAL_ADC_CHANNEL_6:
    958              case HAL_ADC_CHANNEL_7:
    959                tempValue = HalAdcRead(channel, resolution);
   \                     ??MT_SysAdcRead_0: (+1)
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x0010             MOVS     R0,R2
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       HalAdcRead
    960                break;
   \   0000002E   0xE00A             B.N      ??MT_SysAdcRead_4
    961          
    962              /* Temperature sensor */
    963              case(HAL_ADC_CHANNEL_TEMP):
    964                tempValue = HalAdcRead(HAL_ADC_CHANNEL_TEMP, HAL_ADC_RESOLUTION_14);
   \                     ??MT_SysAdcRead_1: (+1)
   \   00000030   0x2104             MOVS     R1,#+4
   \   00000032   0x200E             MOVS     R0,#+14
   \   00000034   0x.... 0x....      BL       HalAdcRead
    965                break;
   \   00000038   0xE005             B.N      ??MT_SysAdcRead_4
    966          
    967              /* Voltage reading */
    968              case(HAL_ADC_CHANNEL_VDD):
    969                tempValue = HalAdcRead(HAL_ADC_CHANNEL_VDD, HAL_ADC_RESOLUTION_14);
   \                     ??MT_SysAdcRead_2: (+1)
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0x200F             MOVS     R0,#+15
   \   0000003E   0x.... 0x....      BL       HalAdcRead
    970                break;
   \   00000042   0xE000             B.N      ??MT_SysAdcRead_4
    971          
    972              /* Undefined channels */
    973              default:
    974                tempValue = 0x00;
   \                     ??MT_SysAdcRead_3: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
    975                break;
    976            }
    977          
    978            retArray[0] = LO_UINT16(tempValue);
   \                     ??MT_SysAdcRead_4: (+1)
   \   00000046   0x0001             MOVS     R1,R0
   \   00000048   0xF88D 0x1000      STRB     R1,[SP, #+0]
    979            retArray[1] = HI_UINT16(tempValue);
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0x0A00             LSRS     R0,R0,#+8
   \   00000050   0xF88D 0x0001      STRB     R0,[SP, #+1]
    980          
    981            /* Build and send back the response */
    982            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 2, retArray);
   \   00000054   0xAB00             ADD      R3,SP,#+0
   \   00000056   0x2202             MOVS     R2,#+2
   \   00000058   0x0021             MOVS     R1,R4
   \   0000005A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005C   0x2061             MOVS     R0,#+97
   \   0000005E   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
    983          #endif /* #ifndef HAL_BOARD_LM3S */
    984          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    985          
    986          /**************************************************************************************************
    987           * @fn      MT_SysGpio
    988           *
    989           * @brief   ZAccel RPC interface for controlling the available GPIO pins.
    990           *
    991           * @param   uint8 pBuf - pointer to the data
    992           *
    993           * @return  None
    994           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    995          void MT_SysGpio(uint8 *pBuf)
    996          {
   \                     MT_SysGpio: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    997            uint8 cmd, val;
    998            GPIO_Op_t op;
    999          
   1000            cmd = pBuf[MT_RPC_POS_CMD1];
   \   00000002   0x7881             LDRB     R1,[R0, #+2]
   1001            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000004   0x1CC0             ADDS     R0,R0,#+3
   1002          
   1003            op = (GPIO_Op_t)(*pBuf++);
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   1004            val = *pBuf;
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1005          
   1006            switch (op)
   \   00000010   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD00C             BEQ.N    ??MT_SysGpio_0
   \   00000016   0x2A01             CMP      R2,#+1
   \   00000018   0xD00B             BEQ.N    ??MT_SysGpio_1
   \   0000001A   0x2A02             CMP      R2,#+2
   \   0000001C   0xD016             BEQ.N    ??MT_SysGpio_2
   \   0000001E   0x2A03             CMP      R2,#+3
   \   00000020   0xD015             BEQ.N    ??MT_SysGpio_3
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xD014             BEQ.N    ??MT_SysGpio_4
   \   00000026   0x2A05             CMP      R2,#+5
   \   00000028   0xD013             BEQ.N    ??MT_SysGpio_5
   \   0000002A   0x2A12             CMP      R2,#+18
   \   0000002C   0xD012             BEQ.N    ??MT_SysGpio_6
   \   0000002E   0xE021             B.N      ??MT_SysGpio_7
   1007            {
   1008              case GPIO_DIR:
   1009                if (val & BV(0)) {GPIO_DIR_OUT(0);} else {GPIO_DIR_IN(0);}
   1010                if (val & BV(1)) {GPIO_DIR_OUT(1);} else {GPIO_DIR_IN(1);}
   1011                if (val & BV(2)) {GPIO_DIR_OUT(2);} else {GPIO_DIR_IN(2);}
   1012                if (val & BV(3)) {GPIO_DIR_OUT(3);} else {GPIO_DIR_IN(3);}
   1013                break;
   \                     ??MT_SysGpio_0: (+1)
   \   00000030   0xE020             B.N      ??MT_SysGpio_8
   1014          
   1015              case GPIO_TRI:
   1016                if(val & BV(0)) {GPIO_TRI(0);} else if(val & BV(4)) {GPIO_PULL_DN(0);} else {GPIO_PULL_UP(0);}
   \                     ??MT_SysGpio_1: (+1)
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0x07C0             LSLS     R0,R0,#+31
   1017                if(val & BV(1)) {GPIO_TRI(1);} else if(val & BV(5)) {GPIO_PULL_DN(1);} else {GPIO_PULL_UP(1);}
   \                     ??MT_SysGpio_9: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x0780             LSLS     R0,R0,#+30
   1018                if(val & BV(2)) {GPIO_TRI(2);} else if(val & BV(6)) {GPIO_PULL_DN(2);} else {GPIO_PULL_UP(2);}
   \                     ??MT_SysGpio_10: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x0740             LSLS     R0,R0,#+29
   1019                if(val & BV(3)) {GPIO_TRI(3);} else if(val & BV(7)) {GPIO_PULL_DN(3);} else {GPIO_PULL_UP(3);}
   \                     ??MT_SysGpio_11: (+1)
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0x0700             LSLS     R0,R0,#+28
   1020                break;
   \                     ??MT_SysGpio_12: (+1)
   \   0000004A   0xE013             B.N      ??MT_SysGpio_8
   1021          
   1022              case GPIO_SET:
   1023                if (val & BV(0)) {GPIO_SET(0);}
   1024                if (val & BV(1)) {GPIO_SET(1);}
   1025                if (val & BV(2)) {GPIO_SET(2);}
   1026                if (val & BV(3)) {GPIO_SET(3);}
   1027                break;
   \                     ??MT_SysGpio_2: (+1)
   \   0000004C   0xE012             B.N      ??MT_SysGpio_8
   1028          
   1029              case GPIO_CLR:
   1030                if (val & BV(0)) {GPIO_CLR(0);}
   1031                if (val & BV(1)) {GPIO_CLR(1);}
   1032                if (val & BV(2)) {GPIO_CLR(2);}
   1033                if (val & BV(3)) {GPIO_CLR(3);}
   1034                break;
   \                     ??MT_SysGpio_3: (+1)
   \   0000004E   0xE011             B.N      ??MT_SysGpio_8
   1035          
   1036              case GPIO_TOG:
   1037                if (val & BV(0)) {GPIO_TOG(0);}
   1038                if (val & BV(1)) {GPIO_TOG(1);}
   1039                if (val & BV(2)) {GPIO_TOG(2);}
   1040                if (val & BV(3)) {GPIO_TOG(3);}
   1041                break;
   \                     ??MT_SysGpio_4: (+1)
   \   00000050   0xE010             B.N      ??MT_SysGpio_8
   1042          
   1043              case GPIO_GET:
   1044                break;
   \                     ??MT_SysGpio_5: (+1)
   \   00000052   0xE00F             B.N      ??MT_SysGpio_8
   1045          
   1046              case GPIO_HiD:
   1047                (val) ? GPIO_HiD_SET() :  GPIO_HiD_CLR();
   \                     ??MT_SysGpio_6: (+1)
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD005             BEQ.N    ??MT_SysGpio_13
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0xE004             B.N      ??MT_SysGpio_14
   \                     ??MT_SysGpio_13: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000006E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   1048                break;
   \                     ??MT_SysGpio_14: (+1)
   \   00000072   0xE7FF             B.N      ??MT_SysGpio_8
   1049          
   1050              default:
   1051                break;
   1052            }
   1053          
   1054            val  = (GPIO_GET(0)) ? BV(0) : 0;
   \                     ??MT_SysGpio_7: (+1)
   \                     ??MT_SysGpio_8: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1055            val |= (GPIO_GET(1)) ? BV(1) : 0;
   \   0000007A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1056            val |= (GPIO_GET(2)) ? BV(2) : 0;
   \   00000082   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000086   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1057            val |= (GPIO_GET(3)) ? BV(3) : 0;
   \   0000008A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1058          
   1059            /* Build and send back the response */
   1060            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmd, 1, &val);
   \   00000092   0xAB00             ADD      R3,SP,#+0
   \   00000094   0x2201             MOVS     R2,#+1
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0x2061             MOVS     R0,#+97
   \   0000009A   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1061          }
   \   0000009E   0xBD01             POP      {R0,PC}          ;; return
   1062          
   1063          /**************************************************************************************************
   1064           * @fn      MT_SysStackTune
   1065           *
   1066           * @brief   ZAccel RPC interface for tuning the stack parameters to adjust performance
   1067           *
   1068           * @param   uint8 pBuf - pointer to the data
   1069           *
   1070           * @return  None
   1071           *************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1072          void MT_SysStackTune(uint8 *pBuf)
   1073          {
   \                     MT_SysStackTune: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1074            uint8 cmd, rtrn;
   1075          
   1076            cmd = pBuf[MT_RPC_POS_CMD1];
   \   00000004   0x7884             LDRB     R4,[R0, #+2]
   1077            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000006   0x1CC0             ADDS     R0,R0,#+3
   1078          
   1079            switch (*pBuf++)
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0x1C48             ADDS     R0,R1,#+1
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ.N    ??MT_SysStackTune_0
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD007             BEQ.N    ??MT_SysStackTune_1
   \   00000016   0xE018             B.N      ??MT_SysStackTune_2
   1080            {
   1081            case STK_TX_PWR:
   1082              rtrn = ZMacSetReq(ZMacPhyTransmitPowerSigned, pBuf);
   \                     ??MT_SysStackTune_0: (+1)
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0x20E0             MOVS     R0,#+224
   \   0000001C   0x.... 0x....      BL       ZMacSetReq
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1083              break;
   \   00000024   0xE014             B.N      ??MT_SysStackTune_3
   1084          
   1085            case STK_RX_ON_IDLE:
   1086              if ((*pBuf != TRUE) && (*pBuf != FALSE))
   \                     ??MT_SysStackTune_1: (+1)
   \   00000026   0x7801             LDRB     R1,[R0, #+0]
   \   00000028   0x2901             CMP      R1,#+1
   \   0000002A   0xD007             BEQ.N    ??MT_SysStackTune_4
   \   0000002C   0x7801             LDRB     R1,[R0, #+0]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD004             BEQ.N    ??MT_SysStackTune_4
   1087              {
   1088                (void)ZMacGetReq(ZMacRxOnIdle, &rtrn);
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0x2052             MOVS     R0,#+82
   \   00000036   0x.... 0x....      BL       ZMacGetReq
   \   0000003A   0xE005             B.N      ??MT_SysStackTune_5
   1089              }
   1090              else
   1091              {
   1092                rtrn = ZMacSetReq(ZMacRxOnIdle, pBuf);
   \                     ??MT_SysStackTune_4: (+1)
   \   0000003C   0x0001             MOVS     R1,R0
   \   0000003E   0x2052             MOVS     R0,#+82
   \   00000040   0x.... 0x....      BL       ZMacSetReq
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1093              }
   1094              break;
   \                     ??MT_SysStackTune_5: (+1)
   \   00000048   0xE002             B.N      ??MT_SysStackTune_3
   1095          
   1096            default:
   1097              rtrn = ZInvalidParameter;
   \                     ??MT_SysStackTune_2: (+1)
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1098              break;
   1099            }
   1100          
   1101            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmd, 1, &rtrn);
   \                     ??MT_SysStackTune_3: (+1)
   \   00000050   0xAB00             ADD      R3,SP,#+0
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x2061             MOVS     R0,#+97
   \   0000005A   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1102          }
   \   0000005E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1103          
   1104          /***************************************************************************************************
   1105           * @fn      MT_SysSetUtcTime
   1106           *
   1107           * @brief   Set the OSAL UTC Time. UTC rollover is: 06:28:16 02/07/2136
   1108           *
   1109           * @param   pBuf - pointer to time parameters
   1110           *
   1111           * @return  None
   1112           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1113          void MT_SysSetUtcTime(uint8 *pBuf)
   1114          {
   \                     MT_SysSetUtcTime: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0006             MOVS     R6,R0
   1115            uint8 cmdId;
   1116            uint8 retStat;
   1117            UTCTime utcSecs;
   1118          
   1119            /* Parse header */
   1120            cmdId = pBuf[MT_RPC_POS_CMD1];
   \   00000006   0x78B4             LDRB     R4,[R6, #+2]
   1121            pBuf += MT_RPC_FRAME_HDR_SZ;
   \   00000008   0x1CF6             ADDS     R6,R6,#+3
   1122          
   1123            utcSecs = osal_build_uint32( pBuf, 4 );
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x.... 0x....      BL       osal_build_uint32
   \   00000012   0x0005             MOVS     R5,R0
   1124            if ( utcSecs == 0 )
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD160             BNE.N    ??MT_SysSetUtcTime_0
   1125            {
   1126              UTCTimeStruct utc;
   1127          
   1128              /* Skip past UTC time */
   1129              pBuf += 4;
   \   00000018   0x1D36             ADDS     R6,R6,#+4
   1130          
   1131              /* Get time and date parameters */
   1132              utc.hour = *pBuf++;
   \   0000001A   0x7830             LDRB     R0,[R6, #+0]
   \   0000001C   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   1133              utc.minutes = *pBuf++;
   \   00000022   0x7830             LDRB     R0,[R6, #+0]
   \   00000024   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   1134              utc.seconds = *pBuf++;
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   1135              utc.month = (*pBuf++) - 1;
   \   00000032   0x7830             LDRB     R0,[R6, #+0]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   1136              utc.day = (*pBuf++) - 1;
   \   0000003C   0x7830             LDRB     R0,[R6, #+0]
   \   0000003E   0x1E40             SUBS     R0,R0,#+1
   \   00000040   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   1137              utc.year = osal_build_uint16 ( pBuf );
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0x.... 0x....      BL       osal_build_uint16
   \   0000004C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1138          
   1139              if ((utc.hour < 24) && (utc.minutes < 60) && (utc.seconds < 60) &&
   1140                  (utc.month < 12) && (utc.day < 31) && (utc.year > 1999) && (utc.year < 2136))
   \   00000050   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000054   0x2818             CMP      R0,#+24
   \   00000056   0xDA40             BGE.N    ??MT_SysSetUtcTime_0
   \   00000058   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000005C   0x283C             CMP      R0,#+60
   \   0000005E   0xDA3C             BGE.N    ??MT_SysSetUtcTime_0
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0x283C             CMP      R0,#+60
   \   00000066   0xDA38             BGE.N    ??MT_SysSetUtcTime_0
   \   00000068   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000006C   0x280C             CMP      R0,#+12
   \   0000006E   0xDA34             BGE.N    ??MT_SysSetUtcTime_0
   \   00000070   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000074   0x281F             CMP      R0,#+31
   \   00000076   0xDA30             BGE.N    ??MT_SysSetUtcTime_0
   \   00000078   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   0000007C   0xF5B0 0x60FA      SUBS     R0,R0,#+2000
   \   00000080   0x2888             CMP      R0,#+136
   \   00000082   0xD22A             BCS.N    ??MT_SysSetUtcTime_0
   1141              {
   1142                /* Got past the course filter, now check for leap year */
   1143                if ((utc.month != 1) || (utc.day < (IsLeapYear( utc.year ) ? 29 : 28)))
   \   00000084   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD122             BNE.N    ??MT_SysSetUtcTime_1
   \   0000008C   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000090   0xF44F 0x71C8      MOV      R1,#+400
   \   00000094   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000098   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD011             BEQ.N    ??MT_SysSetUtcTime_2
   \   000000A0   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000000A4   0x2164             MOVS     R1,#+100
   \   000000A6   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   000000AA   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD00A             BEQ.N    ??MT_SysSetUtcTime_3
   \   000000B2   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000000B6   0x2104             MOVS     R1,#+4
   \   000000B8   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   000000BC   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000C0   0x2A00             CMP      R2,#+0
   \   000000C2   0xD101             BNE.N    ??MT_SysSetUtcTime_3
   \                     ??MT_SysSetUtcTime_2: (+1)
   \   000000C4   0x201D             MOVS     R0,#+29
   \   000000C6   0xE000             B.N      ??MT_SysSetUtcTime_4
   \                     ??MT_SysSetUtcTime_3: (+1)
   \   000000C8   0x201C             MOVS     R0,#+28
   \                     ??MT_SysSetUtcTime_4: (+1)
   \   000000CA   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000000CE   0x4281             CMP      R1,R0
   \   000000D0   0xDA03             BGE.N    ??MT_SysSetUtcTime_0
   1144                {
   1145                  /* Numbers look reasonable, convert to UTC */
   1146                  utcSecs = osal_ConvertUTCSecs( &utc );
   \                     ??MT_SysSetUtcTime_1: (+1)
   \   000000D2   0xA800             ADD      R0,SP,#+0
   \   000000D4   0x.... 0x....      BL       osal_ConvertUTCSecs
   \   000000D8   0x0005             MOVS     R5,R0
   1147                }
   1148              }
   1149            }
   1150          
   1151            if ( utcSecs == 0 )
   \                     ??MT_SysSetUtcTime_0: (+1)
   \   000000DA   0x2D00             CMP      R5,#+0
   \   000000DC   0xD103             BNE.N    ??MT_SysSetUtcTime_5
   1152            {
   1153              /* Bad parameter(s) */
   1154              retStat = ZInvalidParameter;
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000000E4   0xE005             B.N      ??MT_SysSetUtcTime_6
   1155            }
   1156            else
   1157            {
   1158              /* Parameters accepted, set the time */
   1159              osal_setClock( utcSecs );
   \                     ??MT_SysSetUtcTime_5: (+1)
   \   000000E6   0x0028             MOVS     R0,R5
   \   000000E8   0x.... 0x....      BL       osal_setClock
   1160              retStat = ZSuccess;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1161            }
   1162          
   1163            /* Build and send back the response */
   1164            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1165                                           cmdId, 1, &retStat);
   \                     ??MT_SysSetUtcTime_6: (+1)
   \   000000F2   0xAB02             ADD      R3,SP,#+8
   \   000000F4   0x2201             MOVS     R2,#+1
   \   000000F6   0x0021             MOVS     R1,R4
   \   000000F8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000FA   0x2061             MOVS     R0,#+97
   \   000000FC   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1166          }
   \   00000100   0xBD7F             POP      {R0-R6,PC}       ;; return
   1167          
   1168          /***************************************************************************************************
   1169           * @fn      MT_SysGetUtcTime
   1170           *
   1171           * @brief   Get the OSAL UTC time
   1172           *
   1173           * @param   None
   1174           *
   1175           * @return  32-bit and Parsed UTC time
   1176           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1177          void MT_SysGetUtcTime(void)
   1178          {
   \                     MT_SysGetUtcTime: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1179            uint8 len;
   1180            uint8 *buf;
   1181          
   1182            len = sizeof( UTCTime ) + sizeof( UTCTimeStruct );
   \   00000004   0x200C             MOVS     R0,#+12
   1183          
   1184            buf = osal_mem_alloc( len );
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0x.... 0x....      BL       osal_mem_alloc
   \   0000000E   0x0004             MOVS     R4,R0
   1185            if ( buf )
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD034             BEQ.N    ??MT_SysGetUtcTime_0
   1186            {
   1187              uint8 *pBuf;
   1188              UTCTime utcSecs;
   1189              UTCTimeStruct utcTime;
   1190          
   1191              // Get current 32-bit UTC time and parse it
   1192              utcSecs = osal_getClock();
   \   00000014   0x.... 0x....      BL       osal_getClock
   \   00000018   0x0005             MOVS     R5,R0
   1193              osal_ConvertUTCTime( &utcTime, utcSecs );
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x.... 0x....      BL       osal_ConvertUTCTime
   1194          
   1195              // Start with 32-bit UTC time
   1196              pBuf = osal_buffer_uint32( buf, utcSecs );
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       osal_buffer_uint32
   1197          
   1198              // Concatenate parsed UTC time fields
   1199              *pBuf++ = utcTime.hour;
   \   0000002A   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   1200              *pBuf++ = utcTime.minutes;
   \   00000032   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000036   0x7001             STRB     R1,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   1201              *pBuf++ = utcTime.seconds;
   \   0000003A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000003E   0x7001             STRB     R1,[R0, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   1202              *pBuf++ = utcTime.month + 1;  // Convert to human numbers
   \   00000042   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000046   0x1C49             ADDS     R1,R1,#+1
   \   00000048   0x7001             STRB     R1,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   1203              *pBuf++ = utcTime.day + 1;
   \   0000004C   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \   00000052   0x7001             STRB     R1,[R0, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   1204              *pBuf++ = LO_UINT16( utcTime.year );
   \   00000056   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   1205              *pBuf++ = HI_UINT16( utcTime.year );
   \   0000005E   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   00000062   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000064   0x0A09             LSRS     R1,R1,#+8
   \   00000066   0x7001             STRB     R1,[R0, #+0]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   1206          
   1207              /* Build and send back the response */
   1208              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1209                                             MT_SYS_GET_TIME, (uint8)(pBuf-buf), buf);
   \   0000006A   0x0023             MOVS     R3,R4
   \   0000006C   0x1B02             SUBS     R2,R0,R4
   \   0000006E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000070   0x2111             MOVS     R1,#+17
   \   00000072   0x2061             MOVS     R0,#+97
   \   00000074   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1210          
   1211              osal_mem_free( buf );
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       osal_mem_free
   1212            }
   1213          }
   \                     ??MT_SysGetUtcTime_0: (+1)
   \   0000007E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1214          
   1215          /***************************************************************************************************
   1216           * @fn      MT_SysSetTxPower
   1217           *
   1218           * @brief   Set the transmit power.
   1219           *
   1220           * @param   pBuf - MT message containing the ZMacTransmitPower_t power level to set.
   1221           *
   1222           * @return  None
   1223           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1224          void MT_SysSetTxPower(uint8 *pBuf)
   1225          {
   \                     MT_SysSetTxPower: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1226            /* A local variable to hold the signed dBm value of TxPower that is being requested. */
   1227            uint8 signed_dBm_of_TxPower_requeseted;
   1228          
   1229            /*
   1230             * A local variable to hold the signed dBm value of TxPower that can be set which is closest to
   1231             * the requested dBm value of TxPower, but which is also valid according to a complex set of
   1232             * compile-time and run-time configuration which is interpreted by the macRadioSetTxPower()
   1233             * function.
   1234             */
   1235            uint8 signed_dBm_of_TxPower_range_corrected;
   1236          
   1237            /* Parse the requested dBm from the RPC message. */
   1238            signed_dBm_of_TxPower_requeseted = pBuf[MT_RPC_POS_DAT0];
   \   00000002   0x78C0             LDRB     R0,[R0, #+3]
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1239          
   1240            /*
   1241             * MAC_MlmeSetReq() will store an out-of-range dBm parameter value into the NIB. So it is not
   1242             * possible to learn the actual dBm value that will be set by invoking MACMlmeGetReq().
   1243             * But this actual dBm value is a required return value in the SRSP to this SREQ. Therefore,
   1244             * it is necessary to make this redundant pre-call to macRadioSetTxPower() here in order to run
   1245             * the code that will properly constrain the requested dBm to a valid range based on both the
   1246             * compile-time and the run-time configurations that affect the available valid ranges
   1247             * (i.e. MAC_MlmeSetReq() itself will invoke for a second time the macRadioSetTxPower() function).
   1248             */
   1249            signed_dBm_of_TxPower_range_corrected = macRadioSetTxPower(signed_dBm_of_TxPower_requeseted);
   \   00000008   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000000C   0x.... 0x....      BL       macRadioSetTxPower
   \   00000010   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1250          
   1251            /*
   1252             * Call the function to store the requested dBm in the MAC PIB and to set the TxPower as closely
   1253             * as possible within the TxPower range that is valid for the compile-time and run-time
   1254             * configuration.
   1255             */
   1256            (void)MAC_MlmeSetReq(MAC_PHY_TRANSMIT_POWER_SIGNED, &signed_dBm_of_TxPower_requeseted);
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x20E0             MOVS     R0,#+224
   \   00000018   0x.... 0x....      BL       MAC_MlmeSetReq
   1257          
   1258            /* Build and send back the response that includes the actual dBm TxPower that can be set. */
   1259            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1260                                                 MT_SYS_SET_TX_POWER, 1,
   1261                                                 &signed_dBm_of_TxPower_range_corrected);
   \   0000001C   0xF10D 0x0301      ADD      R3,SP,#+1
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x2114             MOVS     R1,#+20
   \   00000024   0x2061             MOVS     R0,#+97
   \   00000026   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1262          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
   1263          
   1264          #if defined ( FEATURE_SYSTEM_STATS )
   1265          /***************************************************************************************************
   1266           * @fn      MT_SysZDiagsInitStats
   1267           *
   1268           * @brief   Initialize the statistics table in NV or restore values from
   1269           *          NV into the Statistics table in RAM
   1270           *
   1271           * @param   None
   1272           *
   1273           * @return  None
   1274           ***************************************************************************************************/
   1275          void MT_SysZDiagsInitStats(void)
   1276          {
   1277            uint8 retValue;
   1278          
   1279            retValue = ZDiagsInitStats();
   1280          
   1281            /* Build and send back the response */
   1282            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1283                                          MT_SYS_ZDIAGS_INIT_STATS, 1, &retValue);
   1284          }
   1285          
   1286          /***************************************************************************************************
   1287           * @fn      MT_SysZDiagsClearStats
   1288           *
   1289           * @brief   Clears the statistics table in RAM and NV if option flag set.
   1290           *
   1291           * @param   uint8 pBuf - pointer to the data
   1292           *
   1293           * @return  None
   1294           ***************************************************************************************************/
   1295          void MT_SysZDiagsClearStats(uint8 *pBuf)
   1296          {
   1297            uint8 cmdId;
   1298            uint8 clearNV;
   1299            uint32 sysClock;
   1300            uint8 retBuf[4];
   1301          
   1302            /* parse header */
   1303            cmdId = pBuf[MT_RPC_POS_CMD1];
   1304            pBuf += MT_RPC_FRAME_HDR_SZ;
   1305          
   1306            clearNV = *pBuf;
   1307          
   1308            /* returns the system clock of the time when the statistics were cleared */
   1309            sysClock = ZDiagsClearStats( clearNV );
   1310          
   1311            retBuf[0] = BREAK_UINT32( sysClock, 0);
   1312            retBuf[1] = BREAK_UINT32( sysClock, 1);
   1313            retBuf[2] = BREAK_UINT32( sysClock, 2);
   1314            retBuf[3] = BREAK_UINT32( sysClock, 3);
   1315          
   1316            /* Build and send back the response */
   1317            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1318                                         cmdId, 4, retBuf);
   1319          }
   1320          
   1321          /***************************************************************************************************
   1322           * @fn      MT_SysZDiagsGetStatsAttr
   1323           *
   1324           * @brief   Reads specific system (attribute) ID statistics and/or metrics.
   1325           *
   1326           * @param   uint8 pBuf - pointer to the data
   1327           *
   1328           * @return  None
   1329           ***************************************************************************************************/
   1330          void MT_SysZDiagsGetStatsAttr(uint8 *pBuf)
   1331          {
   1332            uint8 cmdId;
   1333            uint16 attributeId;
   1334            uint32 attrValue;
   1335            uint8 retBuf[4];
   1336          
   1337            /* parse header */
   1338            cmdId = pBuf[MT_RPC_POS_CMD1];
   1339            pBuf += MT_RPC_FRAME_HDR_SZ;
   1340          
   1341            /* Get the Attribute ID */
   1342            attributeId = BUILD_UINT16(pBuf[0], pBuf[1]);
   1343          
   1344            attrValue = ZDiagsGetStatsAttr( attributeId );
   1345          
   1346            retBuf[0] = BREAK_UINT32( attrValue, 0);
   1347            retBuf[1] = BREAK_UINT32( attrValue, 1);
   1348            retBuf[2] = BREAK_UINT32( attrValue, 2);
   1349            retBuf[3] = BREAK_UINT32( attrValue, 3);
   1350          
   1351            /* Build and send back the response */
   1352            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1353                                         cmdId, 4, retBuf);
   1354          }
   1355          
   1356          /***************************************************************************************************
   1357           * @fn      MT_SysZDiagsRestoreStatsFromNV
   1358           *
   1359           * @brief   Restores the statistics table from NV into the RAM table.
   1360           *
   1361           * @param   None
   1362           *
   1363           * @return  None
   1364           ***************************************************************************************************/
   1365          void MT_SysZDiagsRestoreStatsFromNV(void)
   1366          {
   1367            uint8 retValue;
   1368          
   1369            retValue = ZDiagsRestoreStatsFromNV();
   1370          
   1371            /* Build and send back the response */
   1372            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1373                                          MT_SYS_ZDIAGS_RESTORE_STATS_NV, 1, &retValue);
   1374          }
   1375          
   1376          /***************************************************************************************************
   1377           * @fn      MT_SysZDiagsSaveStatsToNV
   1378           *
   1379           * @brief   Saves the statistics table from RAM to NV.
   1380           *
   1381           * @param   None
   1382           *
   1383           * @return  None
   1384           ***************************************************************************************************/
   1385          void MT_SysZDiagsSaveStatsToNV(void)
   1386          {
   1387            uint32 sysClock;
   1388            uint8 retBuf[4];
   1389          
   1390            /* returns the system clock of the time when the statistics were saved to NV */
   1391            sysClock = ZDiagsSaveStatsToNV();
   1392          
   1393            retBuf[0] = BREAK_UINT32( sysClock, 0);
   1394            retBuf[1] = BREAK_UINT32( sysClock, 1);
   1395            retBuf[2] = BREAK_UINT32( sysClock, 2);
   1396            retBuf[3] = BREAK_UINT32( sysClock, 3);
   1397          
   1398            /* Build and send back the response */
   1399            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1400                                         MT_SYS_ZDIAGS_SAVE_STATS_TO_NV, 4, retBuf);
   1401          }
   1402          #endif /* FEATURE_SYSTEM_STATS */
   1403          
   1404          #endif /* MT_SYS_FUNC */
   1405          
   1406          /***************************************************************************************************
   1407           * SUPPORT
   1408           ***************************************************************************************************/
   1409          
   1410          /***************************************************************************************************
   1411           * @fn      MT_SysResetInd()
   1412           *
   1413           * @brief   Sends a ZTOOL "reset response" message.
   1414           *
   1415           * @param   None
   1416           *
   1417           * @return  None
   1418           *
   1419           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1420          void MT_SysResetInd(void)
   1421          {
   \                     MT_SysResetInd: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1422            uint8 retArray[6];
   1423          
   1424            retArray[0] = ResetReason();   /* Reason */
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1425            osal_memcpy( &retArray[1], MTVersionString, 5 );   /* Revision info */
   \   0000000A   0x2205             MOVS     R2,#+5
   \   0000000C   0x....             LDR.N    R1,??DataTable3
   \   0000000E   0xF10D 0x0001      ADD      R0,SP,#+1
   \   00000012   0x.... 0x....      BL       osal_memcpy
   1426          
   1427            /* Send out Reset Response message */
   1428            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_SYS), MT_SYS_RESET_IND,
   1429                                          sizeof(retArray), retArray);
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x2206             MOVS     R2,#+6
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x2041             MOVS     R0,#+65
   \   0000001E   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1430          }
   \   00000022   0xBD07             POP      {R0-R2,PC}       ;; return
   1431          
   1432          /***************************************************************************************************
   1433           * @fn      MT_SysOsalTimerExpired()
   1434           *
   1435           * @brief   Sends a SYS Osal Timer Expired
   1436           *
   1437           * @param   None
   1438           *
   1439           * @return  None
   1440           *
   1441           ***************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1442          void MT_SysOsalTimerExpired(uint8 Id)
   1443          {
   \                     MT_SysOsalTimerExpired: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1444            uint8 retValue;
   1445            retValue = Id;
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1446            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_SYS), MT_SYS_OSAL_TIMER_EXPIRED, 1, &retValue);
   \   00000006   0xAB00             ADD      R3,SP,#+0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x2181             MOVS     R1,#+129
   \   0000000C   0x2041             MOVS     R0,#+65
   \   0000000E   0x.... 0x....      BL       MT_BuildAndSendZToolResponse
   1447          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   1448          
   1449          #if defined ( MT_SYS_JAMMER_FEATURE )
   1450          /***************************************************************************************************
   1451           * @fn      MT_SysJammerParameters
   1452           *
   1453           * @brief   Set the Jammer detection parameters.
   1454           *
   1455           * @param   pBuf - MT message containing the parameters.
   1456           *
   1457           * @return  None
   1458           ***************************************************************************************************/
   1459          void MT_SysJammerParameters( uint8 *pBuf )
   1460          {
   1461            uint8 status = SUCCESS;
   1462            
   1463            // Adjust for the data
   1464            pBuf += MT_RPC_FRAME_HDR_SZ;
   1465            
   1466            // Number of continuous events needed to detect Jam
   1467            jammerContinuousEvents = BUILD_UINT16( pBuf[0], pBuf[1] );
   1468            jammerDetections = jammerContinuousEvents;
   1469            pBuf += 2;
   1470            
   1471            // Noise Level need to be a Jam
   1472            jammerHighNoiseLevel = *pBuf++;
   1473            
   1474            // The time between each noise level reading
   1475            jammerDetectPeriodTime = BUILD_UINT32( pBuf[0], pBuf[1], pBuf[2], pBuf[3] );
   1476            
   1477            // Update the timer
   1478            osal_start_reload_timer( jammerTaskID, JAMMER_CHECK_EVT, jammerDetectPeriodTime );
   1479            
   1480            /* Build and send back the response that includes the actual dBm TxPower that can be set. */
   1481            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1482                                                 MT_SYS_JAMMER_PARAMETERS, 1, &status );
   1483          }
   1484          
   1485          /***************************************************************************************************
   1486           * @fn      MT_SysJammerInd()
   1487           *
   1488           * @brief   Sends a jammer indication message.
   1489           *
   1490           * @param   jammerInd - TRUE if jammer detected, FALSE if changed to undetected
   1491           *
   1492           * @return  None
   1493           *
   1494           ***************************************************************************************************/
   1495          void MT_SysJammerInd( uint8 jammerInd )
   1496          {
   1497            /* Send out Reset Response message */
   1498            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_SYS), MT_SYS_JAMMER_IND,
   1499                                          1, &jammerInd );
   1500          }
   1501          
   1502          /***************************************************************************************************
   1503           * @fn      jammerInit()
   1504           *
   1505           * @brief   Jammer Detection task initialization function
   1506           *
   1507           * @param   taskId - task ID 
   1508           *
   1509           * @return  None
   1510           *
   1511           ***************************************************************************************************/
   1512          void jammerInit( uint8 taskId )
   1513          {
   1514            jammerTaskID = taskId; 
   1515            
   1516            // Start the jammer check timer
   1517            osal_start_reload_timer( taskId, JAMMER_CHECK_EVT, jammerDetectPeriodTime );
   1518          }
   1519          
   1520          /***************************************************************************************************
   1521           * @fn      jammerEventLoop()
   1522           *
   1523           * @brief   Jammer Detection task event processing function
   1524           *
   1525           * @param   taskId - task ID 
   1526           * @param   events - task events 
   1527           *
   1528           * @return  remaining events
   1529           *
   1530           ***************************************************************************************************/
   1531          uint16 jammerEventLoop( uint8 taskId, uint16 events )
   1532          {
   1533            osal_event_hdr_t  *pMsg;
   1534          
   1535            if (events & SYS_EVENT_MSG)
   1536            {
   1537              if ( (pMsg = (osal_event_hdr_t *) osal_msg_receive( taskId )) != NULL )
   1538              {
   1539                switch ( pMsg->event )
   1540                {
   1541                  default:
   1542                    break;
   1543                }
   1544          
   1545                osal_msg_deallocate( (byte *)pMsg );
   1546              }
   1547          
   1548              events ^= SYS_EVENT_MSG;
   1549            }
   1550            else if ( events & JAMMER_CHECK_EVT )
   1551            {
   1552              // Make sure we aren't currently receiving a message
   1553              // and the radio is active.
   1554              if ( MAC_RX_IS_PHYSICALLY_ACTIVE() == MAC_RX_ACTIVE_NO_ACTIVITY )
   1555              {
   1556                int8 rssiDbm = -128;
   1557                
   1558                // Read the noise level
   1559                if ( RSSISTAT & 0x01 )
   1560                {
   1561                  /* Add the RSSI offset */  
   1562                  rssiDbm = RSSI + MAC_RADIO_RSSI_OFFSET;
   1563          
   1564                  /* Adjust for external PA/LNA, if any */
   1565                  MAC_RADIO_RSSI_LNA_OFFSET( rssiDbm );
   1566                
   1567                  // Check for a noise level that's high
   1568                  if ( jammerDetections && (rssiDbm  > jammerHighNoiseLevel) )
   1569                  {
   1570                    jammerDetections--;
   1571                    if ( jammerDetections == 0 )
   1572                    {
   1573                      // Jam detected
   1574                      MT_SysJammerInd( TRUE );
   1575                    }
   1576                  }
   1577                  else if ( rssiDbm <= jammerHighNoiseLevel )
   1578                  {
   1579                    if ( jammerDetections == 0 )
   1580                    {
   1581                      // Jam cleared
   1582                      MT_SysJammerInd( FALSE );
   1583                    }
   1584                    jammerDetections = jammerContinuousEvents;
   1585                  }
   1586                }
   1587              }
   1588              events ^= JAMMER_CHECK_EVT;
   1589            }
   1590            else
   1591            {
   1592              events = 0;  /* Discard unknown events. */
   1593            }
   1594          
   1595            return ( events );
   1596          }
   1597          #endif // MT_SYS_JAMMER_FEATURE
   1598          
   1599          #if defined ( MT_SYS_SNIFFER_FEATURE )
   1600          /***************************************************************************************************
   1601           * @fn      MT_SysSnifferParameters
   1602           *
   1603           * @brief   Set the sniffer parameters.
   1604           *
   1605           * @param   pBuf - MT message containing the parameters.
   1606           *
   1607           * @return  None
   1608           ***************************************************************************************************/
   1609          void MT_SysSnifferParameters( uint8 *pBuf )
   1610          {
   1611            uint8 status = SUCCESS;
   1612            uint8 param;
   1613            
   1614            // Adjust for the data
   1615            pBuf += MT_RPC_FRAME_HDR_SZ;
   1616            
   1617            // Noise Level need to be a Jam
   1618            param = *pBuf++;
   1619            
   1620            if ( param == MT_SYS_SNIFFER_DISABLE )
   1621            {
   1622              // Disable Sniffer
   1623              HAL_BOARD_DISABLE_INTEGRATED_SNIFFER();
   1624              sniffer = FALSE;
   1625            }
   1626            else if ( param == MT_SYS_SNIFFER_ENABLE )
   1627            {
   1628              // Enable the Sniffer
   1629              HAL_BOARD_ENABLE_INTEGRATED_SNIFFER();
   1630              sniffer = TRUE;
   1631            }
   1632            else if ( param == MT_SYS_SNIFFER_GET_SETTING )
   1633            {
   1634              status = sniffer; // sniffer setting
   1635            }
   1636            else 
   1637            {
   1638              status = INVALIDPARAMETER;
   1639            }
   1640            
   1641            /* Build and send back the response that includes the actual dBm TxPower that can be set. */
   1642            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
   1643                                                 MT_SYS_SNIFFER_PARAMETERS, 1, &status );
   1644          }
   1645          #endif // MT_SYS_SNIFFER_FEATURE
   1646          
   1647          /**************************************************************************************************
   1648           * @fn          powerOffSoc
   1649           *
   1650           * @brief       put the device in lowest power mode infinitely.
   1651           *
   1652           * input parameters
   1653           *
   1654           * None.
   1655           *
   1656           * output parameters
   1657           *
   1658           * None.
   1659           *
   1660           * @return      None.
   1661           **************************************************************************************************
   1662           */

   \                                 In section .text, align 2, keep-with-next
   1663          void powerOffSoc(void)
   1664          {
   1665          #ifdef ENABLE_MT_SYS_RESET_SHUTDOWN
   1666            HAL_DISABLE_INTERRUPTS();
   1667          
   1668            /* turn off the RF front end device */
   1669            //TBD, based on the rf-front-end being used
   1670          
   1671            /* turn off the receiver */
   1672            MAC_RADIO_RXTX_OFF();
   1673            
   1674            /* just in case a receive was about to start, flush the receive FIFO */
   1675            MAC_RADIO_FLUSH_RX_FIFO();
   1676            
   1677            /* clear any receive interrupt that happened to squeak through */
   1678            MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
   1679            
   1680            /* put MAC timer to sleep */
   1681            MAC_RADIO_TIMER_SLEEP();
   1682            
   1683            /* power of radio */
   1684            MAC_RADIO_TURN_OFF_POWER();
   1685            
   1686            STIF = 0; //HAL_SLEEP_TIMER_CLEAR_INT;
   1687            
   1688            if (ZNP_CFG1_UART == znpCfg1)
   1689            {
   1690              HalUARTSuspend();
   1691            }
   1692            
   1693            /* Prep CC2530 power mode */
   1694            //HAL_SLEEP_PREP_POWER_MODE(3);
   1695            SLEEPCMD &= ~PMODE; /* clear mode bits */
   1696            SLEEPCMD |= 3;      /* set mode bits  to PM3 */
   1697            while (!(STLOAD & LDRDY));
   1698            
   1699            while (1) //just in case we wake up for some unknown reason
   1700            {
   1701              PCON = halSleepPconValue; //execution is suppose to halt with this command. Interrupts are disabled, so the only way to exit this state is using a hardware reset.
   1702              asm("NOP");
   1703            }
   1704          #endif
   1705          }
   \                     powerOffSoc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     MTVersionString

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     MT_SysOsalEventId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     MT_TaskID
   1706          
   1707          /***************************************************************************************************
   1708           ***************************************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MT_SysAdcRead
        16   -> HalAdcRead
        16   -> MT_BuildAndSendZToolResponse
       8   MT_SysCommandProcessing
         8   -> MT_SysAdcRead
         8   -> MT_SysGetExtAddr
         8   -> MT_SysGetUtcTime
         8   -> MT_SysGpio
         8   -> MT_SysOsalNVDelete
         8   -> MT_SysOsalNVItemInit
         8   -> MT_SysOsalNVLength
         8   -> MT_SysOsalNVRead
         8   -> MT_SysOsalNVWrite
         8   -> MT_SysOsalStartTimer
         8   -> MT_SysOsalStopTimer
         8   -> MT_SysPing
         8   -> MT_SysRandom
         8   -> MT_SysReset
         8   -> MT_SysSetExtAddr
         8   -> MT_SysSetTxPower
         8   -> MT_SysSetUtcTime
         8   -> MT_SysStackTune
         8   -> MT_SysVersion
      16   MT_SysGetExtAddr
        16   -> MT_BuildAndSendZToolResponse
        16   -> ZMacGetReq
      24   MT_SysGetUtcTime
        24   -> MT_BuildAndSendZToolResponse
        24   -> osal_ConvertUTCTime
        24   -> osal_buffer_uint32
        24   -> osal_getClock
        24   -> osal_mem_alloc
        24   -> osal_mem_free
       8   MT_SysGpio
         8   -> MT_BuildAndSendZToolResponse
       8   MT_SysOsalNVDelete
         8   -> MT_BuildAndSendZToolResponse
         8   -> osal_nv_delete
      24   MT_SysOsalNVItemInit
        24   -> MT_BuildAndSendZToolResponse
        24   -> osal_nv_item_init
        24   -> osal_nv_write
       8   MT_SysOsalNVLength
         8   -> MT_BuildAndSendZToolResponse
         8   -> osal_nv_item_len
      40   MT_SysOsalNVRead
        40   -> MT_BuildAndSendZToolResponse
        40   -> osal_mem_alloc
        40   -> osal_mem_free
        40   -> osal_memset
        40   -> osal_nv_item_len
        40   -> osal_nv_read
      32   MT_SysOsalNVWrite
        32   -> MT_BuildAndSendZToolResponse
        32   -> ZMacSetReq
        32   -> osal_nv_item_len
        32   -> osal_nv_write
        32   -> zgSetItem
      16   MT_SysOsalStartTimer
        16   -> MT_BuildAndSendZToolResponse
        16   -> osal_start_timerEx
      16   MT_SysOsalStopTimer
        16   -> MT_BuildAndSendZToolResponse
        16   -> osal_stop_timerEx
       8   MT_SysOsalTimerExpired
         8   -> MT_BuildAndSendZToolResponse
       8   MT_SysPing
         8   -> MT_BuildAndSendZToolResponse
       8   MT_SysRandom
         8   -> MT_BuildAndSendZToolResponse
         8   -> Onboard_rand
       8   MT_SysReset
         8   -> SysCtrlReset
         8   -> powerOffSoc
      16   MT_SysResetInd
        16   -> MT_BuildAndSendZToolResponse
        16   -> osal_memcpy
      16   MT_SysSetExtAddr
        16   -> MT_BuildAndSendZToolResponse
        16   -> ZMacSetReq
        16   -> osal_nv_write
       8   MT_SysSetTxPower
         8   -> MAC_MlmeSetReq
         8   -> MT_BuildAndSendZToolResponse
         8   -> macRadioSetTxPower
      32   MT_SysSetUtcTime
        32   -> MT_BuildAndSendZToolResponse
        32   -> osal_ConvertUTCSecs
        32   -> osal_build_uint16
        32   -> osal_build_uint32
        32   -> osal_setClock
      16   MT_SysStackTune
        16   -> MT_BuildAndSendZToolResponse
        16   -> ZMacGetReq
        16   -> ZMacSetReq
       8   MT_SysVersion
         8   -> MT_BuildAndSendZToolResponse
       0   powerOffSoc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       2  ?_0
     100  MT_SysAdcRead
     226  MT_SysCommandProcessing
      26  MT_SysGetExtAddr
     128  MT_SysGetUtcTime
     160  MT_SysGpio
       8  MT_SysOsalEventId
      48  MT_SysOsalNVDelete
     120  MT_SysOsalNVItemInit
      46  MT_SysOsalNVLength
     296  MT_SysOsalNVRead
     182  MT_SysOsalNVWrite
      80  MT_SysOsalStartTimer
      70  MT_SysOsalStopTimer
      20  MT_SysOsalTimerExpired
      32  MT_SysPing
      34  MT_SysRandom
      34  MT_SysReset
      36  MT_SysResetInd
      58  MT_SysSetExtAddr
      44  MT_SysSetTxPower
     258  MT_SysSetUtcTime
      96  MT_SysStackTune
      18  MT_SysVersion
       2  powerOffSoc

 
    10 bytes in section .rodata
 2 126 bytes in section .text
 
 2 126 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
